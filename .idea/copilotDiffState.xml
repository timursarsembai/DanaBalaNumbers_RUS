<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/AchievementManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/AchievementManager.kt" />
              <option name="updatedContent" value="package com.example.danabala&#10;&#10;import android.content.Context&#10;&#10;class AchievementManager(context: Context) {&#10;    private val progressManager = ProgressManager(context)&#10;    &#10;    data class Achievement(&#10;        val id: String,&#10;        val title: String,&#10;        val description: String,&#10;        val emoji: String,&#10;        val isUnlocked: Boolean = false&#10;    )&#10;&#10;    fun checkAchievements(trainingType: String): List&lt;Achievement&gt; {&#10;        val newAchievements = mutableListOf&lt;Achievement&gt;()&#10;        val completed = progressManager.getCompletedTrainings(trainingType)&#10;        val successRate = progressManager.getSuccessRate(trainingType)&#10;        val bestScore = progressManager.getBestScore(trainingType)&#10;&#10;        // Достижения за количество тренировок&#10;        when (completed) {&#10;            1 -&gt; newAchievements.add(Achievement(&#10;                &quot;${trainingType}_first&quot;, &quot;Первые шаги&quot;, &#10;                &quot;Прошел первую тренировку!&quot;, &quot;&quot;&#10;            ))&#10;            5 -&gt; newAchievements.add(Achievement(&#10;                &quot;${trainingType}_5th&quot;, &quot;Упорный ученик&quot;, &#10;                &quot;Прошел 5 тренировок!&quot;, &quot;&quot;&#10;            ))&#10;            10 -&gt; newAchievements.add(Achievement(&#10;                &quot;${trainingType}_10th&quot;, &quot;Знаток&quot;, &#10;                &quot;Прошел 10 тренировок!&quot;, &quot;&quot;&#10;            ))&#10;        }&#10;&#10;        // Достижения за качество&#10;        if (successRate &gt;= 90 &amp;&amp; completed &gt;= 3) {&#10;            newAchievements.add(Achievement(&#10;                &quot;${trainingType}_perfectionist&quot;, &quot;Перфекционист&quot;, &#10;                &quot;Успешность 90%+!&quot;, &quot;⭐&quot;&#10;            ))&#10;        }&#10;&#10;        // Достижения за безошибочное прохождение&#10;        if (trainingType == &quot;numbers&quot; &amp;&amp; bestScore &gt;= 18) {&#10;            newAchievements.add(Achievement(&#10;                &quot;${trainingType}_master&quot;, &quot;Мастер цифр&quot;, &#10;                &quot;Почти идеальный результат!&quot;, &quot;&quot;&#10;            ))&#10;        } else if (trainingType == &quot;letters&quot; &amp;&amp; bestScore &gt;= 30) {&#10;            newAchievements.add(Achievement(&#10;                &quot;${trainingType}_master&quot;, &quot;Мастер букв&quot;, &#10;                &quot;Почти идеальный результат!&quot;, &quot;&quot;&#10;            ))&#10;        }&#10;&#10;        return newAchievements&#10;    }&#10;&#10;    fun getAllAchievements(): List&lt;Achievement&gt; {&#10;        return listOf(&#10;            // Математика&#10;            Achievement(&quot;numbers_first&quot;, &quot;Первые шаги&quot;, &quot;Прошел первую тренировку по математике!&quot;, &quot;&quot;),&#10;            Achievement(&quot;numbers_5th&quot;, &quot;Упорный ученик&quot;, &quot;Прошел 5 тренировок по математике!&quot;, &quot;&quot;),&#10;            Achievement(&quot;numbers_10th&quot;, &quot;Знаток математики&quot;, &quot;Прошел 10 тренировок по математике!&quot;, &quot;&quot;),&#10;            Achievement(&quot;numbers_perfectionist&quot;, &quot;Перфекционист&quot;, &quot;Успешность 90%+ в математике!&quot;, &quot;⭐&quot;),&#10;            Achievement(&quot;numbers_master&quot;, &quot;Мастер цифр&quot;, &quot;Почти идеальный результат!&quot;, &quot;&quot;),&#10;            &#10;            // Чтение&#10;            Achievement(&quot;letters_first&quot;, &quot;Первые шаги&quot;, &quot;Прошел первую тренировку по чтению!&quot;, &quot;&quot;),&#10;            Achievement(&quot;letters_5th&quot;, &quot;Упорный ученик&quot;, &quot;Прошел 5 тренировок по чтению!&quot;, &quot;&quot;),&#10;            Achievement(&quot;letters_10th&quot;, &quot;Знаток чтения&quot;, &quot;Прошел 10 тренировок по чтению!&quot;, &quot;&quot;),&#10;            Achievement(&quot;letters_perfectionist&quot;, &quot;Перфекционист&quot;, &quot;Успешность 90%+ в чтении!&quot;, &quot;⭐&quot;),&#10;            Achievement(&quot;letters_master&quot;, &quot;Мастер букв&quot;, &quot;Почти идеальный результат!&quot;, &quot;&quot;)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/LetterRecognitionActivityFixed.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/LetterRecognitionActivityFixed.kt" />
              <option name="updatedContent" value="package com.example.danabala&#10;&#10;import android.animation.AnimatorSet&#10;import android.animation.ObjectAnimator&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import android.util.Log&#10;import android.view.View&#10;import android.view.animation.BounceInterpolator&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import java.util.*&#10;import kotlin.random.Random&#10;&#10;class LetterRecognitionActivityFixed : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var targetLetter = &quot;А&quot;&#10;    private var currentQuestion = 0&#10;    private val totalQuestions = 33 // 33 буквы в русском алфавите&#10;    private var tts: TextToSpeech? = null&#10;    private var isTtsReady = false&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var currentQuestionText = &quot;&quot;&#10;&#10;    // Переменные для отслеживания ошибок&#10;    private var correctAnswersCount = 0&#10;    private var answersWithErrors = 0&#10;    private var currentQuestionHasError = false&#10;&#10;    // Список доступных букв для избежания повторов&#10;    private val availableLetters = mutableListOf&lt;String&gt;()&#10;&#10;    // Русский алфавит&#10;    private val russianAlphabet = arrayOf(&#10;        &quot;А&quot;, &quot;Б&quot;, &quot;В&quot;, &quot;Г&quot;, &quot;Д&quot;, &quot;Е&quot;, &quot;Ё&quot;, &quot;Ж&quot;, &quot;З&quot;, &quot;И&quot;, &quot;Й&quot;, &quot;К&quot;, &quot;Л&quot;, &quot;М&quot;, &quot;Н&quot;, &quot;О&quot;, &quot;П&quot;,&#10;        &quot;Р&quot;, &quot;С&quot;, &quot;Т&quot;, &quot;У&quot;, &quot;Ф&quot;, &quot;Х&quot;, &quot;Ц&quot;, &quot;Ч&quot;, &quot;Ш&quot;, &quot;Щ&quot;, &quot;Ъ&quot;, &quot;Ы&quot;, &quot;Ь&quot;, &quot;Э&quot;, &quot;Ю&quot;, &quot;Я&quot;&#10;    )&#10;&#10;    // Правильное произношение букв для TTS&#10;    private val letterPronunciation = mapOf(&#10;        &quot;А&quot; to &quot;А&quot;,&#10;        &quot;Б&quot; to &quot;БЭ&quot;,&#10;        &quot;В&quot; to &quot;ВЭ&quot;,&#10;        &quot;Г&quot; to &quot;ГЭ&quot;,&#10;        &quot;Д&quot; to &quot;ДЭ&quot;,&#10;        &quot;Е&quot; to &quot;Е&quot;,&#10;        &quot;Ё&quot; to &quot;Ё&quot;,&#10;        &quot;Ж&quot; to &quot;ЖЭ&quot;,&#10;        &quot;З&quot; to &quot;ЗЭ&quot;,&#10;        &quot;И&quot; to &quot;И&quot;,&#10;        &quot;Й&quot; to &quot;И КРАТКОЕ&quot;,&#10;        &quot;К&quot; to &quot;КА&quot;,&#10;        &quot;Л&quot; to &quot;ЭЛЬ&quot;,&#10;        &quot;М&quot; to &quot;ЭМ&quot;,&#10;        &quot;Н&quot; to &quot;ЭН&quot;,&#10;        &quot;О&quot; to &quot;ОООО&quot;,&#10;        &quot;П&quot; to &quot;ПЭ&quot;,&#10;        &quot;Р&quot; to &quot;ЭР&quot;,&#10;        &quot;С&quot; to &quot;ЭС&quot;,&#10;        &quot;Т&quot; to &quot;ТЭ&quot;,&#10;        &quot;У&quot; to &quot;У&quot;,&#10;        &quot;Ф&quot; to &quot;ЭФ&quot;,&#10;        &quot;Х&quot; to &quot;ХА&quot;,&#10;        &quot;Ц&quot; to &quot;ЦЭ&quot;,&#10;        &quot;Ч&quot; to &quot;ЧЭ&quot;,&#10;        &quot;Ш&quot; to &quot;ША&quot;,&#10;        &quot;Щ&quot; to &quot;ЩА&quot;,&#10;        &quot;Ъ&quot; to &quot;ТВЁРДЫЙ ЗНАК&quot;,&#10;        &quot;Ы&quot; to &quot;Ы&quot;,&#10;        &quot;Ь&quot; to &quot;МЯГКИЙ ЗНАК&quot;,&#10;        &quot;Э&quot; to &quot;Э&quot;,&#10;        &quot;Ю&quot; to &quot;Ю&quot;,&#10;        &quot;Я&quot; to &quot;Я&quot;&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_letter_recognition)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        // Инициализация списка доступных букв&#10;        initializeAvailableLetters()&#10;&#10;        // Инициализация TTS&#10;        tts = TextToSpeech(this, this)&#10;&#10;        setupBackButton()&#10;        setupSpeakerButton()&#10;        &#10;        // Убираем текст вопроса - делаем его невидимым&#10;        findViewById&lt;TextView&gt;(R.id.questionText).visibility = View.GONE&#10;        &#10;        startNewQuestion()&#10;    }&#10;&#10;    private fun initializeAvailableLetters() {&#10;        availableLetters.clear()&#10;        availableLetters.addAll(russianAlphabet)&#10;        availableLetters.shuffle()&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val result = tts?.setLanguage(Locale(&quot;ru&quot;))&#10;            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                Log.e(&quot;TTS&quot;, &quot;Русский язык не поддерживается, используем английский&quot;)&#10;                tts?.language = Locale.getDefault()&#10;            }&#10;            isTtsReady = true&#10;&#10;            // Озвучиваем вопрос сразу, если он уже готов&#10;            if (currentQuestionText.isNotEmpty()) {&#10;                // Небольшая задержка для первого вопроса&#10;                handler.postDelayed({&#10;                    speakQuestion()&#10;                }, 500)&#10;            }&#10;        } else {&#10;            Log.e(&quot;TTS&quot;, &quot;Инициализация TTS не удалась&quot;)&#10;        }&#10;    }&#10;&#10;    private fun setupBackButton() {&#10;        findViewById&lt;View&gt;(R.id.backButton).setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun setupSpeakerButton() {&#10;        findViewById&lt;ImageView&gt;(R.id.speakerButton).setOnClickListener {&#10;            speakQuestion()&#10;        }&#10;    }&#10;&#10;    private fun speakQuestion() {&#10;        if (isTtsReady &amp;&amp; currentQuestionText.isNotEmpty()) {&#10;            tts?.speak(currentQuestionText, TextToSpeech.QUEUE_FLUSH, null, &quot;question&quot;)&#10;        }&#10;    }&#10;&#10;    private fun vibrateOnError() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            val vibratorManager = getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            val vibrator = vibratorManager.defaultVibrator&#10;            vibrator.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val vibrator = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                vibrator.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                vibrator.vibrate(200)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startNewQuestion() {&#10;        if (currentQuestion &gt;= totalQuestions) {&#10;            showResultsScreen()&#10;            return&#10;        }&#10;&#10;        currentQuestion++&#10;        currentQuestionHasError = false&#10;&#10;        // Получаем следующую букву из списка доступных&#10;        if (availableLetters.isEmpty()) {&#10;            initializeAvailableLetters()&#10;        }&#10;        targetLetter = availableLetters.removeAt(0)&#10;&#10;        // Обновляем вопрос с правильным произношением&#10;        val letterName = letterPronunciation[targetLetter] ?: targetLetter&#10;        val questionText = &quot;Найди букву $letterName&quot;&#10;        currentQuestionText = questionText&#10;&#10;        // Озвучиваем вопрос (если TTS готов)&#10;        if (isTtsReady) {&#10;            speakQuestion()&#10;        }&#10;&#10;        // Обновляем прогресс-бар&#10;        val progressBar = findViewById&lt;ProgressBar&gt;(R.id.progressBar)&#10;        progressBar.progress = (currentQuestion * 100) / totalQuestions&#10;&#10;        // Генерируем 4 случайные буквы, одна из которых правильная&#10;        val letters = generateLetterOptions(targetLetter)&#10;&#10;        val cards = listOf(&#10;            findViewById&lt;CardView&gt;(R.id.card1),&#10;            findViewById&lt;CardView&gt;(R.id.card2),&#10;            findViewById&lt;CardView&gt;(R.id.card3),&#10;            findViewById&lt;CardView&gt;(R.id.card4)&#10;        )&#10;&#10;        val letterTexts = listOf(&#10;            findViewById&lt;TextView&gt;(R.id.letter1),&#10;            findViewById&lt;TextView&gt;(R.id.letter2),&#10;            findViewById&lt;TextView&gt;(R.id.letter3),&#10;            findViewById&lt;TextView&gt;(R.id.letter4)&#10;        )&#10;&#10;        // Заполняем карточки&#10;        for (i in 0..3) {&#10;            letterTexts[i].text = letters[i]&#10;            cards[i].setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.white))&#10;            cards[i].isClickable = true&#10;            animateCardEntrance(cards[i], i * 100L)&#10;&#10;            cards[i].setOnClickListener {&#10;                checkAnswer(letters[i], cards[i])&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun animateCardEntrance(card: CardView, delay: Long) {&#10;        card.alpha = 0f&#10;        card.scaleX = 0.5f&#10;        card.scaleY = 0.5f&#10;&#10;        card.animate()&#10;            .alpha(1f)&#10;            .scaleX(1f)&#10;            .scaleY(1f)&#10;            .setDuration(300)&#10;            .setStartDelay(delay)&#10;            .setInterpolator(BounceInterpolator())&#10;            .start()&#10;    }&#10;&#10;    private fun generateLetterOptions(correct: String): List&lt;String&gt; {&#10;        val options = mutableSetOf&lt;String&gt;()&#10;        options.add(correct)&#10;&#10;        while (options.size &lt; 4) {&#10;            val randomLetter = russianAlphabet[Random.nextInt(russianAlphabet.size)]&#10;            options.add(randomLetter)&#10;        }&#10;&#10;        return options.shuffled()&#10;    }&#10;&#10;    private fun checkAnswer(selectedLetter: String, selectedCard: CardView) {&#10;        if (selectedLetter == targetLetter) {&#10;            // Правильный ответ&#10;            if (currentQuestionHasError) {&#10;                answersWithErrors++&#10;            } else {&#10;                correctAnswersCount++&#10;            }&#10;&#10;            animateCorrectAnswer(selectedCard)&#10;            tts?.speak(&quot;Молодец!&quot;, TextToSpeech.QUEUE_FLUSH, null, &quot;correct&quot;)&#10;            disableAllCards()&#10;&#10;            handler.postDelayed({&#10;                startNewQuestion()&#10;            }, 2000)&#10;        } else {&#10;            // Неправильный ответ&#10;            currentQuestionHasError = true&#10;            animateWrongAnswer(selectedCard)&#10;            vibrateOnError()&#10;            tts?.speak(&quot;Попробуй ещё раз, у тебя получится!&quot;, TextToSpeech.QUEUE_FLUSH, null, &quot;wrong&quot;)&#10;            selectedCard.isClickable = false&#10;        }&#10;    }&#10;&#10;    private fun disableAllCards() {&#10;        val cards = listOf(&#10;            findViewById&lt;CardView&gt;(R.id.card1),&#10;            findViewById&lt;CardView&gt;(R.id.card2),&#10;            findViewById&lt;CardView&gt;(R.id.card3),&#10;            findViewById&lt;CardView&gt;(R.id.card4)&#10;        )&#10;        cards.forEach { it.isClickable = false }&#10;    }&#10;&#10;    private fun animateCorrectAnswer(card: CardView) {&#10;        card.setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.holo_green_light))&#10;&#10;        val scaleUpX = ObjectAnimator.ofFloat(card, &quot;scaleX&quot;, 1f, 1.3f)&#10;        val scaleUpY = ObjectAnimator.ofFloat(card, &quot;scaleY&quot;, 1f, 1.3f)&#10;        val scaleDownX = ObjectAnimator.ofFloat(card, &quot;scaleX&quot;, 1.3f, 1f)&#10;        val scaleDownY = ObjectAnimator.ofFloat(card, &quot;scaleY&quot;, 1.3f, 1f)&#10;&#10;        val animatorSet = AnimatorSet()&#10;        animatorSet.play(scaleUpX).with(scaleUpY)&#10;        animatorSet.play(scaleDownX).with(scaleDownY).after(scaleUpX)&#10;        animatorSet.duration = 200&#10;        animatorSet.start()&#10;    }&#10;&#10;    private fun animateWrongAnswer(card: CardView) {&#10;        card.setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.holo_red_light))&#10;&#10;        val shake = ObjectAnimator.ofFloat(card, &quot;translationX&quot;, 0f, 25f, -25f, 25f, -25f, 15f, -15f, 6f, -6f, 0f)&#10;        shake.duration = 500&#10;        shake.start()&#10;    }&#10;&#10;    private fun showResultsScreen() {&#10;        val intent = Intent(this, ResultsActivity::class.java)&#10;        intent.putExtra(&quot;score&quot;, correctAnswersCount)&#10;        intent.putExtra(&quot;total&quot;, totalQuestions)&#10;        intent.putExtra(&quot;correctAnswersCount&quot;, correctAnswersCount)&#10;        intent.putExtra(&quot;answersWithErrors&quot;, answersWithErrors)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/LetterRecognitionActivity_fixed.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/LetterRecognitionActivity_fixed.kt" />
              <option name="updatedContent" value="package com.example.danabala&#10;&#10;import android.animation.AnimatorSet&#10;import android.animation.ObjectAnimator&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import android.util.Log&#10;import android.view.View&#10;import android.view.animation.BounceInterpolator&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import java.util.*&#10;import kotlin.random.Random&#10;&#10;class LetterRecognitionActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var targetLetter = &quot;А&quot;&#10;    private var currentQuestion = 0&#10;    private val totalQuestions = 33 // 33 буквы в русском алфавите&#10;    private var tts: TextToSpeech? = null&#10;    private var isTtsReady = false&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var currentQuestionText = &quot;&quot;&#10;&#10;    // Переменные для отслеживания ошибок&#10;    private var correctAnswersCount = 0&#10;    private var answersWithErrors = 0&#10;    private var currentQuestionHasError = false&#10;&#10;    // Список доступных букв для избежания повторов&#10;    private val availableLetters = mutableListOf&lt;String&gt;()&#10;&#10;    // Русский алфавит&#10;    private val russianAlphabet = arrayOf(&#10;        &quot;А&quot;, &quot;Б&quot;, &quot;В&quot;, &quot;Г&quot;, &quot;Д&quot;, &quot;Е&quot;, &quot;Ё&quot;, &quot;Ж&quot;, &quot;З&quot;, &quot;И&quot;, &quot;Й&quot;, &quot;К&quot;, &quot;Л&quot;, &quot;М&quot;, &quot;Н&quot;, &quot;О&quot;, &quot;П&quot;,&#10;        &quot;Р&quot;, &quot;С&quot;, &quot;Т&quot;, &quot;У&quot;, &quot;Ф&quot;, &quot;Х&quot;, &quot;Ц&quot;, &quot;Ч&quot;, &quot;Ш&quot;, &quot;Щ&quot;, &quot;Ъ&quot;, &quot;Ы&quot;, &quot;Ь&quot;, &quot;Э&quot;, &quot;Ю&quot;, &quot;Я&quot;&#10;    )&#10;&#10;    // Правильное произношение букв для TTS&#10;    private val letterPronunciation = mapOf(&#10;        &quot;А&quot; to &quot;А&quot;,&#10;        &quot;Б&quot; to &quot;БЭ&quot;, &#10;        &quot;В&quot; to &quot;ВЭ&quot;,&#10;        &quot;Г&quot; to &quot;ГЭ&quot;,&#10;        &quot;Д&quot; to &quot;ДЭ&quot;,&#10;        &quot;Е&quot; to &quot;Е&quot;,&#10;        &quot;Ё&quot; to &quot;Ё&quot;,&#10;        &quot;Ж&quot; to &quot;ЖЭ&quot;,&#10;        &quot;З&quot; to &quot;ЗЭ&quot;,&#10;        &quot;И&quot; to &quot;И&quot;,&#10;        &quot;Й&quot; to &quot;И КРАТКОЕ&quot;,&#10;        &quot;К&quot; to &quot;КА&quot;,&#10;        &quot;Л&quot; to &quot;ЭЛЬ&quot;,&#10;        &quot;М&quot; to &quot;ЭМ&quot;,&#10;        &quot;Н&quot; to &quot;ЭН&quot;,&#10;        &quot;О&quot; to &quot;О-О&quot;,&#10;        &quot;П&quot; to &quot;ПЭ&quot;,&#10;        &quot;Р&quot; to &quot;ЭР&quot;,&#10;        &quot;С&quot; to &quot;ЭС&quot;,&#10;        &quot;Т&quot; to &quot;ТЭ&quot;,&#10;        &quot;У&quot; to &quot;У&quot;,&#10;        &quot;Ф&quot; to &quot;ЭФ&quot;,&#10;        &quot;Х&quot; to &quot;ХА&quot;,&#10;        &quot;Ц&quot; to &quot;ЦЭ&quot;,&#10;        &quot;Ч&quot; to &quot;ЧЭ&quot;,&#10;        &quot;Ш&quot; to &quot;ША&quot;,&#10;        &quot;Щ&quot; to &quot;ЩА&quot;,&#10;        &quot;Ъ&quot; to &quot;ТВЁРДЫЙ ЗНАК&quot;,&#10;        &quot;Ы&quot; to &quot;Ы&quot;,&#10;        &quot;Ь&quot; to &quot;МЯГКИЙ ЗНАК&quot;,&#10;        &quot;Э&quot; to &quot;Э&quot;,&#10;        &quot;Ю&quot; to &quot;Ю&quot;,&#10;        &quot;Я&quot; to &quot;Я&quot;&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_letter_recognition)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        // Инициализация списка доступных букв&#10;        initializeAvailableLetters()&#10;&#10;        // Инициализация TTS&#10;        tts = TextToSpeech(this, this)&#10;&#10;        setupBackButton()&#10;        setupSpeakerButton()&#10;        startNewQuestion()&#10;    }&#10;&#10;    private fun initializeAvailableLetters() {&#10;        availableLetters.clear()&#10;        availableLetters.addAll(russianAlphabet)&#10;        availableLetters.shuffle()&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val result = tts?.setLanguage(Locale(&quot;ru&quot;))&#10;            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                Log.e(&quot;TTS&quot;, &quot;Русский язык не поддерживается, используем английский&quot;)&#10;                tts?.language = Locale.getDefault()&#10;            }&#10;            isTtsReady = true&#10;&#10;            // Озвучиваем вопрос сразу, если он уже готов&#10;            if (currentQuestionText.isNotEmpty()) {&#10;                speakQuestion()&#10;            }&#10;        } else {&#10;            Log.e(&quot;TTS&quot;, &quot;Инициализация TTS не удалась&quot;)&#10;        }&#10;    }&#10;&#10;    private fun setupBackButton() {&#10;        findViewById&lt;View&gt;(R.id.backButton).setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun setupSpeakerButton() {&#10;        findViewById&lt;ImageView&gt;(R.id.speakerButton).setOnClickListener {&#10;            speakQuestion()&#10;        }&#10;    }&#10;&#10;    private fun speakQuestion() {&#10;        if (isTtsReady &amp;&amp; currentQuestionText.isNotEmpty()) {&#10;            tts?.speak(currentQuestionText, TextToSpeech.QUEUE_FLUSH, null, &quot;question&quot;)&#10;        }&#10;    }&#10;&#10;    private fun vibrateOnError() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            val vibratorManager = getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            val vibrator = vibratorManager.defaultVibrator&#10;            vibrator.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val vibrator = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                vibrator.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                vibrator.vibrate(200)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startNewQuestion() {&#10;        if (currentQuestion &gt;= totalQuestions) {&#10;            showResultsScreen()&#10;            return&#10;        }&#10;&#10;        currentQuestion++&#10;        currentQuestionHasError = false&#10;&#10;        // Получаем следующую букву из списка доступных&#10;        if (availableLetters.isEmpty()) {&#10;            initializeAvailableLetters()&#10;        }&#10;        targetLetter = availableLetters.removeAt(0)&#10;&#10;        // Формируем текст вопроса с правильным произношением для TTS&#10;        val letterName = letterPronunciation[targetLetter] ?: targetLetter&#10;        currentQuestionText = &quot;Найди букву $letterName&quot;&#10;&#10;        // Озвучиваем вопрос сразу (если TTS готов)&#10;        if (isTtsReady) {&#10;            speakQuestion()&#10;        }&#10;&#10;        // Обновляем прогресс-бар&#10;        val progressBar = findViewById&lt;ProgressBar&gt;(R.id.progressBar)&#10;        progressBar.progress = (currentQuestion * 100) / totalQuestions&#10;&#10;        // Генерируем 4 случайные буквы, одна из которых правильная&#10;        val letters = generateLetterOptions(targetLetter)&#10;&#10;        val cards = listOf(&#10;            findViewById&lt;CardView&gt;(R.id.card1),&#10;            findViewById&lt;CardView&gt;(R.id.card2),&#10;            findViewById&lt;CardView&gt;(R.id.card3),&#10;            findViewById&lt;CardView&gt;(R.id.card4)&#10;        )&#10;&#10;        val letterTexts = listOf(&#10;            findViewById&lt;TextView&gt;(R.id.letter1),&#10;            findViewById&lt;TextView&gt;(R.id.letter2),&#10;            findViewById&lt;TextView&gt;(R.id.letter3),&#10;            findViewById&lt;TextView&gt;(R.id.letter4)&#10;        )&#10;&#10;        // Заполняем карточки&#10;        for (i in 0..3) {&#10;            letterTexts[i].text = letters[i]&#10;            cards[i].setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.white))&#10;            cards[i].isClickable = true&#10;            animateCardEntrance(cards[i], i * 100L)&#10;&#10;            cards[i].setOnClickListener {&#10;                checkAnswer(letters[i], cards[i])&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun animateCardEntrance(card: CardView, delay: Long) {&#10;        card.alpha = 0f&#10;        card.scaleX = 0.5f&#10;        card.scaleY = 0.5f&#10;&#10;        card.animate()&#10;            .alpha(1f)&#10;            .scaleX(1f)&#10;            .scaleY(1f)&#10;            .setDuration(300)&#10;            .setStartDelay(delay)&#10;            .setInterpolator(BounceInterpolator())&#10;            .start()&#10;    }&#10;&#10;    private fun generateLetterOptions(correct: String): List&lt;String&gt; {&#10;        val options = mutableSetOf&lt;String&gt;()&#10;        options.add(correct)&#10;&#10;        while (options.size &lt; 4) {&#10;            val randomLetter = russianAlphabet[Random.nextInt(russianAlphabet.size)]&#10;            options.add(randomLetter)&#10;        }&#10;&#10;        return options.shuffled()&#10;    }&#10;&#10;    private fun checkAnswer(selectedLetter: String, selectedCard: CardView) {&#10;        if (selectedLetter == targetLetter) {&#10;            // Правильный ответ&#10;            if (currentQuestionHasError) {&#10;                answersWithErrors++&#10;            } else {&#10;                correctAnswersCount++&#10;            }&#10;&#10;            animateCorrectAnswer(selectedCard)&#10;            tts?.speak(&quot;Молодец!&quot;, TextToSpeech.QUEUE_FLUSH, null, &quot;correct&quot;)&#10;            disableAllCards()&#10;&#10;            handler.postDelayed({&#10;                startNewQuestion()&#10;            }, 2000)&#10;        } else {&#10;            // Неправильный ответ&#10;            currentQuestionHasError = true&#10;            animateWrongAnswer(selectedCard)&#10;            vibrateOnError()&#10;            tts?.speak(&quot;Попробуй ещё раз, у тебя получится!&quot;, TextToSpeech.QUEUE_FLUSH, null, &quot;wrong&quot;)&#10;            selectedCard.isClickable = false&#10;        }&#10;    }&#10;&#10;    private fun disableAllCards() {&#10;        val cards = listOf(&#10;            findViewById&lt;CardView&gt;(R.id.card1),&#10;            findViewById&lt;CardView&gt;(R.id.card2),&#10;            findViewById&lt;CardView&gt;(R.id.card3),&#10;            findViewById&lt;CardView&gt;(R.id.card4)&#10;        )&#10;        cards.forEach { it.isClickable = false }&#10;    }&#10;&#10;    private fun animateCorrectAnswer(card: CardView) {&#10;        card.setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.holo_green_light))&#10;&#10;        val scaleUpX = ObjectAnimator.ofFloat(card, &quot;scaleX&quot;, 1f, 1.3f)&#10;        val scaleUpY = ObjectAnimator.ofFloat(card, &quot;scaleY&quot;, 1f, 1.3f)&#10;        val scaleDownX = ObjectAnimator.ofFloat(card, &quot;scaleX&quot;, 1.3f, 1f)&#10;        val scaleDownY = ObjectAnimator.ofFloat(card, &quot;scaleY&quot;, 1.3f, 1f)&#10;&#10;        val animatorSet = AnimatorSet()&#10;        animatorSet.play(scaleUpX).with(scaleUpY)&#10;        animatorSet.play(scaleDownX).with(scaleDownY).after(scaleUpX)&#10;        animatorSet.duration = 200&#10;        animatorSet.start()&#10;    }&#10;&#10;    private fun animateWrongAnswer(card: CardView) {&#10;        card.setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.holo_red_light))&#10;&#10;        val shake = ObjectAnimator.ofFloat(card, &quot;translationX&quot;, 0f, 25f, -25f, 25f, -25f, 15f, -15f, 6f, -6f, 0f)&#10;        shake.duration = 500&#10;        shake.start()&#10;    }&#10;&#10;    private fun showResultsScreen() {&#10;        val intent = Intent(this, ResultsActivity::class.java)&#10;        intent.putExtra(&quot;score&quot;, correctAnswersCount)&#10;        intent.putExtra(&quot;total&quot;, totalQuestions)&#10;        intent.putExtra(&quot;correctAnswersCount&quot;, correctAnswersCount)&#10;        intent.putExtra(&quot;answersWithErrors&quot;, answersWithErrors)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/MatchingActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/MatchingActivity.kt" />
              <option name="originalContent" value="package com.timursarsembayev.danabalanumbersnumbers&#10;&#10;import android.animation.Animator&#10;import android.animation.AnimatorListenerAdapter&#10;import android.animation.ValueAnimator&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import java.util.Locale&#10;import kotlin.random.Random&#10;&#10;class MatchingActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private lateinit var numbersRecyclerView: RecyclerView&#10;    private lateinit var objectsRecyclerView: RecyclerView&#10;    private lateinit var numbersAdapter: NumbersAdapter&#10;    private lateinit var objectsAdapter: ObjectsAdapter&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var backButton: ImageView&#10;&#10;    private var currentLevel = 1&#10;    private var totalLevels = 10&#10;    private var levels = mutableListOf&lt;MatchingLevel&gt;()&#10;    private var currentLevelData: MatchingLevel? = null&#10;&#10;    private var selectedNumberItem: MatchingItem? = null&#10;    private var selectedObjectItem: MatchingItem? = null&#10;    private var selectedNumberView: View? = null&#10;    private var selectedObjectView: View? = null&#10;&#10;    private var completedMatches = 0&#10;    private var totalScore = 0&#10;    private var correctActions = 0&#10;    private var incorrectActions = 0&#10;&#10;    private lateinit var tts: TextToSpeech&#10;    private var isTtsReady = false&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_matching)&#10;&#10;        initTTS()&#10;        initViews()&#10;        initData()&#10;        setupRecyclerViews()&#10;        loadLevel(currentLevel)&#10;    }&#10;&#10;    private fun initTTS() {&#10;        tts = TextToSpeech(this, this)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val result = tts.setLanguage(Locale(&quot;ru&quot;))&#10;            isTtsReady = result != TextToSpeech.LANG_MISSING_DATA &amp;&amp; result != TextToSpeech.LANG_NOT_SUPPORTED&#10;        }&#10;    }&#10;&#10;    private fun speakText(text: String) {&#10;        if (isTtsReady) {&#10;            tts.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;    }&#10;&#10;    private fun initViews() {&#10;        numbersRecyclerView = findViewById(R.id.numbersRecyclerView)&#10;        objectsRecyclerView = findViewById(R.id.objectsRecyclerView)&#10;        progressBar = findViewById(R.id.progressBar)&#10;        backButton = findViewById(R.id.backButton)&#10;&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun initData() {&#10;        levels = MatchingGameData.generateAllLevels().toMutableList()&#10;    }&#10;&#10;    private fun setupRecyclerViews() {&#10;        numbersAdapter = NumbersAdapter(mutableListOf()) { item, view -&gt;&#10;            onNumberItemClick(item, view)&#10;        }&#10;&#10;        objectsAdapter = ObjectsAdapter(mutableListOf()) { item, view -&gt;&#10;            onObjectItemClick(item, view)&#10;        }&#10;&#10;        numbersRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@MatchingActivity)&#10;            adapter = numbersAdapter&#10;        }&#10;&#10;        objectsRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@MatchingActivity)&#10;            adapter = objectsAdapter&#10;        }&#10;    }&#10;&#10;    private fun loadLevel(level: Int) {&#10;        currentLevelData = levels[level - 1]&#10;        updateProgressBar()&#10;        completedMatches = 0&#10;&#10;        // Перемешиваем элементы для случайного порядка&#10;        val numbers = currentLevelData!!.pairs.map { it.number }.shuffled()&#10;        val objects = currentLevelData!!.pairs.map { it.objects }.shuffled()&#10;&#10;        numbersAdapter.updateItems(numbers)&#10;        objectsAdapter.updateItems(objects)&#10;&#10;        // Сбрасываем выделения&#10;        clearSelections()&#10;&#10;        // Сбрасываем прозрачность всех view после анимаций&#10;        resetViewsAlpha()&#10;    }&#10;&#10;    private fun updateProgressBar() {&#10;        val progress = (currentLevel * 100) / totalLevels&#10;        progressBar.progress = progress&#10;    }&#10;&#10;    private fun resetViewsAlpha() {&#10;        // Сбрасываем прозрачность для всех элементов RecyclerView&#10;        numbersRecyclerView.post {&#10;            for (i in 0 until numbersRecyclerView.childCount) {&#10;                val child = numbersRecyclerView.getChildAt(i)&#10;                child.alpha = 1.0f&#10;                child.scaleX = 1.0f&#10;                child.scaleY = 1.0f&#10;            }&#10;        }&#10;&#10;        objectsRecyclerView.post {&#10;            for (i in 0 until objectsRecyclerView.childCount) {&#10;                val child = objectsRecyclerView.getChildAt(i)&#10;                child.alpha = 1.0f&#10;                child.scaleX = 1.0f&#10;                child.scaleY = 1.0f&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun onNumberItemClick(item: MatchingItem, view: View) {&#10;        if (item.isMatched) return&#10;&#10;        // Убираем предыдущее выделение&#10;        selectedNumberView?.setBackgroundResource(0)&#10;&#10;        if (selectedNumberItem == item) {&#10;            // Отменяем выделение&#10;            clearSelections()&#10;            return&#10;        }&#10;&#10;        selectedNumberItem = item&#10;        selectedNumberView = view&#10;&#10;        // Выделяем элемент&#10;        view.setBackgroundResource(android.R.drawable.editbox_background)&#10;&#10;        // Проверяем совпадение&#10;        checkMatch()&#10;    }&#10;&#10;    private fun onObjectItemClick(item: MatchingItem, view: View) {&#10;        if (item.isMatched) return&#10;&#10;        // Убираем предыдущее выделение&#10;        selectedObjectView?.setBackgroundResource(0)&#10;&#10;        if (selectedObjectItem == item) {&#10;            // Отменяем выделение&#10;            clearSelections()&#10;            return&#10;        }&#10;&#10;        selectedObjectItem = item&#10;        selectedObjectView = view&#10;&#10;        // Выделяем элемент&#10;        view.setBackgroundResource(android.R.drawable.editbox_background)&#10;&#10;        // Проверяем совпадение&#10;        checkMatch()&#10;    }&#10;&#10;    private fun checkMatch() {&#10;        val numberItem = selectedNumberItem&#10;        val objectItem = selectedObjectItem&#10;&#10;        if (numberItem != null &amp;&amp; objectItem != null) {&#10;            if (numberItem.value == objectItem.value) {&#10;                // Правильное совпадение!&#10;                onCorrectMatch(numberItem, objectItem)&#10;            } else {&#10;                // Неправильное совпадение&#10;                onIncorrectMatch()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun onCorrectMatch(numberItem: MatchingItem, objectItem: MatchingItem) {&#10;        // Увеличиваем счетчик правильных действий&#10;        correctActions++&#10;&#10;        // Озвучиваем поощрение&#10;        val randomPhrase = MatchingFeedbackPhrases.correctPhrases[Random.nextInt(MatchingFeedbackPhrases.correctPhrases.size)]&#10;        speakText(randomPhrase)&#10;&#10;        // Отмечаем элементы как сопоставленные&#10;        numberItem.isMatched = true&#10;        objectItem.isMatched = true&#10;&#10;        // Анимация успешного совпадения&#10;        animateMatch(selectedNumberView!!, selectedObjectView!!) {&#10;            // После анимации удаляем элементы с эффектом падения&#10;            numbersAdapter.removeItem(numberItem)&#10;            objectsAdapter.removeItem(objectItem)&#10;&#10;            completedMatches++&#10;&#10;            // Проверяем завершение уровня&#10;            if (completedMatches &gt;= 5) {&#10;                onLevelCompleted()&#10;            }&#10;        }&#10;&#10;        clearSelections()&#10;    }&#10;&#10;    private fun onIncorrectMatch() {&#10;        // Увеличиваем счетчик неправильных действий&#10;        incorrectActions++&#10;&#10;        // Озвучиваем подбадривание&#10;        val randomPhrase = MatchingFeedbackPhrases.incorrectPhrases[Random.nextInt(MatchingFeedbackPhrases.incorrectPhrases.size)]&#10;        speakText(randomPhrase)&#10;&#10;        // Анимация неправильного совпадения&#10;        animateIncorrectMatch(selectedNumberView!!, selectedObjectView!!)&#10;        clearSelections()&#10;    }&#10;&#10;    private fun animateMatch(view1: View, view2: View, onComplete: () -&gt; Unit) {&#10;        val animator1 = ValueAnimator.ofFloat(1f, 0f)&#10;        val animator2 = ValueAnimator.ofFloat(1f, 0f)&#10;&#10;        animator1.duration = 300&#10;        animator2.duration = 300&#10;&#10;        animator1.addUpdateListener { animation -&gt;&#10;            val alpha = animation.animatedValue as Float&#10;            view1.alpha = alpha&#10;            view1.scaleX = alpha&#10;            view1.scaleY = alpha&#10;        }&#10;&#10;        animator2.addUpdateListener { animation -&gt;&#10;            val alpha = animation.animatedValue as Float&#10;            view2.alpha = alpha&#10;            view2.scaleX = alpha&#10;            view2.scaleY = alpha&#10;        }&#10;&#10;        animator1.addListener(object : AnimatorListenerAdapter() {&#10;            override fun onAnimationEnd(animation: Animator) {&#10;                onComplete()&#10;            }&#10;        })&#10;&#10;        animator1.start()&#10;        animator2.start()&#10;    }&#10;&#10;    private fun animateIncorrectMatch(view1: View, view2: View) {&#10;        // Анимация тряски для неправильного совпадения&#10;        val shake = ValueAnimator.ofFloat(0f, 25f, -25f, 25f, -25f, 15f, -15f, 6f, -6f, 0f)&#10;        shake.duration = 600&#10;&#10;        shake.addUpdateListener { animation -&gt;&#10;            val translateX = animation.animatedValue as Float&#10;            view1.translationX = translateX&#10;            view2.translationX = translateX&#10;        }&#10;&#10;        shake.addListener(object : AnimatorListenerAdapter() {&#10;            override fun onAnimationEnd(animation: Animator) {&#10;                view1.translationX = 0f&#10;                view2.translationX = 0f&#10;            }&#10;        })&#10;&#10;        shake.start()&#10;    }&#10;&#10;    private fun clearSelections() {&#10;        selectedNumberItem = null&#10;        selectedObjectItem = null&#10;        selectedNumberView?.setBackgroundResource(0)&#10;        selectedObjectView?.setBackgroundResource(0)&#10;        selectedNumberView = null&#10;        selectedObjectView = null&#10;    }&#10;&#10;    private fun onLevelCompleted() {&#10;        if (currentLevel &lt; totalLevels) {&#10;            // Убираем задержку - сразу переходим на следующий уровень&#10;            currentLevel++&#10;            loadLevel(currentLevel)&#10;        } else {&#10;            // Переход к экрану результатов без задержки&#10;            showResults()&#10;        }&#10;    }&#10;&#10;    private fun showResults() {&#10;        // Вычисляем итоговые очки: +10 за правильные действия, -5 за ошибки&#10;        val finalScore = (correctActions * 10) - (incorrectActions * 5)&#10;&#10;        val intent = Intent(this, MatchingResultsActivity::class.java)&#10;        intent.putExtra(&quot;completed_levels&quot;, currentLevel)&#10;        intent.putExtra(&quot;correct_actions&quot;, correctActions)&#10;        intent.putExtra(&quot;incorrect_actions&quot;, incorrectActions)&#10;        intent.putExtra(&quot;final_score&quot;, finalScore)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        if (::tts.isInitialized) {&#10;            tts.stop()&#10;            tts.shutdown()&#10;        }&#10;        super.onDestroy()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.animation.Animator&#10;import android.animation.AnimatorListenerAdapter&#10;import android.animation.ValueAnimator&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import java.util.Locale&#10;import kotlin.random.Random&#10;&#10;class MatchingActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private lateinit var numbersRecyclerView: RecyclerView&#10;    private lateinit var objectsRecyclerView: RecyclerView&#10;    private lateinit var numbersAdapter: NumbersAdapter&#10;    private lateinit var objectsAdapter: ObjectsAdapter&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var backButton: ImageView&#10;&#10;    private var currentLevel = 1&#10;    private var totalLevels = 10&#10;    private var levels = mutableListOf&lt;MatchingLevel&gt;()&#10;    private var currentLevelData: MatchingLevel? = null&#10;&#10;    private var selectedNumberItem: MatchingItem? = null&#10;    private var selectedObjectItem: MatchingItem? = null&#10;    private var selectedNumberView: View? = null&#10;    private var selectedObjectView: View? = null&#10;&#10;    private var completedMatches = 0&#10;    private var totalScore = 0&#10;    private var correctActions = 0&#10;    private var incorrectActions = 0&#10;&#10;    private lateinit var tts: TextToSpeech&#10;    private var isTtsReady = false&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_matching)&#10;&#10;        initTTS()&#10;        initViews()&#10;        initData()&#10;        setupRecyclerViews()&#10;        loadLevel(currentLevel)&#10;    }&#10;&#10;    private fun initTTS() {&#10;        tts = TextToSpeech(this, this)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val result = tts.setLanguage(Locale(&quot;ru&quot;))&#10;            isTtsReady = result != TextToSpeech.LANG_MISSING_DATA &amp;&amp; result != TextToSpeech.LANG_NOT_SUPPORTED&#10;        }&#10;    }&#10;&#10;    private fun speakText(text: String) {&#10;        if (isTtsReady) {&#10;            tts.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;    }&#10;&#10;    private fun initViews() {&#10;        numbersRecyclerView = findViewById(R.id.numbersRecyclerView)&#10;        objectsRecyclerView = findViewById(R.id.objectsRecyclerView)&#10;        progressBar = findViewById(R.id.progressBar)&#10;        backButton = findViewById(R.id.backButton)&#10;&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun initData() {&#10;        levels = MatchingGameData.generateAllLevels().toMutableList()&#10;    }&#10;&#10;    private fun setupRecyclerViews() {&#10;        numbersAdapter = NumbersAdapter(mutableListOf()) { item, view -&gt;&#10;            onNumberItemClick(item, view)&#10;        }&#10;&#10;        objectsAdapter = ObjectsAdapter(mutableListOf()) { item, view -&gt;&#10;            onObjectItemClick(item, view)&#10;        }&#10;&#10;        numbersRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@MatchingActivity)&#10;            adapter = numbersAdapter&#10;        }&#10;&#10;        objectsRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@MatchingActivity)&#10;            adapter = objectsAdapter&#10;        }&#10;    }&#10;&#10;    private fun loadLevel(level: Int) {&#10;        currentLevelData = levels[level - 1]&#10;        updateProgressBar()&#10;        completedMatches = 0&#10;&#10;        // Перемешиваем элементы для случайного порядка&#10;        val numbers = currentLevelData!!.pairs.map { it.number }.shuffled()&#10;        val objects = currentLevelData!!.pairs.map { it.objects }.shuffled()&#10;&#10;        numbersAdapter.updateItems(numbers)&#10;        objectsAdapter.updateItems(objects)&#10;&#10;        // Сбрасываем выделения&#10;        clearSelections()&#10;&#10;        // Сбрасываем прозрачность всех view пос��е анимаций&#10;        resetViewsAlpha()&#10;    }&#10;&#10;    private fun updateProgressBar() {&#10;        val progress = (currentLevel * 100) / totalLevels&#10;        progressBar.progress = progress&#10;    }&#10;&#10;    private fun resetViewsAlpha() {&#10;        // Сбрасываем прозрачность для всех элементов RecyclerView&#10;        numbersRecyclerView.post {&#10;            for (i in 0 until numbersRecyclerView.childCount) {&#10;                val child = numbersRecyclerView.getChildAt(i)&#10;                child.alpha = 1.0f&#10;                child.scaleX = 1.0f&#10;                child.scaleY = 1.0f&#10;            }&#10;        }&#10;&#10;        objectsRecyclerView.post {&#10;            for (i in 0 until objectsRecyclerView.childCount) {&#10;                val child = objectsRecyclerView.getChildAt(i)&#10;                child.alpha = 1.0f&#10;                child.scaleX = 1.0f&#10;                child.scaleY = 1.0f&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun onNumberItemClick(item: MatchingItem, view: View) {&#10;        if (item.isMatched) return&#10;&#10;        // Убираем предыдущее выделение&#10;        selectedNumberView?.setBackgroundResource(0)&#10;&#10;        if (selectedNumberItem == item) {&#10;            // Отменяем выделение&#10;            clearSelections()&#10;            return&#10;        }&#10;&#10;        selectedNumberItem = item&#10;        selectedNumberView = view&#10;&#10;        // Выделяем элемент&#10;        view.setBackgroundResource(android.R.drawable.editbox_background)&#10;&#10;        // Проверяем совпадение&#10;        checkMatch()&#10;    }&#10;&#10;    private fun onObjectItemClick(item: MatchingItem, view: View) {&#10;        if (item.isMatched) return&#10;&#10;        // Убираем предыдущее выделение&#10;        selectedObjectView?.setBackgroundResource(0)&#10;&#10;        if (selectedObjectItem == item) {&#10;            // Отменяем выделение&#10;            clearSelections()&#10;            return&#10;        }&#10;&#10;        selectedObjectItem = item&#10;        selectedObjectView = view&#10;&#10;        // Выделяем элемент&#10;        view.setBackgroundResource(android.R.drawable.editbox_background)&#10;&#10;        // Проверяем совпаден��е&#10;        checkMatch()&#10;    }&#10;&#10;    private fun checkMatch() {&#10;        val numberItem = selectedNumberItem&#10;        val objectItem = selectedObjectItem&#10;&#10;        if (numberItem != null &amp;&amp; objectItem != null) {&#10;            if (numberItem.value == objectItem.value) {&#10;                // Правильное совпадение!&#10;                onCorrectMatch(numberItem, objectItem)&#10;            } else {&#10;                // Неправильное совпадение&#10;                onIncorrectMatch()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun onCorrectMatch(numberItem: MatchingItem, objectItem: MatchingItem) {&#10;        // Увеличиваем счетчик правильных действий&#10;        correctActions++&#10;&#10;        // Озвучиваем поощрение&#10;        val randomPhrase = MatchingFeedbackPhrases.correctPhrases[Random.nextInt(MatchingFeedbackPhrases.correctPhrases.size)]&#10;        speakText(randomPhrase)&#10;&#10;        // Отмечаем элементы как сопоставленные&#10;        numberItem.isMatched = true&#10;        objectItem.isMatched = true&#10;&#10;        // Анимация успешного совпадения&#10;        animateMatch(selectedNumberView!!, selectedObjectView!!) {&#10;            // После анимации удаляем элементы с эффектом падения&#10;            numbersAdapter.removeItem(numberItem)&#10;            objectsAdapter.removeItem(objectItem)&#10;&#10;            completedMatches++&#10;&#10;            // Проверяем завершение уровня&#10;            if (completedMatches &gt;= 5) {&#10;                onLevelCompleted()&#10;            }&#10;        }&#10;&#10;        clearSelections()&#10;    }&#10;&#10;    private fun onIncorrectMatch() {&#10;        // Увеличиваем счетчик неправильных действий&#10;        incorrectActions++&#10;&#10;        // Озвучиваем подбадривание&#10;        val randomPhrase = MatchingFeedbackPhrases.incorrectPhrases[Random.nextInt(MatchingFeedbackPhrases.incorrectPhrases.size)]&#10;        speakText(randomPhrase)&#10;&#10;        // Анимация неправильного совпадения&#10;        animateIncorrectMatch(selectedNumberView!!, selectedObjectView!!)&#10;        clearSelections()&#10;    }&#10;&#10;    private fun animateMatch(view1: View, view2: View, onComplete: () -&gt; Unit) {&#10;        val animator1 = ValueAnimator.ofFloat(1f, 0f)&#10;        val animator2 = ValueAnimator.ofFloat(1f, 0f)&#10;&#10;        animator1.duration = 300&#10;        animator2.duration = 300&#10;&#10;        animator1.addUpdateListener { animation -&gt;&#10;            val alpha = animation.animatedValue as Float&#10;            view1.alpha = alpha&#10;            view1.scaleX = alpha&#10;            view1.scaleY = alpha&#10;        }&#10;&#10;        animator2.addUpdateListener { animation -&gt;&#10;            val alpha = animation.animatedValue as Float&#10;            view2.alpha = alpha&#10;            view2.scaleX = alpha&#10;            view2.scaleY = alpha&#10;        }&#10;&#10;        animator1.addListener(object : AnimatorListenerAdapter() {&#10;            override fun onAnimationEnd(animation: Animator) {&#10;                onComplete()&#10;            }&#10;        })&#10;&#10;        animator1.start()&#10;        animator2.start()&#10;    }&#10;&#10;    private fun animateIncorrectMatch(view1: View, view2: View) {&#10;        // Анимация тряски для неправильного совпадения&#10;        val shake = ValueAnimator.ofFloat(0f, 25f, -25f, 25f, -25f, 15f, -15f, 6f, -6f, 0f)&#10;        shake.duration = 600&#10;&#10;        shake.addUpdateListener { animation -&gt;&#10;            val translateX = animation.animatedValue as Float&#10;            view1.translationX = translateX&#10;            view2.translationX = translateX&#10;        }&#10;&#10;        shake.addListener(object : AnimatorListenerAdapter() {&#10;            override fun onAnimationEnd(animation: Animator) {&#10;                view1.translationX = 0f&#10;                view2.translationX = 0f&#10;            }&#10;        })&#10;&#10;        shake.start()&#10;    }&#10;&#10;    private fun clearSelections() {&#10;        selectedNumberItem = null&#10;        selectedObjectItem = null&#10;        selectedNumberView?.setBackgroundResource(0)&#10;        selectedObjectView?.setBackgroundResource(0)&#10;        selectedNumberView = null&#10;        selectedObjectView = null&#10;    }&#10;&#10;    private fun onLevelCompleted() {&#10;        if (currentLevel &lt; totalLevels) {&#10;            // Убираем задержку - сразу переходим на следующий уровень&#10;            currentLevel++&#10;            loadLevel(currentLevel)&#10;        } else {&#10;            // Переход к экрану результатов без задержки&#10;            showResults()&#10;        }&#10;    }&#10;&#10;    private fun showResults() {&#10;        // Вычисляем итоговые очки: +10 за правильные действия, -5 за ошибки&#10;        val finalScore = (correctActions * 10) - (incorrectActions * 5)&#10;&#10;        val intent = Intent(this, MatchingResultsActivity::class.java)&#10;        intent.putExtra(&quot;completed_levels&quot;, currentLevel)&#10;        intent.putExtra(&quot;correct_actions&quot;, correctActions)&#10;        intent.putExtra(&quot;incorrect_actions&quot;, incorrectActions)&#10;        intent.putExtra(&quot;final_score&quot;, finalScore)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        if (::tts.isInitialized) {&#10;            tts.stop()&#10;            tts.shutdown()&#10;        }&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/MathExercisesActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/MathExercisesActivity.kt" />
              <option name="originalContent" value="package com.timursarsembayev.danabalanumbersnumbers&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;&#10;class MathExercisesActivity : AppCompatActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_math_exercises)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        setupExerciseCards()&#10;    }&#10;&#10;    private fun setupExerciseCards() {&#10;        findViewById&lt;CardView&gt;(R.id.cardNumbers).setOnClickListener {&#10;            val intent = Intent(this, NumberRecognitionActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;&#10;        findViewById&lt;CardView&gt;(R.id.cardCounting).setOnClickListener {&#10;            val intent = Intent(this, CountingActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;&#10;        findViewById&lt;CardView&gt;(R.id.cardObjectCounting).setOnClickListener {&#10;            val intent = Intent(this, ObjectCountingActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;&#10;        findViewById&lt;CardView&gt;(R.id.cardMatching).setOnClickListener {&#10;            val intent = Intent(this, MatchingActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;&#10;class MathExercisesActivity : AppCompatActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_math_exercises)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        setupExerciseCards()&#10;    }&#10;&#10;    private fun setupExerciseCards() {&#10;        findViewById&lt;CardView&gt;(R.id.cardNumbers).setOnClickListener {&#10;            val intent = Intent(this, NumberRecognitionActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;&#10;        findViewById&lt;CardView&gt;(R.id.cardCounting).setOnClickListener {&#10;            val intent = Intent(this, CountingActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;&#10;        findViewById&lt;CardView&gt;(R.id.cardObjectCounting).setOnClickListener {&#10;            val intent = Intent(this, ObjectCountingActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;&#10;        findViewById&lt;CardView&gt;(R.id.cardMatching).setOnClickListener {&#10;            val intent = Intent(this, MatchingActivity::class.java)&#10;            startActivity(intent)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/NumberRecognitionActivity_new.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/NumberRecognitionActivity_new.kt" />
              <option name="updatedContent" value="package com.example.danabala&#10;&#10;import android.animation.AnimatorSet&#10;import android.animation.ObjectAnimator&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.os.Build&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import android.os.VibratorManager&#10;import android.speech.tts.TextToSpeech&#10;import android.util.Log&#10;import android.view.View&#10;import android.view.animation.BounceInterpolator&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import java.util.*&#10;import kotlin.random.Random&#10;&#10;class NumberRecognitionActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var targetNumber = 1&#10;    private var currentQuestion = 0&#10;    private val totalQuestions = 20&#10;    private var tts: TextToSpeech? = null&#10;    private var isTtsReady = false&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var currentQuestionText = &quot;&quot;&#10;&#10;    // Новые переменные для отслеживания ошибок&#10;    private var correctAnswersCount = 0&#10;    private var answersWithErrors = 0&#10;    private var currentQuestionHasError = false&#10;&#10;    // Список доступных цифр для избежания повторов&#10;    private val availableNumbers = mutableListOf&lt;Int&gt;()&#10;&#10;    // Массив прописных чисел (включая 0)&#10;    private val numberWords = arrayOf(&#10;        &quot;ноль&quot;, &quot;один&quot;, &quot;два&quot;, &quot;три&quot;, &quot;четыре&quot;, &quot;пять&quot;,&#10;        &quot;шесть&quot;, &quot;семь&quot;, &quot;восемь&quot;, &quot;девять&quot;&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_number_recognition)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        // Инициализация списка доступных цифр (0-9)&#10;        initializeAvailableNumbers()&#10;&#10;        // Инициализация TTS&#10;        tts = TextToSpeech(this, this)&#10;&#10;        setupBackButton()&#10;        setupSpeakerButton()&#10;        startNewQuestion()&#10;    }&#10;&#10;    private fun initializeAvailableNumbers() {&#10;        availableNumbers.clear()&#10;        // Добавляем цифры от 0 до 9&#10;        for (i in 0..9) {&#10;            availableNumbers.add(i)&#10;        }&#10;        availableNumbers.shuffle()&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val result = tts?.setLanguage(Locale(&quot;ru&quot;))&#10;            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                Log.e(&quot;TTS&quot;, &quot;Русский язык не поддерживается, используем английский&quot;)&#10;                tts?.language = Locale.getDefault()&#10;            }&#10;            isTtsReady = true&#10;&#10;            // Озвучиваем вопрос сразу, если он уже готов&#10;            if (currentQuestionText.isNotEmpty()) {&#10;                speakQuestion()&#10;            }&#10;        } else {&#10;            Log.e(&quot;TTS&quot;, &quot;Инициализация TTS не удалась&quot;)&#10;        }&#10;    }&#10;&#10;    private fun setupBackButton() {&#10;        findViewById&lt;View&gt;(R.id.backButton).setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun setupSpeakerButton() {&#10;        findViewById&lt;ImageView&gt;(R.id.speakerButton).setOnClickListener {&#10;            speakQuestion()&#10;        }&#10;&#10;        findViewById&lt;TextView&gt;(R.id.questionText).setOnClickListener {&#10;            speakQuestion()&#10;        }&#10;    }&#10;&#10;    private fun speakQuestion() {&#10;        if (isTtsReady &amp;&amp; currentQuestionText.isNotEmpty()) {&#10;            tts?.speak(currentQuestionText, TextToSpeech.QUEUE_FLUSH, null, &quot;question&quot;)&#10;        }&#10;    }&#10;&#10;    private fun vibrateOnError() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;            val vibratorManager = getSystemService(Context.VIBRATOR_MANAGER_SERVICE) as VibratorManager&#10;            val vibrator = vibratorManager.defaultVibrator&#10;            vibrator.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            val vibrator = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                vibrator.vibrate(VibrationEffect.createOneShot(200, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                vibrator.vibrate(200)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startNewQuestion() {&#10;        if (currentQuestion &gt;= totalQuestions) {&#10;            showResultsScreen()&#10;            return&#10;        }&#10;&#10;        currentQuestion++&#10;        currentQuestionHasError = false&#10;&#10;        // Получаем следующую цифру из списка доступных&#10;        if (availableNumbers.isEmpty()) {&#10;            initializeAvailableNumbers()&#10;        }&#10;        targetNumber = availableNumbers.removeAt(0)&#10;&#10;        // Обновляем вопрос с прописным числом&#10;        val questionText = &quot;Найди цифру ${numberWords[targetNumber]}&quot;&#10;        findViewById&lt;TextView&gt;(R.id.questionText).text = questionText&#10;        currentQuestionText = questionText&#10;&#10;        // Озвучиваем вопрос сразу (если TTS готов)&#10;        if (isTtsReady) {&#10;            speakQuestion()&#10;        }&#10;&#10;        // Обновляем прогресс-бар&#10;        val progressBar = findViewById&lt;ProgressBar&gt;(R.id.progressBar)&#10;        progressBar.progress = (currentQuestion * 100) / totalQuestions&#10;&#10;        // Генерируем 4 случайные цифры, одна из которых правильная&#10;        val numbers = generateNumberOptions(targetNumber)&#10;&#10;        val cards = listOf(&#10;            findViewById&lt;CardView&gt;(R.id.card1),&#10;            findViewById&lt;CardView&gt;(R.id.card2),&#10;            findViewById&lt;CardView&gt;(R.id.card3),&#10;            findViewById&lt;CardView&gt;(R.id.card4)&#10;        )&#10;&#10;        val numberTexts = listOf(&#10;            findViewById&lt;TextView&gt;(R.id.number1),&#10;            findViewById&lt;TextView&gt;(R.id.number2),&#10;            findViewById&lt;TextView&gt;(R.id.number3),&#10;            findViewById&lt;TextView&gt;(R.id.number4)&#10;        )&#10;&#10;        // Заполняем карточки&#10;        for (i in 0..3) {&#10;            numberTexts[i].text = numbers[i].toString()&#10;            cards[i].setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.white))&#10;            cards[i].isClickable = true&#10;            animateCardEntrance(cards[i], i * 100L)&#10;&#10;            cards[i].setOnClickListener {&#10;                checkAnswer(numbers[i], cards[i])&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun animateCardEntrance(card: CardView, delay: Long) {&#10;        card.alpha = 0f&#10;        card.scaleX = 0.5f&#10;        card.scaleY = 0.5f&#10;&#10;        card.animate()&#10;            .alpha(1f)&#10;            .scaleX(1f)&#10;            .scaleY(1f)&#10;            .setDuration(300)&#10;            .setStartDelay(delay)&#10;            .setInterpolator(BounceInterpolator())&#10;            .start()&#10;    }&#10;&#10;    private fun generateNumberOptions(correct: Int): List&lt;Int&gt; {&#10;        val options = mutableSetOf&lt;Int&gt;()&#10;        options.add(correct)&#10;&#10;        while (options.size &lt; 4) {&#10;            val randomNum = Random.nextInt(0, 10)&#10;            options.add(randomNum)&#10;        }&#10;&#10;        return options.shuffled()&#10;    }&#10;&#10;    private fun checkAnswer(selectedNumber: Int, selectedCard: CardView) {&#10;        if (selectedNumber == targetNumber) {&#10;            // Правильный ответ&#10;            if (currentQuestionHasError) {&#10;                answersWithErrors++&#10;            } else {&#10;                correctAnswersCount++&#10;            }&#10;&#10;            animateCorrectAnswer(selectedCard)&#10;            tts?.speak(&quot;Молодец!&quot;, TextToSpeech.QUEUE_FLUSH, null, &quot;correct&quot;)&#10;            disableAllCards()&#10;&#10;            handler.postDelayed({&#10;                startNewQuestion()&#10;            }, 2000)&#10;        } else {&#10;            // Неправильный ответ&#10;            currentQuestionHasError = true&#10;            animateWrongAnswer(selectedCard)&#10;            vibrateOnError() // Добавляем вибрацию&#10;            tts?.speak(&quot;Попробуй ещё раз, у тебя получится!&quot;, TextToSpeech.QUEUE_FLUSH, null, &quot;wrong&quot;)&#10;            selectedCard.isClickable = false&#10;        }&#10;    }&#10;&#10;    private fun disableAllCards() {&#10;        val cards = listOf(&#10;            findViewById&lt;CardView&gt;(R.id.card1),&#10;            findViewById&lt;CardView&gt;(R.id.card2),&#10;            findViewById&lt;CardView&gt;(R.id.card3),&#10;            findViewById&lt;CardView&gt;(R.id.card4)&#10;        )&#10;        cards.forEach { it.isClickable = false }&#10;    }&#10;&#10;    private fun animateCorrectAnswer(card: CardView) {&#10;        card.setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.holo_green_light))&#10;&#10;        val scaleUpX = ObjectAnimator.ofFloat(card, &quot;scaleX&quot;, 1f, 1.3f)&#10;        val scaleUpY = ObjectAnimator.ofFloat(card, &quot;scaleY&quot;, 1f, 1.3f)&#10;        val scaleDownX = ObjectAnimator.ofFloat(card, &quot;scaleX&quot;, 1.3f, 1f)&#10;        val scaleDownY = ObjectAnimator.ofFloat(card, &quot;scaleY&quot;, 1.3f, 1f)&#10;&#10;        val animatorSet = AnimatorSet()&#10;        animatorSet.play(scaleUpX).with(scaleUpY)&#10;        animatorSet.play(scaleDownX).with(scaleDownY).after(scaleUpX)&#10;        animatorSet.duration = 200&#10;        animatorSet.start()&#10;    }&#10;&#10;    private fun animateWrongAnswer(card: CardView) {&#10;        card.setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.holo_red_light))&#10;&#10;        val shake = ObjectAnimator.ofFloat(card, &quot;translationX&quot;, 0f, 25f, -25f, 25f, -25f, 15f, -15f, 6f, -6f, 0f)&#10;        shake.duration = 500&#10;        shake.start()&#10;    }&#10;&#10;    private fun showResultsScreen() {&#10;        val intent = Intent(this, ResultsActivity::class.java)&#10;        intent.putExtra(&quot;score&quot;, correctAnswersCount) // Только правильные ответы без ошибок&#10;        intent.putExtra(&quot;total&quot;, totalQuestions)&#10;        intent.putExtra(&quot;correctAnswersCount&quot;, correctAnswersCount)&#10;        intent.putExtra(&quot;answersWithErrors&quot;, answersWithErrors)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/ProgressManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/ProgressManager.kt" />
              <option name="updatedContent" value="package com.example.danabala&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;&#10;class ProgressManager(context: Context) {&#10;    private val sharedPreferences: SharedPreferences = &#10;        context.getSharedPreferences(&quot;danabala_progress&quot;, Context.MODE_PRIVATE)&#10;&#10;    // Сохранение результатов тренировки&#10;    fun saveTrainingResult(trainingType: String, score: Int, total: Int, correctAnswers: Int, answersWithErrors: Int) {&#10;        val editor = sharedPreferences.edit()&#10;        &#10;        // Увеличиваем счетчик пройденных тренировок&#10;        val completedCount = getCompletedTrainings(trainingType) + 1&#10;        editor.putInt(&quot;${trainingType}_completed&quot;, completedCount)&#10;        &#10;        // Сохраняем лучший результат&#10;        val bestScore = getBestScore(trainingType)&#10;        if (correctAnswers &gt; bestScore) {&#10;            editor.putInt(&quot;${trainingType}_best_score&quot;, correctAnswers)&#10;            editor.putInt(&quot;${trainingType}_best_total&quot;, total)&#10;        }&#10;        &#10;        // Сохраняем общую статистику&#10;        val totalCorrect = getTotalCorrectAnswers(trainingType) + correctAnswers&#10;        val totalQuestions = getTotalQuestions(trainingType) + total&#10;        editor.putInt(&quot;${trainingType}_total_correct&quot;, totalCorrect)&#10;        editor.putInt(&quot;${trainingType}_total_questions&quot;, totalQuestions)&#10;        &#10;        editor.apply()&#10;    }&#10;&#10;    // Получение количества пройденных тренировок&#10;    fun getCompletedTrainings(trainingType: String): Int {&#10;        return sharedPreferences.getInt(&quot;${trainingType}_completed&quot;, 0)&#10;    }&#10;&#10;    // Получение лучшего результата&#10;    fun getBestScore(trainingType: String): Int {&#10;        return sharedPreferences.getInt(&quot;${trainingType}_best_score&quot;, 0)&#10;    }&#10;&#10;    // Получение общей статистики&#10;    fun getTotalCorrectAnswers(trainingType: String): Int {&#10;        return sharedPreferences.getInt(&quot;${trainingType}_total_correct&quot;, 0)&#10;    }&#10;&#10;    fun getTotalQuestions(trainingType: String): Int {&#10;        return sharedPreferences.getInt(&quot;${trainingType}_total_questions&quot;, 0)&#10;    }&#10;&#10;    // Получение процента правильных ответов&#10;    fun getSuccessRate(trainingType: String): Int {&#10;        val total = getTotalQuestions(trainingType)&#10;        val correct = getTotalCorrectAnswers(trainingType)&#10;        return if (total &gt; 0) (correct * 100) / total else 0&#10;    }&#10;&#10;    // Сброс прогресса (для отладки)&#10;    fun resetProgress() {&#10;        sharedPreferences.edit().clear().apply()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/AppDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/AppDatabase.kt" />
              <option name="updatedContent" value="package com.example.danabala.data.local&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import androidx.room.TypeConverters&#10;import android.content.Context&#10;import com.example.danabala.data.local.dao.ExerciseResultDao&#10;import com.example.danabala.data.local.dao.UserDao&#10;import com.example.danabala.data.local.entity.ExerciseResultEntity&#10;import com.example.danabala.data.local.entity.UserEntity&#10;&#10;/**&#10; * Основная база данных приложения&#10; */&#10;@Database(&#10;    entities = [UserEntity::class, ExerciseResultEntity::class],&#10;    version = 1,&#10;    exportSchema = false&#10;)&#10;@TypeConverters(Converters::class)&#10;abstract class AppDatabase : RoomDatabase() {&#10;    abstract fun userDao(): UserDao&#10;    abstract fun exerciseResultDao(): ExerciseResultDao&#10;&#10;    companion object {&#10;        const val DATABASE_NAME = &quot;danabala_database&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/Converters.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/Converters.kt" />
              <option name="updatedContent" value="package com.example.danabala.data.local&#10;&#10;import androidx.room.TypeConverter&#10;import com.example.danabala.domain.model.Grade&#10;&#10;/**&#10; * Конверторы типов для Room базы данных&#10; */&#10;class Converters {&#10;    @TypeConverter&#10;    fun fromGrade(grade: Grade): String = grade.name&#10;    &#10;    @TypeConverter&#10;    fun toGrade(gradeName: String): Grade = Grade.valueOf(gradeName)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/PreferencesManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/PreferencesManager.kt" />
              <option name="updatedContent" value="package com.example.danabala.data.local&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Менеджер для работы с SharedPreferences&#10; */&#10;@Singleton&#10;class PreferencesManager @Inject constructor(&#10;    @ApplicationContext context: Context&#10;) {&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    &#10;    var currentUserId: String?&#10;        get() = prefs.getString(KEY_CURRENT_USER_ID, null)&#10;        set(value) = prefs.edit().putString(KEY_CURRENT_USER_ID, value).apply()&#10;    &#10;    var isFirstLaunch: Boolean&#10;        get() = prefs.getBoolean(KEY_FIRST_LAUNCH, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_FIRST_LAUNCH, value).apply()&#10;    &#10;    var soundEnabled: Boolean&#10;        get() = prefs.getBoolean(KEY_SOUND_ENABLED, true)&#10;        set(value) = prefs.edit().putBoolean(KEY_SOUND_ENABLED, value).apply()&#10;    &#10;    companion object {&#10;        private const val PREFS_NAME = &quot;danabala_prefs&quot;&#10;        private const val KEY_CURRENT_USER_ID = &quot;current_user_id&quot;&#10;        private const val KEY_FIRST_LAUNCH = &quot;first_launch&quot;&#10;        private const val KEY_SOUND_ENABLED = &quot;sound_enabled&quot;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/dao/ExerciseResultDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/dao/ExerciseResultDao.kt" />
              <option name="updatedContent" value="package com.example.danabala.data.local.dao&#10;&#10;import androidx.room.*&#10;import com.example.danabala.data.local.entity.ExerciseResultEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface ExerciseResultDao {&#10;    @Query(&quot;SELECT * FROM exercise_results WHERE userId = :userId ORDER BY completedAt DESC&quot;)&#10;    fun getUserResults(userId: String): Flow&lt;List&lt;ExerciseResultEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM exercise_results WHERE userId = :userId AND exerciseId = :exerciseId ORDER BY completedAt DESC&quot;)&#10;    fun getUserResultsForExercise(userId: String, exerciseId: String): Flow&lt;List&lt;ExerciseResultEntity&gt;&gt;&#10;    &#10;    @Insert&#10;    suspend fun insertResult(result: ExerciseResultEntity)&#10;    &#10;    @Query(&quot;DELETE FROM exercise_results WHERE userId = :userId&quot;)&#10;    suspend fun deleteUserResults(userId: String)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/dao/UserDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/dao/UserDao.kt" />
              <option name="updatedContent" value="package com.example.danabala.data.local.dao&#10;&#10;import androidx.room.*&#10;import com.example.danabala.data.local.entity.UserEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface UserDao {&#10;    @Query(&quot;SELECT * FROM users&quot;)&#10;    fun getAllUsers(): Flow&lt;List&lt;UserEntity&gt;&gt;&#10;    &#10;    @Query(&quot;SELECT * FROM users WHERE id = :id&quot;)&#10;    suspend fun getUserById(id: String): UserEntity?&#10;    &#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertUser(user: UserEntity)&#10;    &#10;    @Update&#10;    suspend fun updateUser(user: UserEntity)&#10;    &#10;    @Query(&quot;DELETE FROM users WHERE id = :id&quot;)&#10;    suspend fun deleteUser(id: String)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/entity/ExerciseResultEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/entity/ExerciseResultEntity.kt" />
              <option name="updatedContent" value="package com.example.danabala.data.local.entity&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import com.example.danabala.domain.model.ExerciseResult&#10;&#10;@Entity(tableName = &quot;exercise_results&quot;)&#10;data class ExerciseResultEntity(&#10;    @PrimaryKey(autoGenerate = true)&#10;    val id: Long = 0,&#10;    val exerciseId: String,&#10;    val userId: String,&#10;    val score: Int,&#10;    val maxScore: Int,&#10;    val timeSpentSeconds: Int,&#10;    val completedAt: Long,&#10;    val mistakes: String // JSON строка для хранения списка ошибок&#10;)&#10;&#10;fun ExerciseResultEntity.toDomain(): ExerciseResult = ExerciseResult(&#10;    exerciseId = exerciseId,&#10;    userId = userId,&#10;    score = score,&#10;    maxScore = maxScore,&#10;    timeSpentSeconds = timeSpentSeconds,&#10;    completedAt = completedAt,&#10;    mistakes = mistakes.split(&quot;,&quot;).filter { it.isNotBlank() }&#10;)&#10;&#10;fun ExerciseResult.toEntity(): ExerciseResultEntity = ExerciseResultEntity(&#10;    exerciseId = exerciseId,&#10;    userId = userId,&#10;    score = score,&#10;    maxScore = maxScore,&#10;    timeSpentSeconds = timeSpentSeconds,&#10;    completedAt = completedAt,&#10;    mistakes = mistakes.joinToString(&quot;,&quot;)&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/entity/UserEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/local/entity/UserEntity.kt" />
              <option name="updatedContent" value="package com.example.danabala.data.local.entity&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;import com.example.danabala.domain.model.Grade&#10;import com.example.danabala.domain.model.User&#10;&#10;@Entity(tableName = &quot;users&quot;)&#10;data class UserEntity(&#10;    @PrimaryKey&#10;    val id: String,&#10;    val name: String,&#10;    val age: Int,&#10;    val grade: Grade,&#10;    val avatarUrl: String?,&#10;    val createdAt: Long&#10;)&#10;&#10;fun UserEntity.toDomain(): User = User(&#10;    id = id,&#10;    name = name,&#10;    age = age,&#10;    grade = grade,&#10;    avatarUrl = avatarUrl,&#10;    createdAt = createdAt&#10;)&#10;&#10;fun User.toEntity(): UserEntity = UserEntity(&#10;    id = id,&#10;    name = name,&#10;    age = age,&#10;    grade = grade,&#10;    avatarUrl = avatarUrl,&#10;    createdAt = createdAt&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/repository/ExerciseRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/repository/ExerciseRepositoryImpl.kt" />
              <option name="updatedContent" value="package com.example.danabala.data.repository&#10;&#10;import com.example.danabala.data.local.AppDatabase&#10;import com.example.danabala.data.local.entity.toDomain&#10;import com.example.danabala.data.local.entity.toEntity&#10;import com.example.danabala.domain.model.Exercise&#10;import com.example.danabala.domain.model.ExerciseResult&#10;import com.example.danabala.domain.model.ExerciseType&#10;import com.example.danabala.domain.model.Grade&#10;import com.example.danabala.domain.repository.ExerciseRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.flowOf&#10;import kotlinx.coroutines.flow.map&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Реализация репозитория упражнений&#10; */&#10;@Singleton&#10;class ExerciseRepositoryImpl @Inject constructor(&#10;    private val database: AppDatabase&#10;) : ExerciseRepository {&#10;&#10;    private val exerciseResultDao = database.exerciseResultDao()&#10;&#10;    // Временно используем статические данные для упражнений&#10;    // В будущем можно добавить загрузку с сервера или из локальных файлов&#10;    private val staticExercises = listOf(&#10;        Exercise(&#10;            id = &quot;math_add_1&quot;,&#10;            title = &quot;Сложение до 10&quot;,&#10;            description = &quot;Учимся складывать числа от 1 до 10&quot;,&#10;            type = ExerciseType.MATH_ADDITION,&#10;            difficulty = com.example.danabala.domain.model.Difficulty.EASY,&#10;            targetGrades = listOf(Grade.PRESCHOOL_5_6, Grade.GRADE_1),&#10;            estimatedDurationMinutes = 10&#10;        ),&#10;        Exercise(&#10;            id = &quot;reading_letters_1&quot;,&#10;            title = &quot;Изучаем буквы А-Я&quot;,&#10;            description = &quot;Знакомимся с русским алфавитом&quot;,&#10;            type = ExerciseType.READING_LETTERS,&#10;            difficulty = com.example.danabala.domain.model.Difficulty.EASY,&#10;            targetGrades = listOf(Grade.PRESCHOOL_4_5, Grade.PRESCHOOL_5_6),&#10;            estimatedDurationMinutes = 15&#10;        )&#10;    )&#10;&#10;    override suspend fun getExercisesByType(type: ExerciseType): Flow&lt;List&lt;Exercise&gt;&gt; {&#10;        return flowOf(staticExercises.filter { it.type == type })&#10;    }&#10;&#10;    override suspend fun getExercisesByGrade(grade: Grade): Flow&lt;List&lt;Exercise&gt;&gt; {&#10;        return flowOf(staticExercises.filter { grade in it.targetGrades })&#10;    }&#10;&#10;    override suspend fun getExerciseById(id: String): Result&lt;Exercise?&gt; {&#10;        return try {&#10;            val exercise = staticExercises.find { it.id == id }&#10;            Result.success(exercise)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun saveExerciseResult(result: ExerciseResult): Result&lt;Unit&gt; {&#10;        return try {&#10;            exerciseResultDao.insertResult(result.toEntity())&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun getUserResults(userId: String): Flow&lt;List&lt;ExerciseResult&gt;&gt; {&#10;        return exerciseResultDao.getUserResults(userId).map { entities -&gt;&#10;            entities.map { it.toDomain() }&#10;        }&#10;    }&#10;&#10;    override suspend fun getUserResultsForExercise(userId: String, exerciseId: String): Flow&lt;List&lt;ExerciseResult&gt;&gt; {&#10;        return exerciseResultDao.getUserResultsForExercise(userId, exerciseId).map { entities -&gt;&#10;            entities.map { it.toDomain() }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/repository/UserRepositoryImpl.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/data/repository/UserRepositoryImpl.kt" />
              <option name="updatedContent" value="package com.example.danabala.data.repository&#10;&#10;import com.example.danabala.data.local.AppDatabase&#10;import com.example.danabala.data.local.PreferencesManager&#10;import com.example.danabala.data.local.entity.toDomain&#10;import com.example.danabala.data.local.entity.toEntity&#10;import com.example.danabala.domain.model.User&#10;import com.example.danabala.domain.repository.UserRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import kotlinx.coroutines.flow.map&#10;import javax.inject.Inject&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * Реализация репозитория пользователей&#10; */&#10;@Singleton&#10;class UserRepositoryImpl @Inject constructor(&#10;    private val database: AppDatabase,&#10;    private val preferencesManager: PreferencesManager&#10;) : UserRepository {&#10;&#10;    private val userDao = database.userDao()&#10;&#10;    override suspend fun createUser(user: User): Result&lt;Unit&gt; {&#10;        return try {&#10;            userDao.insertUser(user.toEntity())&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun getUserById(id: String): Result&lt;User?&gt; {&#10;        return try {&#10;            val user = userDao.getUserById(id)?.toDomain()&#10;            Result.success(user)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun getAllUsers(): Flow&lt;List&lt;User&gt;&gt; {&#10;        return userDao.getAllUsers().map { entities -&gt;&#10;            entities.map { it.toDomain() }&#10;        }&#10;    }&#10;&#10;    override suspend fun updateUser(user: User): Result&lt;Unit&gt; {&#10;        return try {&#10;            userDao.updateUser(user.toEntity())&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun deleteUser(id: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            userDao.deleteUser(id)&#10;            // Если удаляемый пользователь был текущим, сбрасываем настройку&#10;            if (preferencesManager.currentUserId == id) {&#10;                preferencesManager.currentUserId = null&#10;            }&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    override suspend fun getCurrentUser(): Flow&lt;User?&gt; {&#10;        return userDao.getAllUsers().map { users -&gt;&#10;            val currentUserId = preferencesManager.currentUserId&#10;            users.find { it.id == currentUserId }?.toDomain()&#10;        }&#10;    }&#10;&#10;    override suspend fun setCurrentUser(userId: String): Result&lt;Unit&gt; {&#10;        return try {&#10;            preferencesManager.currentUserId = userId&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/di/DatabaseModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/di/DatabaseModule.kt" />
              <option name="updatedContent" value="package com.example.danabala.di&#10;&#10;import android.content.Context&#10;import androidx.room.Room&#10;import com.example.danabala.data.local.AppDatabase&#10;import com.example.danabala.data.local.dao.ExerciseResultDao&#10;import com.example.danabala.data.local.dao.UserDao&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.android.qualifiers.ApplicationContext&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * DI модуль для базы данных&#10; */&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object DatabaseModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {&#10;        return Room.databaseBuilder(&#10;            context,&#10;            AppDatabase::class.java,&#10;            AppDatabase.DATABASE_NAME&#10;        ).build()&#10;    }&#10;&#10;    @Provides&#10;    fun provideUserDao(database: AppDatabase): UserDao = database.userDao()&#10;&#10;    @Provides&#10;    fun provideExerciseResultDao(database: AppDatabase): ExerciseResultDao = database.exerciseResultDao()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/di/RepositoryModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/di/RepositoryModule.kt" />
              <option name="updatedContent" value="package com.example.danabala.di&#10;&#10;import com.example.danabala.data.repository.ExerciseRepositoryImpl&#10;import com.example.danabala.data.repository.UserRepositoryImpl&#10;import com.example.danabala.domain.repository.ExerciseRepository&#10;import com.example.danabala.domain.repository.UserRepository&#10;import dagger.Binds&#10;import dagger.Module&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;/**&#10; * DI модуль для связывания интерфейсов репозиториев с их реализациями&#10; */&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;abstract class RepositoryModule {&#10;&#10;    @Binds&#10;    @Singleton&#10;    abstract fun bindUserRepository(userRepositoryImpl: UserRepositoryImpl): UserRepository&#10;&#10;    @Binds&#10;    @Singleton&#10;    abstract fun bindExerciseRepository(exerciseRepositoryImpl: ExerciseRepositoryImpl): ExerciseRepository&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/model/Exercise.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/model/Exercise.kt" />
              <option name="updatedContent" value="package com.example.danabala.domain.model&#10;&#10;/**&#10; * Базовая модель тренировки&#10; */&#10;data class Exercise(&#10;    val id: String,&#10;    val title: String,&#10;    val description: String,&#10;    val type: ExerciseType,&#10;    val difficulty: Difficulty,&#10;    val targetGrades: List&lt;Grade&gt;,&#10;    val estimatedDurationMinutes: Int,&#10;    val iconResId: Int? = null&#10;)&#10;&#10;/**&#10; * Типы тренировок&#10; */&#10;enum class ExerciseType {&#10;    MATH_ADDITION,      // Сложение&#10;    MATH_SUBTRACTION,   // Вычитание&#10;    MATH_MULTIPLICATION,// Умножение&#10;    MATH_DIVISION,      // Деление&#10;    MATH_COUNTING,      // Счет&#10;    READING_LETTERS,    // Изучение букв&#10;    READING_SYLLABLES,  // Слоги&#10;    READING_WORDS,      // Слова&#10;    READING_SENTENCES,  // Предложения&#10;    READING_COMPREHENSION // Понимание прочитанного&#10;}&#10;&#10;/**&#10; * Уровень сложности&#10; */&#10;enum class Difficulty {&#10;    EASY,&#10;    MEDIUM,&#10;    HARD&#10;}&#10;&#10;/**&#10; * Результат выполнения тренировки&#10; */&#10;data class ExerciseResult(&#10;    val exerciseId: String,&#10;    val userId: String,&#10;    val score: Int,&#10;    val maxScore: Int,&#10;    val timeSpentSeconds: Int,&#10;    val completedAt: Long = System.currentTimeMillis(),&#10;    val mistakes: List&lt;String&gt; = emptyList()&#10;) {&#10;    val percentage: Float&#10;        get() = if (maxScore &gt; 0) (score.toFloat() / maxScore) * 100 else 0f&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/model/User.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/model/User.kt" />
              <option name="updatedContent" value="package com.example.danabala.domain.model&#10;&#10;/**&#10; * Базовая модель пользователя (ребенка)&#10; */&#10;data class User(&#10;    val id: String,&#10;    val name: String,&#10;    val age: Int,&#10;    val grade: Grade,&#10;    val avatarUrl: String? = null,&#10;    val createdAt: Long = System.currentTimeMillis()&#10;)&#10;&#10;/**&#10; * Класс обучения (дошкольник/школьник)&#10; */&#10;enum class Grade {&#10;    PRESCHOOL_3_4,    // 3-4 года&#10;    PRESCHOOL_4_5,    // 4-5 лет&#10;    PRESCHOOL_5_6,    // 5-6 лет&#10;    GRADE_1,          // 1 класс&#10;    GRADE_2,          // 2 класс&#10;    GRADE_3,          // 3 класс&#10;    GRADE_4           // 4 класс&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/repository/ExerciseRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/repository/ExerciseRepository.kt" />
              <option name="updatedContent" value="package com.example.danabala.domain.repository&#10;&#10;import com.example.danabala.domain.model.Exercise&#10;import com.example.danabala.domain.model.ExerciseResult&#10;import com.example.danabala.domain.model.ExerciseType&#10;import com.example.danabala.domain.model.Grade&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; * Репозиторий для работы с упражнениями и результатами&#10; */&#10;interface ExerciseRepository {&#10;    suspend fun getExercisesByType(type: ExerciseType): Flow&lt;List&lt;Exercise&gt;&gt;&#10;    suspend fun getExercisesByGrade(grade: Grade): Flow&lt;List&lt;Exercise&gt;&gt;&#10;    suspend fun getExerciseById(id: String): Result&lt;Exercise?&gt;&#10;    suspend fun saveExerciseResult(result: ExerciseResult): Result&lt;Unit&gt;&#10;    suspend fun getUserResults(userId: String): Flow&lt;List&lt;ExerciseResult&gt;&gt;&#10;    suspend fun getUserResultsForExercise(userId: String, exerciseId: String): Flow&lt;List&lt;ExerciseResult&gt;&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/repository/UserRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/repository/UserRepository.kt" />
              <option name="updatedContent" value="package com.example.danabala.domain.repository&#10;&#10;import com.example.danabala.domain.model.User&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; * Репозиторий для работы с пользователями&#10; */&#10;interface UserRepository {&#10;    suspend fun createUser(user: User): Result&lt;Unit&gt;&#10;    suspend fun getUserById(id: String): Result&lt;User?&gt;&#10;    suspend fun getAllUsers(): Flow&lt;List&lt;User&gt;&gt;&#10;    suspend fun updateUser(user: User): Result&lt;Unit&gt;&#10;    suspend fun deleteUser(id: String): Result&lt;Unit&gt;&#10;    suspend fun getCurrentUser(): Flow&lt;User?&gt;&#10;    suspend fun setCurrentUser(userId: String): Result&lt;Unit&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/usecase/ExerciseUseCases.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/usecase/ExerciseUseCases.kt" />
              <option name="updatedContent" value="package com.example.danabala.domain.usecase&#10;&#10;import com.example.danabala.domain.model.Exercise&#10;import com.example.danabala.domain.model.ExerciseResult&#10;import com.example.danabala.domain.model.ExerciseType&#10;import com.example.danabala.domain.model.Grade&#10;import com.example.danabala.domain.repository.ExerciseRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Use Cases для работы с упражнениями&#10; */&#10;class GetExercisesByTypeUseCase @Inject constructor(&#10;    private val exerciseRepository: ExerciseRepository&#10;) {&#10;    operator fun invoke(type: ExerciseType): Flow&lt;List&lt;Exercise&gt;&gt; = &#10;        exerciseRepository.getExercisesByType(type)&#10;}&#10;&#10;class GetExercisesByGradeUseCase @Inject constructor(&#10;    private val exerciseRepository: ExerciseRepository&#10;) {&#10;    operator fun invoke(grade: Grade): Flow&lt;List&lt;Exercise&gt;&gt; = &#10;        exerciseRepository.getExercisesByGrade(grade)&#10;}&#10;&#10;class SaveExerciseResultUseCase @Inject constructor(&#10;    private val exerciseRepository: ExerciseRepository&#10;) {&#10;    suspend operator fun invoke(result: ExerciseResult): Result&lt;Unit&gt; = &#10;        exerciseRepository.saveExerciseResult(result)&#10;}&#10;&#10;class GetUserProgressUseCase @Inject constructor(&#10;    private val exerciseRepository: ExerciseRepository&#10;) {&#10;    operator fun invoke(userId: String): Flow&lt;List&lt;ExerciseResult&gt;&gt; = &#10;        exerciseRepository.getUserResults(userId)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/usecase/UserUseCases.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/danabala/domain/usecase/UserUseCases.kt" />
              <option name="updatedContent" value="package com.example.danabala.domain.usecase&#10;&#10;import com.example.danabala.domain.model.User&#10;import com.example.danabala.domain.repository.UserRepository&#10;import kotlinx.coroutines.flow.Flow&#10;import javax.inject.Inject&#10;&#10;/**&#10; * Use Cases для работы с пользователями&#10; */&#10;class GetCurrentUserUseCase @Inject constructor(&#10;    private val userRepository: UserRepository&#10;) {&#10;    operator fun invoke(): Flow&lt;User?&gt; = userRepository.getCurrentUser()&#10;}&#10;&#10;class CreateUserUseCase @Inject constructor(&#10;    private val userRepository: UserRepository&#10;) {&#10;    suspend operator fun invoke(user: User): Result&lt;Unit&gt; = userRepository.createUser(user)&#10;}&#10;&#10;class GetAllUsersUseCase @Inject constructor(&#10;    private val userRepository: UserRepository&#10;) {&#10;    operator fun invoke(): Flow&lt;List&lt;User&gt;&gt; = userRepository.getAllUsers()&#10;}&#10;&#10;class SetCurrentUserUseCase @Inject constructor(&#10;    private val userRepository: UserRepository&#10;) {&#10;    suspend operator fun invoke(userId: String): Result&lt;Unit&gt; = userRepository.setCurrentUser(userId)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/BlockMatchGameView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/BlockMatchGameView.kt" />
              <option name="originalContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Context&#10;import android.graphics.*&#10;import android.util.AttributeSet&#10;import android.view.Choreographer&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class BlockMatchGameView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    // Callbacks&#10;    var onScoreLevelChanged: ((score: Int, level: Int) -&gt; Unit)? = null&#10;    var onGameOver: (() -&gt; Unit)? = null&#10;&#10;    // Grid&#10;    private val cols = 5&#10;    private val rows = 7&#10;    private var cellSize = 0f&#10;    private var gridLeft = 0f&#10;    private var gridTop = 0f&#10;&#10;    // Timing / loop&#10;    private var running = false&#10;    private var lastFrameNs = 0L&#10;    private val choreographer: Choreographer = Choreographer.getInstance()&#10;    private val frameCallback: Choreographer.FrameCallback = object : Choreographer.FrameCallback {&#10;        override fun doFrame(now: Long) {&#10;            if (!running) return&#10;            if (lastFrameNs == 0L) lastFrameNs = now&#10;            val dt = (now - lastFrameNs) / 1_000_000_000f // seconds&#10;            lastFrameNs = now&#10;            update(dt)&#10;            invalidate()&#10;            choreographer.postFrameCallback(this)&#10;        }&#10;    }&#10;&#10;    // Spawn and speeds&#10;    private var spawnIntervalMs = 1200L&#10;    private var spawnTimerMs = 0f&#10;    private var fallSpeedCellsPerSec = 3f // было 3f, изменится в updateSpeed&#10;    private val minSpawnInterval = 300L&#10;    private val baseSpawnMs = 3840L // было 1920L, в 2 раза реже спавн&#10;    private val spawnStepMs = 384L  // было 192L, в 2 раза реже ускорение спавна&#10;&#10;    // Game state&#10;    private data class Tile(&#10;        var digit: Int,&#10;        var colorIdx: Int,&#10;        var textLight: Boolean,&#10;        // Animations&#10;        var fallOffsetY: Float = 0f, // px offset relative to its grid cell&#10;        var removing: Boolean = false,&#10;        var removeProgress: Float = 0f,&#10;        // Soft-drop флаг: когда пользователь тянет вниз — ускоряем падение только этого тайла&#10;        var softDrop: Boolean = false&#10;    )&#10;    private val grid: Array&lt;Array&lt;Tile?&gt;&gt; = Array(rows) { arrayOfNulls&lt;Tile?&gt;(cols) }&#10;    private var score = 0&#10;    private var level = 1&#10;    private var nextLevelScoreTarget = 50 // стартовый порог победы/уровня&#10;&#10;    // Interaction / selection &amp; swap&#10;    private var selC = -1&#10;    private var selR = -1&#10;    private var selectionPulse = 0f // radians&#10;    private var inputLocked = false&#10;&#10;    private var downX = 0f&#10;    private var downY = 0f&#10;    private val clickSlop = 12f * resources.displayMetrics.density&#10;&#10;    // Swap animation between two neighbors&#10;    private var swapping = false&#10;    private var swapA_r = -1; private var swapA_c = -1&#10;    private var swapB_r = -1; private var swapB_c = -1&#10;    private var swapProgress = 0f&#10;    private val swapDuration = 0.15f // seconds&#10;&#10;    // Позиции тайлов, которые сместились вниз со времени последнего стабильного состояния&#10;    private val movedDownSinceLastStable = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;&#10;    // Позиции тайлов, которые в этом кадре полностью приземлились (fallOffsetY стал 0)&#10;    private val landedThisFrame = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;&#10;    // Paints&#10;    private val bgPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val borderPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 2f * resources.displayMetrics.density&#10;        color = 0x22000000&#10;    }&#10;    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        textAlign = Paint.Align.CENTER&#10;        typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;    }&#10;    private val glossyShadow = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        maskFilter = BlurMaskFilter(6f * resources.displayMetrics.density, BlurMaskFilter.Blur.NORMAL)&#10;    }&#10;    private val fillPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val highlightPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val blockColors = intArrayOf(&#10;        Color.parseColor(&quot;#FF5252&quot;),&#10;        Color.parseColor(&quot;#FF9800&quot;),&#10;        Color.parseColor(&quot;#FFEB3B&quot;),&#10;        Color.parseColor(&quot;#4CAF50&quot;),&#10;        Color.parseColor(&quot;#00BCD4&quot;),&#10;        Color.parseColor(&quot;#3F51B5&quot;),&#10;        Color.parseColor(&quot;#9C27B0&quot;),&#10;        Color.parseColor(&quot;#795548&quot;)&#10;    )&#10;&#10;    init {&#10;        isClickable = true&#10;        resetGame()&#10;    }&#10;&#10;    fun resetGame() {&#10;        for (r in 0 until rows) for (c in 0 until cols) grid[r][c] = null&#10;        score = 0; level = 1&#10;        nextLevelScoreTarget = 50&#10;        movedDownSinceLastStable.clear()&#10;        landedThisFrame.clear()&#10;        updateSpeed()&#10;        spawnInitial()&#10;        spawnTimerMs = 0f&#10;        onScoreLevelChanged?.invoke(score, level)&#10;    }&#10;&#10;    fun pause() {&#10;        running = false&#10;        lastFrameNs = 0L&#10;        choreographer.removeFrameCallback(frameCallback)&#10;    }&#10;&#10;    fun resume() {&#10;        if (!running) {&#10;            running = true&#10;            lastFrameNs = 0L&#10;            choreographer.postFrameCallback(frameCallback)&#10;        }&#10;    }&#10;&#10;    override fun onDetachedFromWindow() {&#10;        super.onDetachedFromWindow()&#10;        running = false&#10;        lastFrameNs = 0L&#10;        choreographer.removeFrameCallback(frameCallback)&#10;    }&#10;&#10;    private fun spawnInitial() {&#10;        for (r in 0 until 3) for (c in 0 until cols) grid[r][c] = randomTile()&#10;    }&#10;&#10;    private fun randomTile(): Tile {&#10;        val digit = Random.nextInt(0, 10)&#10;        val colorIdx = Random.nextInt(0, blockColors.size)&#10;        val textLight = Random.nextBoolean()&#10;        return Tile(digit, colorIdx, textLight)&#10;    }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        val contentW = w - paddingLeft - paddingRight&#10;        val contentH = h - paddingTop - paddingBottom&#10;        cellSize = min(contentW / cols.toFloat(), contentH / rows.toFloat())&#10;        val gridW = cellSize * cols&#10;        val gridH = cellSize * rows&#10;        gridLeft = paddingLeft + (contentW - gridW) / 2f&#10;        gridTop = paddingTop + (contentH - gridH) / 2f&#10;        textPaint.textSize = cellSize * 0.55f&#10;        updateFallSpeedPx()&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        // Background grid&#10;        for (r in 0 until rows) for (c in 0 until cols) {&#10;            val l = gridLeft + c * cellSize&#10;            val t = gridTop + r * cellSize&#10;            bgPaint.color = 0x10FFFFFF&#10;            canvas.drawRect(l, t, l + cellSize, t + cellSize, bgPaint)&#10;            canvas.drawRect(l, t, l + cellSize, t + cellSize, borderPaint)&#10;        }&#10;        // Draw tiles with offsets/animations&#10;        for (r in 0 until rows) for (c in 0 until cols) {&#10;            val tile = grid[r][c] ?: continue&#10;            drawTile(canvas, c, r, tile)&#10;        }&#10;    }&#10;&#10;    private fun drawTile(canvas: Canvas, c: Int, r: Int, tile: Tile) {&#10;        // Swap offsets for A/B while animating swap&#10;        var extraX = 0f; var extraY = tile.fallOffsetY&#10;        if (swapping) {&#10;            val dx = (swapB_c - swapA_c) * cellSize&#10;            val dy = (swapB_r - swapA_r) * cellSize&#10;            val t = easeOutCubic(swapProgress)&#10;            if (r == swapA_r &amp;&amp; c == swapA_c) { extraX += dx * t; extraY += dy * t }&#10;            if (r == swapB_r &amp;&amp; c == swapB_c) { extraX -= dx * t; extraY -= dy * t }&#10;        }&#10;        // Selection pulse scaling&#10;        val isSelected = (r == selR &amp;&amp; c == selC &amp;&amp; !swapping)&#10;        val scale = if (isSelected) 1f + 0.06f * sin(selectionPulse) else 1f&#10;&#10;        val cx = gridLeft + c * cellSize + cellSize / 2f + extraX&#10;        val cy = gridTop + r * cellSize + cellSize / 2f + extraY&#10;        val baseSize = cellSize * (if (tile.removing) (1f - 0.6f * tile.removeProgress) else 1f)&#10;        val size = baseSize * scale&#10;        val half = size / 2f&#10;        val left = cx - half&#10;        val top = cy - half&#10;        val right = cx + half&#10;        val bottom = cy + half&#10;&#10;        val color = blockColors[tile.colorIdx]&#10;        val round = cellSize * 0.18f&#10;&#10;        // Shadow&#10;        glossyShadow.color = color&#10;        canvas.drawRoundRect(left + 3f, top + 3f, right + 3f, bottom + 3f, round, round, glossyShadow)&#10;&#10;        // Gradient body (переиспользуем Paint, меняем shader)&#10;        fillPaint.shader = LinearGradient(&#10;            left, top, right, bottom,&#10;            lighten(color, 0.25f), darken(color, 0.15f), Shader.TileMode.CLAMP&#10;        )&#10;&#10;        val save = canvas.save()&#10;        if (tile.removing) {&#10;            val rot = 360f * tile.removeProgress&#10;            canvas.rotate(rot, cx, cy)&#10;        }&#10;        canvas.drawRoundRect(left, top, right, bottom, round, round, fillPaint)&#10;&#10;        // Highlight (переиспользуем Paint, меняем shader)&#10;        highlightPaint.shader = LinearGradient(&#10;            left, top, left, top + size * 0.45f,&#10;            Color.argb(120, 255, 255, 255), Color.TRANSPARENT,&#10;            Shader.TileMode.CLAMP&#10;        )&#10;        val inset = size * 0.06f&#10;        canvas.drawRoundRect(left + inset, top + inset, right - inset, top + size * 0.45f, round, round, highlightPaint)&#10;&#10;        // Digit&#10;        textPaint.color = if (tile.textLight) Color.WHITE else Color.parseColor(&quot;#212121&quot;)&#10;        val text = tile.digit.toString()&#10;        val fm = textPaint.fontMetrics&#10;        val textY = cy - (fm.ascent + fm.descent) / 2f&#10;        canvas.drawText(text, cx, textY, textPaint)&#10;&#10;        canvas.restoreToCount(save)&#10;    }&#10;&#10;    private fun update(dt: Float) {&#10;        // Единственное условие поражения — полный столбец&#10;        if (running &amp;&amp; isAnyColumnFull()) {&#10;            running = false&#10;            onGameOver?.invoke()&#10;            return&#10;        }&#10;&#10;        // Update selection pulse&#10;        if (selC &gt;= 0 &amp;&amp; selR &gt;= 0) selectionPulse = (selectionPulse + dt * 2f * Math.PI).toFloat()&#10;&#10;        // Update removal animations&#10;        var removingActive = false&#10;        if (advanceRemoval(dt)) removingActive = true&#10;&#10;        // Apply gravity smoothly (не двигаем, если сейчас идёт своп/перемещение)&#10;        landedThisFrame.clear()&#10;        val fallingActive = if (!swapping) applyGravitySmooth(dt) else false&#10;&#10;        // Немедленная проверка пар для только что приземлившихся тайлов&#10;        if (landedThisFrame.isNotEmpty()) {&#10;            val pairs = mutableListOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;()&#10;            val used = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;            for ((r, c) in landedThisFrame) {&#10;                val t = grid.getOrNull(r)?.getOrNull(c) ?: continue&#10;                if (t.removing || t.fallOffsetY != 0f) continue&#10;                // левый&#10;                val lc = c - 1&#10;                if (lc &gt;= 0) {&#10;                    val lt = grid[r][lc]&#10;                    if (lt != null &amp;&amp; !lt.removing &amp;&amp; lt.fallOffsetY == 0f &amp;&amp; lt.digit == t.digit) {&#10;                        val p1 = r to c; val p2 = r to lc&#10;                        if (p1 !in used &amp;&amp; p2 !in used) {&#10;                            pairs.add(listOf(p1, p2))&#10;                            used.add(p1); used.add(p2)&#10;                            continue&#10;                        }&#10;                    }&#10;                }&#10;                // правый&#10;                val rc = c + 1&#10;                if (rc &lt; cols) {&#10;                    val rt = grid[r][rc]&#10;                    if (rt != null &amp;&amp; !rt.removing &amp;&amp; rt.fallOffsetY == 0f &amp;&amp; rt.digit == t.digit) {&#10;                        val p1 = r to c; val p2 = r to rc&#10;                        if (p1 !in used &amp;&amp; p2 !in used) {&#10;                            pairs.add(listOf(p1, p2))&#10;                            used.add(p1); used.add(p2)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            if (pairs.isNotEmpty()) startRemoving(pairs)&#10;        }&#10;&#10;        // Убрано авто-уничтожение падающих пар и общий поиск совпадений&#10;&#10;        // Update swap animation&#10;        if (swapping) {&#10;            swapProgress += dt / swapDuration&#10;            if (swapProgress &gt;= 1f) {&#10;                // finalize swap&#10;                swapProgress = 1f&#10;                doSwapFinalize()&#10;                swapping = false&#10;                inputLocked = false&#10;                // После завершения любого свопа проверяем пары, которые могли образоваться вручную рядом по горизонтали&#10;                handleManualAdjacencyPairRemoval()&#10;            }&#10;        }&#10;&#10;        // Spawn independently from input&#10;        if (!removingActive &amp;&amp; !swapping) {&#10;            spawnTimerMs += dt * 1000f&#10;            if (spawnTimerMs &gt;= spawnIntervalMs) {&#10;                spawnTimerMs -= spawnIntervalMs&#10;                trySpawn()&#10;            }&#10;        }&#10;&#10;        // Когда система стабилизировалась (нет падения/свопа/удаления),&#10;        // проверяем пары, образованные из-за вертикального смещения сверху&#10;        if (!fallingActive &amp;&amp; !swapping &amp;&amp; !removingActive) {&#10;            if (movedDownSinceLastStable.isNotEmpty()) {&#10;                val pairs = mutableListOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;()&#10;                val seen = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;                for ((r, c) in movedDownSinceLastStable) {&#10;                    val t = grid.getOrNull(r)?.getOrNull(c) ?: continue&#10;                    if (t.removing) continue&#10;                    // Проверяем левого соседа&#10;                    val lc = c - 1&#10;                    if (lc &gt;= 0) {&#10;                        val lt = grid[r][lc]&#10;                        if (lt != null &amp;&amp; !lt.removing &amp;&amp; lt.digit == t.digit) {&#10;                            val p1 = r to c&#10;                            val p2 = r to lc&#10;                            if (p1 !in seen &amp;&amp; p2 !in seen) {&#10;                                pairs.add(listOf(p1, p2))&#10;                                seen.add(p1); seen.add(p2)&#10;                            }&#10;                        }&#10;                    }&#10;                    // Проверяем правого соседа&#10;                    val rc = c + 1&#10;                    if (rc &lt; cols) {&#10;                        val rt = grid[r][rc]&#10;                        if (rt != null &amp;&amp; !rt.removing &amp;&amp; rt.digit == t.digit) {&#10;                            val p1 = r to c&#10;                            val p2 = r to rc&#10;                            if (p1 !in seen &amp;&amp; p2 !in seen) {&#10;                                pairs.add(listOf(p1, p2))&#10;                                seen.add(p1); seen.add(p2)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                movedDownSinceLastStable.clear()&#10;                if (pairs.isNotEmpty()) startRemoving(pairs)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isAnyColumnFull(): Boolean {&#10;        for (c in 0 until cols) {&#10;            var full = true&#10;            for (r in 0 until rows) {&#10;                if (grid[r][c] == null) { full = false; break }&#10;            }&#10;            if (full) return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    private fun advanceRemoval(dt: Float): Boolean {&#10;        var any = false&#10;        var finishedAll = true&#10;        for (r in 0 until rows) for (c in 0 until cols) {&#10;            val t = grid[r][c] ?: continue&#10;            if (t.removing) {&#10;                any = true&#10;                t.removeProgress += dt * 8f // fast&#10;                if (t.removeProgress &gt;= 1f) {&#10;                    grid[r][c] = null&#10;                } else finishedAll = false&#10;            }&#10;        }&#10;        if (any &amp;&amp; finishedAll) {&#10;            score += pendingScoreGain&#10;            pendingScoreGain = 0&#10;            updateLevel()&#10;            // Снятие блокировки ввода: удаление завершено&#10;            inputLocked = false&#10;        }&#10;        return any&#10;    }&#10;&#10;    private fun applyGravitySmooth(dt: Float): Boolean {&#10;        var anyFalling = false&#10;        val baseFallPxPerSec = fallSpeedCellsPerSec * cellSize&#10;        for (c in 0 until cols) {&#10;            // from bottom-2 to top to pull down chain&#10;            for (r in rows - 2 downTo 0) {&#10;                val t = grid[r][c] ?: continue&#10;                if (t.removing) continue&#10;                val fallPxPerSec = if (t.softDrop) baseFallPxPerSec * 3f else baseFallPxPerSec&#10;                var belowR = r + 1&#10;                if (grid[belowR][c] == null) {&#10;                    anyFalling = true&#10;                    t.fallOffsetY += fallPxPerSec * dt&#10;                    var movedDown = false&#10;                    while (t.fallOffsetY &gt;= cellSize &amp;&amp; belowR &lt;= rows - 1) {&#10;                        // move down by one cell&#10;                        t.fallOffsetY -= cellSize&#10;                        grid[belowR][c] = t&#10;                        grid[belowR - 1][c] = null&#10;                        movedDown = true&#10;                        belowR++&#10;                        if (belowR &gt; rows - 1 || grid[belowR][c] != null) break&#10;                    }&#10;                    if (movedDown) {&#10;                        val finalR = belowR - 1&#10;                        movedDownSinceLastStable.add(finalR to c)&#10;                        // Если приземлились на дно, считаем посадку завершённой в этом кадре&#10;                        if (finalR == rows - 1) {&#10;                            if (t.fallOffsetY != 0f) {&#10;                                t.fallOffsetY = 0f&#10;                                landedThisFrame.add(finalR to c)&#10;                            }&#10;                            // Сброс софт-дропа на приземлении&#10;                            t.softDrop = false&#10;                        }&#10;                    }&#10;                } else {&#10;                    // Snap if offset exists&#10;                    val wasOffset = t.fallOffsetY&#10;                    if (t.fallOffsetY != 0f) anyFalling = true&#10;                    t.fallOffsetY = max(0f, t.fallOffsetY - fallPxPerSec * dt)&#10;                    if (wasOffset &gt; 0f &amp;&amp; t.fallOffsetY == 0f) {&#10;                        // тайл только что приземлился&#10;                        landedThisFrame.add(r to c)&#10;                    }&#10;                    // Если под нами занято и смещение обнулилось — больше не ускоряем&#10;                    if (grid[belowR][c] != null &amp;&amp; t.fallOffsetY == 0f) t.softDrop = false&#10;                }&#10;            }&#10;        }&#10;        return anyFalling&#10;    }&#10;&#10;    private var pendingScoreGain = 0&#10;    private fun startRemoving(matches: List&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;) {&#10;        // Жёсткая валидация пар на всякий случай: только 2 соседние по горизонтали плитки,&#10;        // в одной строке, со совпадающими цифрами и без смещения падения&#10;        val valid = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val used = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        for (pair in matches) {&#10;            if (pair.size != 2) continue&#10;            val (r1, c1) = pair[0]&#10;            val (r2, c2) = pair[1]&#10;            if (r1 !in 0 until rows || c1 !in 0 until cols) continue&#10;            if (r2 !in 0 until rows || c2 !in 0 until cols) continue&#10;            val t1 = grid[r1][c1]&#10;            val t2 = grid[r2][c2]&#10;            if (t1 == null || t2 == null) continue&#10;            if (t1.removing || t2.removing) continue&#10;            if (r1 != r2) continue&#10;            if (kotlin.math.abs(c1 - c2) != 1) continue&#10;            if (t1.digit != t2.digit) continue&#10;            if (t1.fallOffsetY != 0f || t2.fallOffsetY != 0f) continue&#10;            if ((r1 to c1) in used || (r2 to c2) in used) continue&#10;            valid += (r1 to c1)&#10;            valid += (r2 to c2)&#10;            used += (r1 to c1)&#10;            used += (r2 to c2)&#10;        }&#10;        if (valid.isEmpty()) return&#10;&#10;        pendingScoreGain = 0&#10;        for ((r, c) in valid) {&#10;            val t = grid[r][c]&#10;            if (t != null &amp;&amp; !t.removing) {&#10;                t.removing = true&#10;                t.removeProgress = 0f&#10;                pendingScoreGain += 1&#10;            }&#10;        }&#10;        inputLocked = true&#10;        // Deselect during removal&#10;        selC = -1; selR = -1&#10;    }&#10;&#10;    private fun handleManualAdjacencyPairRemoval() {&#10;        // Проверяем горизонтальных соседей для обеих конечных позиций свопа&#10;        val candidates = listOf(swapA_r to swapA_c, swapB_r to swapB_c)&#10;        val pairs = mutableListOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;()&#10;        val used = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        for ((r, c) in candidates) {&#10;            if (r !in 0 until rows || c !in 0 until cols) continue&#10;            val t = grid[r][c] ?: continue&#10;            if ((r to c) in used || t.removing) continue&#10;            // сначала левый сосед&#10;            val lc = c - 1&#10;            if (lc &gt;= 0) {&#10;                val lt = grid[r][lc]&#10;                if (lt != null &amp;&amp; !lt.removing &amp;&amp; lt.digit == t.digit &amp;&amp; (r to lc) !in used) {&#10;                    pairs.add(listOf(r to c, r to lc))&#10;                    used.add(r to c); used.add(r to lc)&#10;                    continue&#10;                }&#10;            }&#10;            // затем правый сосед&#10;            val rc = c + 1&#10;            if (rc &lt; cols) {&#10;                val rt = grid[r][rc]&#10;                if (rt != null &amp;&amp; !rt.removing &amp;&amp; rt.digit == t.digit &amp;&amp; (r to rc) !in used) {&#10;                    pairs.add(listOf(r to c, r to rc))&#10;                    used.add(r to c); used.add(r to rc)&#10;                }&#10;            }&#10;        }&#10;        if (pairs.isNotEmpty()) startRemoving(pairs)&#10;    }&#10;&#10;    private fun doSwapStart(r1: Int, c1: Int, r2: Int, c2: Int) {&#10;        if (swapping) return&#10;        swapping = true&#10;        inputLocked = true&#10;        swapA_r = r1; swapA_c = c1&#10;        swapB_r = r2; swapB_c = c2&#10;        swapProgress = 0f&#10;    }&#10;&#10;    private fun doSwapFinalize() {&#10;        // Exchange tiles in grid&#10;        val a = grid[swapA_r][swapA_c]&#10;        val b = grid[swapB_r][swapB_c]&#10;        grid[swapA_r][swapA_c] = b&#10;        grid[swapB_r][swapB_c] = a&#10;        selR = swapB_r; selC = swapB_c // keep selection on moved tile&#10;        selectionPulse = 0f&#10;    }&#10;&#10;    private fun trySpawn(): Boolean {&#10;        val freeCols = (0 until cols).filter { grid[0][it] == null }&#10;        if (freeCols.isEmpty()) {&#10;            // Нет места для спавна — пропускаем этот тик&#10;            return false&#10;        }&#10;        val col = freeCols.random()&#10;        val tile = randomTile()&#10;        tile.fallOffsetY = -cellSize // start above the cell for a nicer drop-in&#10;        grid[0][col] = tile&#10;        return true&#10;    }&#10;&#10;    private fun updateLevel() {&#10;        var levelChanged = false&#10;        while (score &gt;= nextLevelScoreTarget) {&#10;            level += 1&#10;            // Следующий порог увеличивается на 10% и округляется вверх&#10;            nextLevelScoreTarget = ceil(nextLevelScoreTarget * 1.1).toInt()&#10;            levelChanged = true&#10;        }&#10;        if (levelChanged) {&#10;            updateSpeed()&#10;        }&#10;        onScoreLevelChanged?.invoke(score, level)&#10;    }&#10;&#10;    private fun updateSpeed() {&#10;        // Ещё реже спавн (в 2 раза):&#10;        spawnIntervalMs = (baseSpawnMs - (level - 1) * spawnStepMs).coerceAtLeast(minSpawnInterval)&#10;        // Падение в 2 раза медленнее: базу и шаг делим на 2&#10;        fallSpeedCellsPerSec = 1.5f + (level - 1) * 0.4f&#10;        updateFallSpeedPx()&#10;    }&#10;&#10;    private fun updateFallSpeedPx() {&#10;        // no-op placeholder if later we add pixel-speed cache&#10;    }&#10;&#10;    // Input handling: select, tap neighbor to swap, drag to swap&#10;    private var movedThisGesture = false&#10;&#10;    // Вычисление дальнего доступного столбца по горизонтали в направлении dirX&#10;    // Если соседняя ячейка пуста — двигаем только на одну клетку в сторону.&#10;    // Если соседняя занята — выполняем обычный своп с соседом.&#10;    private fun findHorizontalDestination(row: Int, col: Int, dirX: Int): Int {&#10;        if (dirX == 0) return col&#10;        val next = col + dirX&#10;        return if (next in 0 until cols) next else col&#10;    }&#10;&#10;    override fun onTouchEvent(event: MotionEvent): Boolean {&#10;        if (!running) return super.onTouchEvent(event)&#10;        when (event.actionMasked) {&#10;            MotionEvent.ACTION_DOWN -&gt; {&#10;                if (inputLocked) return true&#10;                val (c, r) = cellAt(event.x, event.y)&#10;                movedThisGesture = false&#10;                if (c in 0 until cols &amp;&amp; r in 0 until rows &amp;&amp; grid[r][c] != null) {&#10;                    // Раньше здесь сбрасывался софт-дроп у всех тайлов. Теперь не трогаем его,&#10;                    // чтобы ускорение продолжалось до приземления даже после отпускания пальца.&#10;                    selC = c; selR = r; selectionPulse = 0f&#10;                    downX = event.x; downY = event.y&#10;                    return true&#10;                }&#10;                return false&#10;            }&#10;            MotionEvent.ACTION_MOVE -&gt; {&#10;                if (inputLocked) return true&#10;                if (movedThisGesture) return true // уже сделали действие в этом жесте&#10;                if (selC !in 0 until cols || selR !in 0 until rows) return true&#10;                val dx = event.x - downX&#10;                val dy = event.y - downY&#10;                val absDx = abs(dx); val absDy = abs(dy)&#10;                if (max(absDx, absDy) &gt;= clickSlop) {&#10;                    if (absDx &gt; absDy) {&#10;                        // Горизонтальное перетягивание: поведение без изменений&#10;                        val dirX = if (dx &gt; 0) 1 else -1&#10;                        val destC = findHorizontalDestination(selR, selC, dirX)&#10;                        if (destC != selC) {&#10;                            movedThisGesture = true&#10;                            doSwapStart(selR, selC, selR, destC)&#10;                        }&#10;                    } else {&#10;                        // Вертикальное движение&#10;                        val nc = selC&#10;                        val nr = selR&#10;                        val belowR = nr + 1&#10;                        if (dy &gt; 0 &amp;&amp; nc in 0 until cols &amp;&amp; belowR in 0 until rows) {&#10;                            // Тянем вниз: если ниже пусто — включаем ускоренное падение&#10;                            val t = grid[nr][nc]&#10;                            if (t != null &amp;&amp; grid[belowR][nc] == null) {&#10;                                t.softDrop = true&#10;                                // не считаем это самостоятельным действием, продолжаем слушать жест&#10;                                return true&#10;                            }&#10;                        }&#10;                        // Иначе — оставляем прежний своп по вертикали с занятым соседом&#10;                        val dirY = if (dy &gt; 0) 1 else -1&#10;                        val nbrR = selR + dirY&#10;                        if (nc in 0 until cols &amp;&amp; nbrR in 0 until rows &amp;&amp; grid[nbrR][nc] != null) {&#10;                            movedThisGesture = true&#10;                            doSwapStart(selR, selC, nbrR, nc)&#10;                        }&#10;                    }&#10;                }&#10;                return true&#10;            }&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                if (inputLocked) return true&#10;                if (!movedThisGesture) {&#10;                    // Поддержка свопа по тапу соседа (если не было движения)&#10;                    val (uc, ur) = cellAt(event.x, event.y)&#10;                    if (selC in 0 until cols &amp;&amp; selR in 0 until rows &amp;&amp; uc in 0 until cols &amp;&amp; ur in 0 until rows) {&#10;                        val dc = abs(uc - selC); val dr = abs(ur - selR)&#10;                        if (dc + dr == 1 &amp;&amp; grid[ur][uc] != null) {&#10;                            movedThisGesture = true&#10;                            doSwapStart(selR, selC, ur, uc)&#10;                        }&#10;                    }&#10;                }&#10;                // Раньше здесь отключали все софт-дропы. Больше этого не делаем —&#10;                // ускорение сохранится до приземления.&#10;                performClick()&#10;                movedThisGesture = false&#10;                return true&#10;            }&#10;        }&#10;        return super.onTouchEvent(event)&#10;    }&#10;&#10;    private fun clearAllSoftDrops() {&#10;        for (r in 0 until rows) for (c in 0 until cols) {&#10;            grid[r][c]?.softDrop = false&#10;        }&#10;    }&#10;&#10;    override fun performClick(): Boolean {&#10;        super.performClick(); return true&#10;    }&#10;&#10;    private fun cellAt(x: Float, y: Float): Pair&lt;Int, Int&gt; {&#10;        val c = floor((x - gridLeft) / cellSize).toInt()&#10;        val r = floor((y - gridTop) / cellSize).toInt()&#10;        return if (c in 0 until cols &amp;&amp; r in 0 until rows) c to r else -1 to -1&#10;    }&#10;&#10;    private fun lighten(color: Int, amount: Float): Int {&#10;        val hsv = FloatArray(3)&#10;        Color.colorToHSV(color, hsv)&#10;        hsv[2] = (hsv[2] * (1f + amount)).coerceAtMost(1f)&#10;        return Color.HSVToColor(hsv)&#10;    }&#10;&#10;    private fun darken(color: Int, amount: Float): Int {&#10;        val hsv = FloatArray(3)&#10;        Color.colorToHSV(color, hsv)&#10;        hsv[2] = (hsv[2] * (1f - amount)).coerceAtLeast(0f)&#10;        return Color.HSVToColor(hsv)&#10;    }&#10;&#10;    private fun easeOutCubic(t: Float): Float = 1f - (1f - t).pow(3)&#10;}&#10;" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Context&#10;import android.graphics.*&#10;import android.util.AttributeSet&#10;import android.view.Choreographer&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import kotlin.math.*&#10;import kotlin.random.Random&#10;&#10;class BlockMatchGameView @JvmOverloads constructor(&#10;    context: Context,&#10;    attrs: AttributeSet? = null,&#10;    defStyleAttr: Int = 0&#10;) : View(context, attrs, defStyleAttr) {&#10;&#10;    // Callbacks&#10;    var onScoreLevelChanged: ((score: Int, level: Int) -&gt; Unit)? = null&#10;    var onGameOver: (() -&gt; Unit)? = null&#10;&#10;    // Grid&#10;    private val cols = 5&#10;    private val rows = 7&#10;    private var cellSize = 0f&#10;    private var gridLeft = 0f&#10;    private var gridTop = 0f&#10;&#10;    // Timing / loop&#10;    private var running = false&#10;    private var lastFrameNs = 0L&#10;    private val choreographer: Choreographer = Choreographer.getInstance()&#10;    private val frameCallback: Choreographer.FrameCallback = object : Choreographer.FrameCallback {&#10;        override fun doFrame(now: Long) {&#10;            if (!running) return&#10;            if (lastFrameNs == 0L) lastFrameNs = now&#10;            val dt = (now - lastFrameNs) / 1_000_000_000f // seconds&#10;            lastFrameNs = now&#10;            update(dt)&#10;            invalidate()&#10;            choreographer.postFrameCallback(this)&#10;        }&#10;    }&#10;&#10;    // Spawn and speeds&#10;    private var spawnIntervalMs = 1200L&#10;    private var spawnTimerMs = 0f&#10;    private var fallSpeedCellsPerSec = 3f // было 3f, изменится в updateSpeed&#10;    private val minSpawnInterval = 300L&#10;    private val baseSpawnMs = 3840L // было 1920L, в 2 раза реже спавн&#10;    private val spawnStepMs = 384L  // было 192L, в 2 раза реже ускорение спавна&#10;&#10;    // Game state&#10;    private data class Tile(&#10;        var digit: Int,&#10;        var colorIdx: Int,&#10;        var textLight: Boolean,&#10;        // Animations&#10;        var fallOffsetY: Float = 0f, // px offset relative to its grid cell&#10;        var removing: Boolean = false,&#10;        var removeProgress: Float = 0f,&#10;        // Soft-drop флаг: когда пользователь тянет вниз — ускоряем падение только этого тайла&#10;        var softDrop: Boolean = false&#10;    )&#10;    private val grid: Array&lt;Array&lt;Tile?&gt;&gt; = Array(rows) { arrayOfNulls&lt;Tile?&gt;(cols) }&#10;    private var score = 0&#10;    private var level = 1&#10;    private var nextLevelScoreTarget = 20 // раньше 50, теперь +20 за уровень&#10;&#10;    // Interaction / selection &amp; swap&#10;    private var selC = -1&#10;    private var selR = -1&#10;    private var selectionPulse = 0f // radians&#10;    private var inputLocked = false&#10;&#10;    private var downX = 0f&#10;    private var downY = 0f&#10;    private val clickSlop = 12f * resources.displayMetrics.density&#10;&#10;    // Swap animation between two neighbors&#10;    private var swapping = false&#10;    private var swapA_r = -1; private var swapA_c = -1&#10;    private var swapB_r = -1; private var swapB_c = -1&#10;    private var swapProgress = 0f&#10;    private val swapDuration = 0.15f // seconds&#10;&#10;    // Позиции тайлов, которые сместились вниз со време��и последнего стабильного состояния&#10;    private val movedDownSinceLastStable = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;&#10;    // Позиции тайлов, которы�� в этом кадре полностью приземлились (fallOffsetY стал 0)&#10;    private val landedThisFrame = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;&#10;    // Paints&#10;    private val bgPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val borderPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 2f * resources.displayMetrics.density&#10;        color = 0x22000000&#10;    }&#10;    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        textAlign = Paint.Align.CENTER&#10;        typeface = Typeface.create(Typeface.DEFAULT, Typeface.BOLD)&#10;    }&#10;    private val glossyShadow = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        maskFilter = BlurMaskFilter(6f * resources.displayMetrics.density, BlurMaskFilter.Blur.NORMAL)&#10;    }&#10;    private val fillPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val highlightPaint = Paint(Paint.ANTI_ALIAS_FLAG)&#10;    private val blockColors = intArrayOf(&#10;        Color.parseColor(&quot;#FF5252&quot;),&#10;        Color.parseColor(&quot;#FF9800&quot;),&#10;        Color.parseColor(&quot;#FFEB3B&quot;),&#10;        Color.parseColor(&quot;#4CAF50&quot;),&#10;        Color.parseColor(&quot;#00BCD4&quot;),&#10;        Color.parseColor(&quot;#3F51B5&quot;),&#10;        Color.parseColor(&quot;#9C27B0&quot;),&#10;        Color.parseColor(&quot;#795548&quot;)&#10;    )&#10;&#10;    init {&#10;        isClickable = true&#10;        resetGame()&#10;    }&#10;&#10;    fun resetGame() {&#10;        for (r in 0 until rows) for (c in 0 until cols) grid[r][c] = null&#10;        score = 0; level = 1&#10;        nextLevelScoreTarget = 20&#10;        movedDownSinceLastStable.clear()&#10;        landedThisFrame.clear()&#10;        updateSpeed()&#10;        spawnInitial()&#10;        spawnTimerMs = 0f&#10;        onScoreLevelChanged?.invoke(score, level)&#10;    }&#10;&#10;    fun pause() {&#10;        running = false&#10;        lastFrameNs = 0L&#10;        choreographer.removeFrameCallback(frameCallback)&#10;    }&#10;&#10;    fun resume() {&#10;        if (!running) {&#10;            running = true&#10;            lastFrameNs = 0L&#10;            choreographer.postFrameCallback(frameCallback)&#10;        }&#10;    }&#10;&#10;    override fun onDetachedFromWindow() {&#10;        super.onDetachedFromWindow()&#10;        running = false&#10;        lastFrameNs = 0L&#10;        choreographer.removeFrameCallback(frameCallback)&#10;    }&#10;&#10;    private fun spawnInitial() {&#10;        for (r in 0 until 3) for (c in 0 until cols) grid[r][c] = randomTile()&#10;    }&#10;&#10;    private fun randomTile(): Tile {&#10;        val digit = Random.nextInt(0, 10)&#10;        val colorIdx = Random.nextInt(0, blockColors.size)&#10;        val textLight = Random.nextBoolean()&#10;        return Tile(digit, colorIdx, textLight)&#10;    }&#10;&#10;    override fun onSizeChanged(w: Int, h: Int, oldw: Int, oldh: Int) {&#10;        super.onSizeChanged(w, h, oldw, oldh)&#10;        val contentW = w - paddingLeft - paddingRight&#10;        val contentH = h - paddingTop - paddingBottom&#10;        cellSize = min(contentW / cols.toFloat(), contentH / rows.toFloat())&#10;        val gridW = cellSize * cols&#10;        val gridH = cellSize * rows&#10;        gridLeft = paddingLeft + (contentW - gridW) / 2f&#10;        gridTop = paddingTop + (contentH - gridH) / 2f&#10;        textPaint.textSize = cellSize * 0.55f&#10;        updateFallSpeedPx()&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;        // Background grid&#10;        for (r in 0 until rows) for (c in 0 until cols) {&#10;            val l = gridLeft + c * cellSize&#10;            val t = gridTop + r * cellSize&#10;            bgPaint.color = 0x10FFFFFF&#10;            canvas.drawRect(l, t, l + cellSize, t + cellSize, bgPaint)&#10;            canvas.drawRect(l, t, l + cellSize, t + cellSize, borderPaint)&#10;        }&#10;        // Draw tiles with offsets/animations&#10;        for (r in 0 until rows) for (c in 0 until cols) {&#10;            val tile = grid[r][c] ?: continue&#10;            drawTile(canvas, c, r, tile)&#10;        }&#10;    }&#10;&#10;    private fun drawTile(canvas: Canvas, c: Int, r: Int, tile: Tile) {&#10;        // Swap offsets for A/B while animating swap&#10;        var extraX = 0f; var extraY = tile.fallOffsetY&#10;        if (swapping) {&#10;            val dx = (swapB_c - swapA_c) * cellSize&#10;            val dy = (swapB_r - swapA_r) * cellSize&#10;            val t = easeOutCubic(swapProgress)&#10;            if (r == swapA_r &amp;&amp; c == swapA_c) { extraX += dx * t; extraY += dy * t }&#10;            if (r == swapB_r &amp;&amp; c == swapB_c) { extraX -= dx * t; extraY -= dy * t }&#10;        }&#10;        // Selection pulse scaling&#10;        val isSelected = (r == selR &amp;&amp; c == selC &amp;&amp; !swapping)&#10;        val scale = if (isSelected) 1f + 0.06f * sin(selectionPulse) else 1f&#10;&#10;        val cx = gridLeft + c * cellSize + cellSize / 2f + extraX&#10;        val cy = gridTop + r * cellSize + cellSize / 2f + extraY&#10;        val baseSize = cellSize * (if (tile.removing) (1f - 0.6f * tile.removeProgress) else 1f)&#10;        val size = baseSize * scale&#10;        val half = size / 2f&#10;        val left = cx - half&#10;        val top = cy - half&#10;        val right = cx + half&#10;        val bottom = cy + half&#10;&#10;        val color = blockColors[tile.colorIdx]&#10;        val round = cellSize * 0.18f&#10;&#10;        // Shadow&#10;        glossyShadow.color = color&#10;        canvas.drawRoundRect(left + 3f, top + 3f, right + 3f, bottom + 3f, round, round, glossyShadow)&#10;&#10;        // Gradient body (переиспользуем Paint, меняем shader)&#10;        fillPaint.shader = LinearGradient(&#10;            left, top, right, bottom,&#10;            lighten(color, 0.25f), darken(color, 0.15f), Shader.TileMode.CLAMP&#10;        )&#10;&#10;        val save = canvas.save()&#10;        if (tile.removing) {&#10;            val rot = 360f * tile.removeProgress&#10;            canvas.rotate(rot, cx, cy)&#10;        }&#10;        canvas.drawRoundRect(left, top, right, bottom, round, round, fillPaint)&#10;&#10;        // Highlight (переиспользуем Paint, меняем shader)&#10;        highlightPaint.shader = LinearGradient(&#10;            left, top, left, top + size * 0.45f,&#10;            Color.argb(120, 255, 255, 255), Color.TRANSPARENT,&#10;            Shader.TileMode.CLAMP&#10;        )&#10;        val inset = size * 0.06f&#10;        canvas.drawRoundRect(left + inset, top + inset, right - inset, top + size * 0.45f, round, round, highlightPaint)&#10;&#10;        // Digit&#10;        textPaint.color = if (tile.textLight) Color.WHITE else Color.parseColor(&quot;#212121&quot;)&#10;        val text = tile.digit.toString()&#10;        val fm = textPaint.fontMetrics&#10;        val textY = cy - (fm.ascent + fm.descent) / 2f&#10;        canvas.drawText(text, cx, textY, textPaint)&#10;&#10;        canvas.restoreToCount(save)&#10;    }&#10;&#10;    private fun update(dt: Float) {&#10;        // Единственное условие поражения — полный столбец&#10;        if (running &amp;&amp; isAnyColumnFull()) {&#10;            running = false&#10;            onGameOver?.invoke()&#10;            return&#10;        }&#10;&#10;        // Update selection pulse&#10;        if (selC &gt;= 0 &amp;&amp; selR &gt;= 0) selectionPulse = (selectionPulse + dt * 2f * Math.PI).toFloat()&#10;&#10;        // Update removal animations&#10;        var removingActive = false&#10;        if (advanceRemoval(dt)) removingActive = true&#10;&#10;        // Apply gravity smoothly (не двигаем, если сейчас идёт своп/перемещение)&#10;        landedThisFrame.clear()&#10;        val fallingActive = if (!swapping) applyGravitySmooth(dt) else false&#10;&#10;        // Немедленная проверка пар для только что приземлившихся тайлов&#10;        if (landedThisFrame.isNotEmpty()) {&#10;            val pairs = mutableListOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;()&#10;            val used = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;            for ((r, c) in landedThisFrame) {&#10;                val t = grid.getOrNull(r)?.getOrNull(c) ?: continue&#10;                if (t.removing || t.fallOffsetY != 0f) continue&#10;                // ��евый&#10;                val lc = c - 1&#10;                if (lc &gt;= 0) {&#10;                    val lt = grid[r][lc]&#10;                    if (lt != null &amp;&amp; !lt.removing &amp;&amp; lt.fallOffsetY == 0f &amp;&amp; lt.digit == t.digit) {&#10;                        val p1 = r to c; val p2 = r to lc&#10;                        if (p1 !in used &amp;&amp; p2 !in used) {&#10;                            pairs.add(listOf(p1, p2))&#10;                            used.add(p1); used.add(p2)&#10;                            continue&#10;                        }&#10;                    }&#10;                }&#10;                // правый&#10;                val rc = c + 1&#10;                if (rc &lt; cols) {&#10;                    val rt = grid[r][rc]&#10;                    if (rt != null &amp;&amp; !rt.removing &amp;&amp; rt.fallOffsetY == 0f &amp;&amp; rt.digit == t.digit) {&#10;                        val p1 = r to c; val p2 = r to rc&#10;                        if (p1 !in used &amp;&amp; p2 !in used) {&#10;                            pairs.add(listOf(p1, p2))&#10;                            used.add(p1); used.add(p2)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            if (pairs.isNotEmpty()) startRemoving(pairs)&#10;        }&#10;&#10;        // Убрано авто-уничтожение падающих пар и общий поиск совпадений&#10;&#10;        // Update swap animation&#10;        if (swapping) {&#10;            swapProgress += dt / swapDuration&#10;            if (swapProgress &gt;= 1f) {&#10;                // finalize swap&#10;                swapProgress = 1f&#10;                doSwapFinalize()&#10;                swapping = false&#10;                inputLocked = false&#10;                // После завершения любого свопа проверяем пары, которые могли образоваться вручную рядом по горизонтали&#10;                handleManualAdjacencyPairRemoval()&#10;            }&#10;        }&#10;&#10;        // Spawn independently from input&#10;        if (!removingActive &amp;&amp; !swapping) {&#10;            spawnTimerMs += dt * 1000f&#10;            if (spawnTimerMs &gt;= spawnIntervalMs) {&#10;                spawnTimerMs -= spawnIntervalMs&#10;                trySpawn()&#10;            }&#10;        }&#10;&#10;        // Когда система стабилизировалась (нет падения/свопа/удаления),&#10;        // проверяем пары, образованные из-за вертикального смещения сверху&#10;        if (!fallingActive &amp;&amp; !swapping &amp;&amp; !removingActive) {&#10;            if (movedDownSinceLastStable.isNotEmpty()) {&#10;                val pairs = mutableListOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;()&#10;                val seen = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;                for ((r, c) in movedDownSinceLastStable) {&#10;                    val t = grid.getOrNull(r)?.getOrNull(c) ?: continue&#10;                    if (t.removing) continue&#10;                    // Проверяем левого соседа&#10;                    val lc = c - 1&#10;                    if (lc &gt;= 0) {&#10;                        val lt = grid[r][lc]&#10;                        if (lt != null &amp;&amp; !lt.removing &amp;&amp; lt.digit == t.digit) {&#10;                            val p1 = r to c&#10;                            val p2 = r to lc&#10;                            if (p1 !in seen &amp;&amp; p2 !in seen) {&#10;                                pairs.add(listOf(p1, p2))&#10;                                seen.add(p1); seen.add(p2)&#10;                            }&#10;                        }&#10;                    }&#10;                    // Проверяем правого соседа&#10;                    val rc = c + 1&#10;                    if (rc &lt; cols) {&#10;                        val rt = grid[r][rc]&#10;                        if (rt != null &amp;&amp; !rt.removing &amp;&amp; rt.digit == t.digit) {&#10;                            val p1 = r to c&#10;                            val p2 = r to rc&#10;                            if (p1 !in seen &amp;&amp; p2 !in seen) {&#10;                                pairs.add(listOf(p1, p2))&#10;                                seen.add(p1); seen.add(p2)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                movedDownSinceLastStable.clear()&#10;                if (pairs.isNotEmpty()) startRemoving(pairs)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isAnyColumnFull(): Boolean {&#10;        for (c in 0 until cols) {&#10;            var full = true&#10;            for (r in 0 until rows) {&#10;                if (grid[r][c] == null) { full = false; break }&#10;            }&#10;            if (full) return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    private fun advanceRemoval(dt: Float): Boolean {&#10;        var any = false&#10;        var finishedAll = true&#10;        for (r in 0 until rows) for (c in 0 until cols) {&#10;            val t = grid[r][c] ?: continue&#10;            if (t.removing) {&#10;                any = true&#10;                t.removeProgress += dt * 8f // fast&#10;                if (t.removeProgress &gt;= 1f) {&#10;                    grid[r][c] = null&#10;                } else finishedAll = false&#10;            }&#10;        }&#10;        if (any &amp;&amp; finishedAll) {&#10;            score += pendingScoreGain&#10;            pendingScoreGain = 0&#10;            updateLevel()&#10;            // Снятие блокировки ввода: удаление завершено&#10;            inputLocked = false&#10;        }&#10;        return any&#10;    }&#10;&#10;    private fun applyGravitySmooth(dt: Float): Boolean {&#10;        var anyFalling = false&#10;        val baseFallPxPerSec = fallSpeedCellsPerSec * cellSize&#10;        for (c in 0 until cols) {&#10;            // from bottom-2 to top to pull down chain&#10;            for (r in rows - 2 downTo 0) {&#10;                val t = grid[r][c] ?: continue&#10;                if (t.removing) continue&#10;                val fallPxPerSec = if (t.softDrop) baseFallPxPerSec * 3f else baseFallPxPerSec&#10;                var belowR = r + 1&#10;                if (grid[belowR][c] == null) {&#10;                    anyFalling = true&#10;                    t.fallOffsetY += fallPxPerSec * dt&#10;                    var movedDown = false&#10;                    while (t.fallOffsetY &gt;= cellSize &amp;&amp; belowR &lt;= rows - 1) {&#10;                        // move down by one cell&#10;                        t.fallOffsetY -= cellSize&#10;                        grid[belowR][c] = t&#10;                        grid[belowR - 1][c] = null&#10;                        movedDown = true&#10;                        belowR++&#10;                        if (belowR &gt; rows - 1 || grid[belowR][c] != null) break&#10;                    }&#10;                    if (movedDown) {&#10;                        val finalR = belowR - 1&#10;                        movedDownSinceLastStable.add(finalR to c)&#10;                        // Если приземлились на дно, считаем посадку завершённой в этом кадре&#10;                        if (finalR == rows - 1) {&#10;                            if (t.fallOffsetY != 0f) {&#10;                                t.fallOffsetY = 0f&#10;                                landedThisFrame.add(finalR to c)&#10;                            }&#10;                            // Сброс софт-дропа на приземлении&#10;                            t.softDrop = false&#10;                        }&#10;                    }&#10;                } else {&#10;                    // Snap if offset exists&#10;                    val wasOffset = t.fallOffsetY&#10;                    if (t.fallOffsetY != 0f) anyFalling = true&#10;                    t.fallOffsetY = max(0f, t.fallOffsetY - fallPxPerSec * dt)&#10;                    if (wasOffset &gt; 0f &amp;&amp; t.fallOffsetY == 0f) {&#10;                        // тайл только что приземлился&#10;                        landedThisFrame.add(r to c)&#10;                    }&#10;                    // Если под нами занято и смещение обнулилось — больше не ускоряем&#10;                    if (grid[belowR][c] != null &amp;&amp; t.fallOffsetY == 0f) t.softDrop = false&#10;                }&#10;            }&#10;        }&#10;        return anyFalling&#10;    }&#10;&#10;    private var pendingScoreGain = 0&#10;    private fun startRemoving(matches: List&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;) {&#10;        // Жёсткая валидация пар на всякий случай: только 2 соседние по горизонтали плитки,&#10;        // в одной строке, со совпадающими цифрами и без смещения падения&#10;        val valid = mutableListOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        val used = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        for (pair in matches) {&#10;            if (pair.size != 2) continue&#10;            val (r1, c1) = pair[0]&#10;            val (r2, c2) = pair[1]&#10;            if (r1 !in 0 until rows || c1 !in 0 until cols) continue&#10;            if (r2 !in 0 until rows || c2 !in 0 until cols) continue&#10;            val t1 = grid[r1][c1]&#10;            val t2 = grid[r2][c2]&#10;            if (t1 == null || t2 == null) continue&#10;            if (t1.removing || t2.removing) continue&#10;            if (r1 != r2) continue&#10;            if (kotlin.math.abs(c1 - c2) != 1) continue&#10;            if (t1.digit != t2.digit) continue&#10;            if (t1.fallOffsetY != 0f || t2.fallOffsetY != 0f) continue&#10;            if ((r1 to c1) in used || (r2 to c2) in used) continue&#10;            valid += (r1 to c1)&#10;            valid += (r2 to c2)&#10;            used += (r1 to c1)&#10;            used += (r2 to c2)&#10;        }&#10;        if (valid.isEmpty()) return&#10;&#10;        pendingScoreGain = 0&#10;        for ((r, c) in valid) {&#10;            val t = grid[r][c]&#10;            if (t != null &amp;&amp; !t.removing) {&#10;                t.removing = true&#10;                t.removeProgress = 0f&#10;                pendingScoreGain += 1&#10;            }&#10;        }&#10;        inputLocked = true&#10;        // Deselect during removal&#10;        selC = -1; selR = -1&#10;    }&#10;&#10;    private fun handleManualAdjacencyPairRemoval() {&#10;        // Проверяем горизонтальных соседей для обеих конечных позиций свопа&#10;        val candidates = listOf(swapA_r to swapA_c, swapB_r to swapB_c)&#10;        val pairs = mutableListOf&lt;List&lt;Pair&lt;Int, Int&gt;&gt;&gt;()&#10;        val used = mutableSetOf&lt;Pair&lt;Int, Int&gt;&gt;()&#10;        for ((r, c) in candidates) {&#10;            if (r !in 0 until rows || c !in 0 until cols) continue&#10;            val t = grid[r][c] ?: continue&#10;            if ((r to c) in used || t.removing) continue&#10;            // сначала левый сосед&#10;            val lc = c - 1&#10;            if (lc &gt;= 0) {&#10;                val lt = grid[r][lc]&#10;                if (lt != null &amp;&amp; !lt.removing &amp;&amp; lt.digit == t.digit &amp;&amp; (r to lc) !in used) {&#10;                    pairs.add(listOf(r to c, r to lc))&#10;                    used.add(r to c); used.add(r to lc)&#10;                    continue&#10;                }&#10;            }&#10;            // затем правый сосед&#10;            val rc = c + 1&#10;            if (rc &lt; cols) {&#10;                val rt = grid[r][rc]&#10;                if (rt != null &amp;&amp; !rt.removing &amp;&amp; rt.digit == t.digit &amp;&amp; (r to rc) !in used) {&#10;                    pairs.add(listOf(r to c, r to rc))&#10;                    used.add(r to c); used.add(r to rc)&#10;                }&#10;            }&#10;        }&#10;        if (pairs.isNotEmpty()) startRemoving(pairs)&#10;    }&#10;&#10;    private fun doSwapStart(r1: Int, c1: Int, r2: Int, c2: Int) {&#10;        if (swapping) return&#10;        swapping = true&#10;        inputLocked = true&#10;        swapA_r = r1; swapA_c = c1&#10;        swapB_r = r2; swapB_c = c2&#10;        swapProgress = 0f&#10;    }&#10;&#10;    private fun doSwapFinalize() {&#10;        // Exchange tiles in grid&#10;        val a = grid[swapA_r][swapA_c]&#10;        val b = grid[swapB_r][swapB_c]&#10;        grid[swapA_r][swapA_c] = b&#10;        grid[swapB_r][swapB_c] = a&#10;        selR = swapB_r; selC = swapB_c // keep selection on moved tile&#10;        selectionPulse = 0f&#10;    }&#10;&#10;    private fun trySpawn(): Boolean {&#10;        val freeCols = (0 until cols).filter { grid[0][it] == null }&#10;        if (freeCols.isEmpty()) {&#10;            // Нет места для спавна — пропускаем этот тик&#10;            return false&#10;        }&#10;        val col = freeCols.random()&#10;        val tile = randomTile()&#10;        tile.fallOffsetY = -cellSize // start above the cell for a nicer drop-in&#10;        grid[0][col] = tile&#10;        return true&#10;    }&#10;&#10;    private fun updateLevel() {&#10;        var levelChanged = false&#10;        while (score &gt;= nextLevelScoreTarget) {&#10;            level += 1&#10;            nextLevelScoreTarget += 20 // фиксированный шаг +20 очков&#10;            levelChanged = true&#10;        }&#10;        if (levelChanged) {&#10;            updateSpeed()&#10;        }&#10;        onScoreLevelChanged?.invoke(score, level)&#10;    }&#10;&#10;    private fun updateSpeed() {&#10;        // Ещё реже спавн (в 2 раза):&#10;        spawnIntervalMs = (baseSpawnMs - (level - 1) * spawnStepMs).coerceAtLeast(minSpawnInterval)&#10;        // Падение в 2 раза медленнее: базу и шаг делим на 2&#10;        fallSpeedCellsPerSec = 1.5f + (level - 1) * 0.4f&#10;        updateFallSpeedPx()&#10;    }&#10;&#10;    private fun updateFallSpeedPx() {&#10;        // no-op placeholder if later we add pixel-speed cache&#10;    }&#10;&#10;    // Input handling: select, tap neighbor to swap, drag to swap&#10;    private var movedThisGesture = false&#10;&#10;    // Вычисление дальнего доступного столбца по горизонтали в направлении dirX&#10;    // Если соседняя ячейка пуста — двигаем только на одну клетку в сторону.&#10;    // Если соседняя занята — выполняем обычный своп с соседом.&#10;    private fun findHorizontalDestination(row: Int, col: Int, dirX: Int): Int {&#10;        if (dirX == 0) return col&#10;        val next = col + dirX&#10;        return if (next in 0 until cols) next else col&#10;    }&#10;&#10;    override fun onTouchEvent(event: MotionEvent): Boolean {&#10;        if (!running) return super.onTouchEvent(event)&#10;        when (event.actionMasked) {&#10;            MotionEvent.ACTION_DOWN -&gt; {&#10;                if (inputLocked) return true&#10;                val (c, r) = cellAt(event.x, event.y)&#10;                movedThisGesture = false&#10;                if (c in 0 until cols &amp;&amp; r in 0 until rows &amp;&amp; grid[r][c] != null) {&#10;                    // Раньше здесь сбрасывался софт-дроп у всех тайлов. Теперь не трогаем его,&#10;                    // чтобы ускорение продолжалось до приземления даже после отпускания пальца.&#10;                    selC = c; selR = r; selectionPulse = 0f&#10;                    downX = event.x; downY = event.y&#10;                    return true&#10;                }&#10;                return false&#10;            }&#10;            MotionEvent.ACTION_MOVE -&gt; {&#10;                if (inputLocked) return true&#10;                if (movedThisGesture) return true // уже сделали действие в этом жесте&#10;                if (selC !in 0 until cols || selR !in 0 until rows) return true&#10;                val dx = event.x - downX&#10;                val dy = event.y - downY&#10;                val absDx = abs(dx); val absDy = abs(dy)&#10;                if (max(absDx, absDy) &gt;= clickSlop) {&#10;                    if (absDx &gt; absDy) {&#10;                        // Горизонтальное перетягивание: поведение без изменений&#10;                        val dirX = if (dx &gt; 0) 1 else -1&#10;                        val destC = findHorizontalDestination(selR, selC, dirX)&#10;                        if (destC != selC) {&#10;                            movedThisGesture = true&#10;                            doSwapStart(selR, selC, selR, destC)&#10;                        }&#10;                    } else {&#10;                        // Вертикальное движение&#10;                        val nc = selC&#10;                        val nr = selR&#10;                        val belowR = nr + 1&#10;                        if (dy &gt; 0 &amp;&amp; nc in 0 until cols &amp;&amp; belowR in 0 until rows) {&#10;                            // Тянем вниз: если ниже пусто — включаем ускоренное падение&#10;                            val t = grid[nr][nc]&#10;                            if (t != null &amp;&amp; grid[belowR][nc] == null) {&#10;                                t.softDrop = true&#10;                                // не считаем это самостоятельным действием, продолжаем слушать жест&#10;                                return true&#10;                            }&#10;                        }&#10;                        // Иначе — оставляем прежний своп по вертикали с занятым соседом&#10;                        val dirY = if (dy &gt; 0) 1 else -1&#10;                        val nbrR = selR + dirY&#10;                        if (nc in 0 until cols &amp;&amp; nbrR in 0 until rows &amp;&amp; grid[nbrR][nc] != null) {&#10;                            movedThisGesture = true&#10;                            doSwapStart(selR, selC, nbrR, nc)&#10;                        }&#10;                    }&#10;                }&#10;                return true&#10;            }&#10;            MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -&gt; {&#10;                if (inputLocked) return true&#10;                if (!movedThisGesture) {&#10;                    // Поддержка свопа по тапу соседа (если не было движения)&#10;                    val (uc, ur) = cellAt(event.x, event.y)&#10;                    if (selC in 0 until cols &amp;&amp; selR in 0 until rows &amp;&amp; uc in 0 until cols &amp;&amp; ur in 0 until rows) {&#10;                        val dc = abs(uc - selC); val dr = abs(ur - selR)&#10;                        if (dc + dr == 1 &amp;&amp; grid[ur][uc] != null) {&#10;                            movedThisGesture = true&#10;                            doSwapStart(selR, selC, ur, uc)&#10;                        }&#10;                    }&#10;                }&#10;                // Раньше здесь отключали все с��фт-дропы. Больше этого не делаем —&#10;                // ускорение сохранится до приземления.&#10;                performClick()&#10;                movedThisGesture = false&#10;                return true&#10;            }&#10;        }&#10;        return super.onTouchEvent(event)&#10;    }&#10;&#10;    private fun clearAllSoftDrops() {&#10;        for (r in 0 until rows) for (c in 0 until cols) {&#10;            grid[r][c]?.softDrop = false&#10;        }&#10;    }&#10;&#10;    override fun performClick(): Boolean {&#10;        super.performClick(); return true&#10;    }&#10;&#10;    private fun cellAt(x: Float, y: Float): Pair&lt;Int, Int&gt; {&#10;        val c = floor((x - gridLeft) / cellSize).toInt()&#10;        val r = floor((y - gridTop) / cellSize).toInt()&#10;        return if (c in 0 until cols &amp;&amp; r in 0 until rows) c to r else -1 to -1&#10;    }&#10;&#10;    private fun lighten(color: Int, amount: Float): Int {&#10;        val hsv = FloatArray(3)&#10;        Color.colorToHSV(color, hsv)&#10;        hsv[2] = (hsv[2] * (1f + amount)).coerceAtMost(1f)&#10;        return Color.HSVToColor(hsv)&#10;    }&#10;&#10;    private fun darken(color: Int, amount: Float): Int {&#10;        val hsv = FloatArray(3)&#10;        Color.colorToHSV(color, hsv)&#10;        hsv[2] = (hsv[2] * (1f - amount)).coerceAtLeast(0f)&#10;        return Color.HSVToColor(hsv)&#10;    }&#10;&#10;    private fun easeOutCubic(t: Float): Float = 1f - (1f - t).pow(3)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/BubbleCatchActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/BubbleCatchActivity.kt" />
              <option name="originalContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.animation.Animator&#10;import android.animation.AnimatorListenerAdapter&#10;import android.animation.AnimatorSet&#10;import android.animation.ObjectAnimator&#10;import android.content.pm.ActivityInfo&#10;import android.graphics.Color&#10;import android.graphics.Paint&#10;import android.graphics.LinearGradient&#10;import android.graphics.RadialGradient&#10;import android.graphics.Shader&#10;import android.graphics.PorterDuff&#10;import android.graphics.PorterDuffXfermode&#10;import android.graphics.RectF&#10;import android.graphics.drawable.Drawable&#10;import android.graphics.drawable.TransitionDrawable&#10;import android.os.Bundle&#10;import android.os.CountDownTimer&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.os.SystemClock&#10;import android.speech.tts.TextToSpeech&#10;import android.util.TypedValue&#10;import android.view.Gravity&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.view.animation.AccelerateDecelerateInterpolator&#10;import android.view.animation.AccelerateInterpolator&#10;import android.widget.FrameLayout&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import java.util.Locale&#10;import kotlin.math.abs&#10;import kotlin.math.floor&#10;import kotlin.math.hypot&#10;import kotlin.math.max&#10;import kotlin.math.min&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class BubbleCatchActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private lateinit var gameField: FrameLayout&#10;    private lateinit var timerText: TextView&#10;    private lateinit var scoreText: TextView&#10;    private lateinit var targetText: TextView&#10;    private lateinit var progressBar: ProgressBar&#10;&#10;    private var score = 0&#10;    private val totalLevels = 10&#10;    private var currentLevel = 0&#10;    private val digitsOrder = (0..9).shuffled().toMutableList()&#10;    private var targetDigit = 0&#10;&#10;    private var tts: TextToSpeech? = null&#10;    private var levelTimer: CountDownTimer? = null&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var spawnRunnable: Runnable? = null&#10;    private val scheduledIncrements = mutableListOf&lt;Runnable&gt;()&#10;&#10;    // Градиентный фон&#10;    private lateinit var rootView: View&#10;    private val gradientHandler = Handler(Looper.getMainLooper())&#10;    private var gradientRunnable: Runnable? = null&#10;    private var gradientIndex = 0&#10;    private val gradientIds = intArrayOf(&#10;        R.drawable.child_gradient_yellow,&#10;        R.drawable.child_gradient_blue,&#10;        R.drawable.child_gradient_purple&#10;    )&#10;&#10;    // Параметры игры&#10;    private var currentConcurrentLimit: Int = 5&#10;    private val maxConcurrentCapBase: Int = 15&#10;&#10;    // Вероятность появления целевой цифры&#10;    private val targetDigitProbability = 0.35f&#10;&#10;    // Словесные названия чисел для TTS&#10;    private val numberWords = arrayOf(&#10;        &quot;ноль&quot;, &quot;один&quot;, &quot;два&quot;, &quot;три&quot;, &quot;четыре&quot;, &quot;пять&quot;,&#10;        &quot;шесть&quot;, &quot;семь&quot;, &quot;восемь&quot;, &quot;девять&quot;&#10;    )&#10;&#10;    // Короткие фразы для озвучивания событий&#10;    private val correctHitPhrases = listOf(&#10;        &quot;Отлично!&quot;, &quot;Верно!&quot;, &quot;Правильно!&quot;, &quot;Так держать!&quot;, &quot;Молодец!&quot;&#10;    )&#10;    private val wrongHitPhrases = listOf(&#10;        &quot;Не та цифра.&quot;, &quot;Промах.&quot;, &quot;Неверно.&quot;, &quot;Попробуй ещё.&quot;, &quot;Это не она.&quot;&#10;    )&#10;    private val missedPhrases = listOf(&#10;        &quot;Ты упустил нужный шарик.&quot;, &quot;Нужный шарик улетел.&quot;, &quot;Цель улетела.&quot;, &quot;Будь внимательнее.&quot;&#10;    )&#10;&#10;    // Список активных шариков и апдейт-цикл&#10;    private data class Bubble(&#10;        val view: View,&#10;        var x: Float,&#10;        var y: Float,&#10;        var vx: Float,&#10;        var vy: Float,&#10;        val radius: Float,&#10;        val value: Int,&#10;        var clickable: Boolean = true&#10;    )&#10;    private val bubbles = mutableListOf&lt;Bubble&gt;()&#10;    private var updateRunnable: Runnable? = null&#10;    private var lastUpdateMs: Long = 0L&#10;&#10;    // Интервал спавна (уменьшается каждые 10 секунд уровня)&#10;    private val baseSpawnIntervalMs = 900L&#10;    private var currentSpawnIntervalMs = baseSpawnIntervalMs&#10;    private val minSpawnIntervalMs = 300L&#10;    private val scheduledSpawnReductions = mutableListOf&lt;Runnable&gt;()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_bubble_catch)&#10;        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT&#10;&#10;        rootView = findViewById(R.id.main)&#10;        ViewCompat.setOnApplyWindowInsetsListener(rootView) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;        startGradientAnimation()&#10;&#10;        tts = TextToSpeech(this, this)&#10;        setupViews()&#10;        setupBackButton()&#10;    }&#10;&#10;    // Градиент фона&#10;    private fun startGradientAnimation() {&#10;        stopGradientAnimation()&#10;        fun nextIndex(i: Int) = (i + 1) % gradientIds.size&#10;        gradientRunnable = object : Runnable {&#10;            override fun run() {&#10;                val curr = ContextCompat.getDrawable(this@BubbleCatchActivity, gradientIds[gradientIndex])&#10;                val next = ContextCompat.getDrawable(this@BubbleCatchActivity, gradientIds[nextIndex(gradientIndex)])&#10;                if (curr != null &amp;&amp; next != null) {&#10;                    val td = TransitionDrawable(arrayOf(curr, next))&#10;                    rootView.background = td&#10;                    td.isCrossFadeEnabled = true&#10;                    td.startTransition(6000)&#10;                }&#10;                gradientIndex = nextIndex(gradientIndex)&#10;                gradientHandler.postDelayed(this, 6000L)&#10;            }&#10;        }&#10;        gradientHandler.post(gradientRunnable!!)&#10;    }&#10;    private fun stopGradientAnimation() {&#10;        gradientRunnable?.let { gradientHandler.removeCallbacks(it) }&#10;        gradientRunnable = null&#10;    }&#10;&#10;    private fun setupViews() {&#10;        gameField = findViewById(R.id.gameField)&#10;        timerText = findViewById(R.id.timerText)&#10;        scoreText = findViewById(R.id.scoreText)&#10;        targetText = findViewById(R.id.targetText)&#10;        progressBar = findViewById(R.id.levelProgressBar)&#10;&#10;        scoreText.text = score.toString()&#10;        progressBar.max = LEVEL_DURATION_MS.toInt()&#10;        progressBar.progress = LEVEL_DURATION_MS.toInt()&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.speakerButton).setOnClickListener { speakTarget() }&#10;    }&#10;&#10;    private fun setupBackButton() {&#10;        findViewById&lt;ImageView&gt;(R.id.backButton).setOnClickListener { finish() }&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            tts?.language = Locale.forLanguageTag(&quot;ru-RU&quot;)&#10;            startNextLevel()&#10;        }&#10;    }&#10;&#10;    private fun startNextLevel() {&#10;        if (currentLevel &gt;= totalLevels) { finishGame(); return }&#10;&#10;        // Настройка цели уровня&#10;        targetDigit = digitsOrder[currentLevel]&#10;        targetText.text = targetDigit.toString()&#10;        speakTarget()&#10;&#10;        // Таймер уровня&#10;        levelTimer?.cancel()&#10;        levelTimer = object : CountDownTimer(LEVEL_DURATION_MS, 100L) {&#10;            override fun onTick(millisUntilFinished: Long) { updateTimerUi(millisUntilFinished) }&#10;            override fun onFinish() {&#10;                updateTimerUi(0)&#10;                stopSpawning()&#10;                clearAllBubbles()&#10;                currentLevel++&#10;                gameField.postDelayed({ startNextLevel() }, 600)&#10;            }&#10;        }.start()&#10;&#10;        // Динамика одновременных шариков на уровне&#10;        currentConcurrentLimit = 5&#10;        scheduleConcurrencyIncrements()&#10;&#10;        // Сброс и планирование уменьшения интервала спавна каждые 3 секунды&#10;        currentSpawnIntervalMs = baseSpawnIntervalMs&#10;        scheduleSpawnIntervalReductions()&#10;&#10;        // Старт апдейт-цикла и спавна&#10;        startUpdateLoop()&#10;        startSpawning()&#10;    }&#10;&#10;    private fun updateTimerUi(millisUntilFinished: Long) {&#10;        val seconds = (millisUntilFinished / 1000).toInt()&#10;        timerText.text = String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, seconds / 60, seconds % 60)&#10;        progressBar.progress = millisUntilFinished.toInt()&#10;    }&#10;&#10;    private fun scheduleConcurrencyIncrements() {&#10;        cancelScheduledIncrements()&#10;        val stepMs = 10_000L&#10;        var delay = stepMs&#10;        repeat(10) {&#10;            val r = Runnable { currentConcurrentLimit = min(currentConcurrentLimit + 1, maxConcurrentCapBase) }&#10;            scheduledIncrements += r&#10;            handler.postDelayed(r, delay)&#10;            delay += stepMs&#10;        }&#10;    }&#10;    private fun cancelScheduledIncrements() {&#10;        scheduledIncrements.forEach { handler.removeCallbacks(it) }&#10;        scheduledIncrements.clear()&#10;    }&#10;&#10;    private fun scheduleSpawnIntervalReductions() {&#10;        cancelScheduledSpawnReductions()&#10;        var delay = 3_000L&#10;        while (delay &lt; LEVEL_DURATION_MS) {&#10;            val r = Runnable {&#10;                currentSpawnIntervalMs = (currentSpawnIntervalMs - 100L).coerceAtLeast(minSpawnIntervalMs)&#10;            }&#10;            scheduledSpawnReductions += r&#10;            handler.postDelayed(r, delay)&#10;            delay += 3_000L&#10;        }&#10;    }&#10;    private fun cancelScheduledSpawnReductions() {&#10;        if (scheduledSpawnReductions.isNotEmpty()) {&#10;            scheduledSpawnReductions.forEach { handler.removeCallbacks(it) }&#10;            scheduledSpawnReductions.clear()&#10;        }&#10;    }&#10;&#10;    private fun startSpawning() {&#10;        stopSpawning()&#10;        spawnRunnable = object : Runnable {&#10;            override fun run() {&#10;                val active = bubbles.size&#10;                if (active &lt; currentConcurrentLimit) {&#10;                    val deficit = currentConcurrentLimit - active&#10;                    val batch = Random.nextInt(1, min(3, deficit) + 1)&#10;                    spawnBubbles(batch)&#10;                }&#10;                handler.postDelayed(this, currentSpawnIntervalMs)&#10;            }&#10;        }&#10;        handler.post(spawnRunnable!!)&#10;    }&#10;    private fun stopSpawning() {&#10;        spawnRunnable?.let { handler.removeCallbacks(it) }&#10;        spawnRunnable = null&#10;        cancelScheduledIncrements()&#10;        cancelScheduledSpawnReductions()&#10;    }&#10;&#10;    private fun startUpdateLoop() {&#10;        if (updateRunnable != null) return&#10;        lastUpdateMs = SystemClock.uptimeMillis()&#10;        updateRunnable = object : Runnable {&#10;            override fun run() {&#10;                val now = SystemClock.uptimeMillis()&#10;                val dt = ((now - lastUpdateMs).coerceAtMost(50)).toFloat() / 1000f&#10;                lastUpdateMs = now&#10;                stepPhysics(dt)&#10;                handler.postDelayed(this, 16L)&#10;            }&#10;        }&#10;        handler.post(updateRunnable!!)&#10;    }&#10;    private fun stopUpdateLoop() { updateRunnable?.let { handler.removeCallbacks(it) }; updateRunnable = null }&#10;&#10;    private fun stepPhysics(dt: Float) {&#10;        if (gameField.width == 0 || gameField.height == 0) return&#10;        val width = gameField.width&#10;&#10;        // Обновление позиций&#10;        for (b in bubbles) {&#10;            b.x += b.vx * dt&#10;            b.y += b.vy * dt&#10;            // столкновения со стенами (по X), небольшое затухание&#10;            if (b.x &lt; 0f) { b.x = 0f; b.vx = -b.vx * 0.9f }&#10;            val maxX = (width - b.radius * 2)&#10;            if (b.x &gt; maxX) { b.x = maxX; b.vx = -b.vx * 0.9f }&#10;        }&#10;&#10;        // Столкновения между шарами (упругие, почти)&#10;        for (i in 0 until bubbles.size) {&#10;            val a = bubbles[i]&#10;            for (j in i + 1 until bubbles.size) {&#10;                val c = bubbles[j]&#10;                val ax = a.x + a.radius&#10;                val ay = a.y + a.radius&#10;                val cx = c.x + c.radius&#10;                val cy = c.y + c.radius&#10;                val dx = cx - ax&#10;                val dy = cy - ay&#10;                val dist = hypot(dx, dy)&#10;                val minDist = a.radius + c.radius + dpf(6f) // небольшой зазор&#10;                if (dist &lt; minDist &amp;&amp; dist &gt; 0f) {&#10;                    // Раздвигаем на половины перекрытия&#10;                    val overlap = (minDist - dist)&#10;                    val nx = dx / dist&#10;                    val ny = dy / dist&#10;                    a.x -= nx * (overlap / 2f)&#10;                    a.y -= ny * (overlap / 2f)&#10;                    c.x += nx * (overlap / 2f)&#10;                    c.y += ny * (overlap / 2f)&#10;                    // Импульс по ��ормали (равные массы)&#10;                    val rvx = c.vx - a.vx&#10;                    val rvy = c.vy - a.vy&#10;                    val vn = rvx * nx + rvy * ny&#10;                    if (vn &lt; 0f) {&#10;                        val e = 0.8f // коэффициент реституции&#10;                        val jImp = -(1 + e) * vn / 2f&#10;                        val jx = jImp * nx&#10;                        val jy = jImp * ny&#10;                        a.vx -= jx; a.vy -= jy&#10;                        c.vx += jx; c.vy += jy&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Удаление улетевших и обновление view&#10;        val iterator = bubbles.iterator()&#10;        while (iterator.hasNext()) {&#10;            val b = iterator.next()&#10;            if (b.y + b.radius * 2 &lt; 0) {&#10;                if (b.clickable &amp;&amp; b.value == targetDigit) {&#10;                    score -= 1&#10;                    if (score &lt; 0) {&#10;                        score = 0&#10;                        scoreText.text = &quot;0&quot;&#10;                        tts?.speak(missedPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;missed&quot;)&#10;                        triggerGameOver()&#10;                        return&#10;                    } else {&#10;                        scoreText.text = score.toString()&#10;                        tts?.speak(missedPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;missed&quot;)&#10;                    }&#10;                }&#10;                (b.view.parent as? ViewGroup)?.removeView(b.view)&#10;                iterator.remove()&#10;                continue&#10;            }&#10;            b.view.x = b.x&#10;            b.view.y = b.y&#10;        }&#10;    }&#10;&#10;    private fun spawnBubbles(count: Int) {&#10;        val sizes = IntArray(count) { dp(Random.nextInt(84, 126)) }&#10;        gameField.post {&#10;            val startYBase = gameField.height&#10;&#10;            // Колонки по ширине&#10;            val maxSizePx = dp(126)&#10;            val laneGap = dp(12) // увеличенный зазор&#10;            val laneWidth = max(maxSizePx + laneGap, 1)&#10;            val lanes = floor(gameField.width.toFloat() / laneWidth).toInt().coerceAtLeast(1)&#10;            val centers = FloatArray(lanes) { i -&gt; (laneWidth / 2f) + i * laneWidth }&#10;&#10;            repeat(count) { idx -&gt;&#10;                val size = sizes[idx]&#10;                val startY = startYBase + size&#10;                val endY = -size&#10;&#10;                // Подбор X: по свободным колонкам, затем fallback&#10;                val order = (0 until lanes).shuffled()&#10;                var chosenX: Float? = null&#10;                for (li in order) {&#10;                    val cx = centers[li]&#10;                    val xCand = (cx - size / 2f).coerceIn(0f, (gameField.width - size).toFloat())&#10;                    if (!willOverlapStrict(xCand, startY.toFloat(), size)) { chosenX = xCand; break }&#10;                }&#10;                val x = chosenX ?: findFreeX(size, startY)&#10;&#10;                // Создание view и модели&#10;                val bubbleView = FrameLayout(this).apply {&#10;                    layoutParams = FrameLayout.LayoutParams(size, size)&#10;                    this.x = x&#10;                    this.y = startY.toFloat()&#10;                    background = createGlossyBubbleDrawable(randomBubbleColor(), size)&#10;                }&#10;                val value = if (Random.nextFloat() &lt; targetDigitProbability) targetDigit else {&#10;                    var v: Int; do { v = Random.nextInt(0, 10) } while (v == targetDigit); v&#10;                }&#10;                val text = TextView(this).apply {&#10;                    layoutParams = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)&#10;                    setTextSize(TypedValue.COMPLEX_UNIT_SP, 22f)&#10;                    setTextColor(Color.WHITE)&#10;                    gravity = Gravity.CENTER&#10;                    setShadowLayer(4f, 0f, 2f, Color.parseColor(&quot;#66000000&quot;))&#10;                    text = value.toString()&#10;                }&#10;                bubbleView.addView(text)&#10;&#10;                val radius = size / 2f&#10;                // Базовая скорость по вертикали (px/с) ~ путь / 6с, с разбросом&#10;                val travelDist = (startY - endY).toFloat()&#10;                val baseVy = -travelDist / 6f&#10;                val vy = baseVy * Random.nextDouble(0.85, 1.25).toFloat()&#10;                val vx = dp(8) * Random.nextDouble(-0.6, 0.6).toFloat() // небольшой боковой дрейф&#10;&#10;                val model = Bubble(bubbleView, x, startY.toFloat(), vx, vy, radius, value, true)&#10;                bubbleView.isClickable = true&#10;                bubbleView.setOnClickListener {&#10;                    if (!model.clickable) return@setOnClickListener&#10;                    if (model.value == targetDigit) {&#10;                        score += 2&#10;                        scoreText.text = score.toString()&#10;                        tts?.speak(correctHitPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;hit_ok&quot;)&#10;                        model.clickable = false&#10;                        bubbles.remove(model)&#10;                        animateCorrectBubbleAndRemove(bubbleView)&#10;                    } else {&#10;                        score -= 1&#10;                        if (score &lt; 0) {&#10;                            score = 0&#10;                            scoreText.text = &quot;0&quot;&#10;                            bubbleView.performHapticFeedback(android.view.HapticFeedbackConstants.KEYBOARD_TAP)&#10;                            animateWrongBubble(bubbleView)&#10;                            tts?.speak(wrongHitPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;hit_bad&quot;)&#10;                            triggerGameOver()&#10;                        } else {&#10;                            scoreText.text = score.toString()&#10;                            bubbleView.performHapticFeedback(android.view.HapticFeedbackConstants.KEYBOARD_TAP)&#10;                            animateWrongBubble(bubbleView)&#10;                            tts?.speak(wrongHitPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;hit_bad&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                gameField.addView(bubbleView)&#10;                bubbles.add(model)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Строгая проверка перекрытий: радиусы + гориз./верт. з��зоры&#10;    private fun willOverlapStrict(xTopLeft: Float, yTopLeft: Float, size: Int): Boolean {&#10;        val cx = xTopLeft + size / 2f&#10;        val cy = yTopLeft + size / 2f&#10;        val r = size / 2f&#10;        val gap = dpf(12f)&#10;        val minH = dpf(10f)&#10;        val minV = dpf(10f)&#10;        for (b in bubbles) {&#10;            val bx = b.x + b.radius&#10;            val by = b.y + b.radius&#10;            val dx = abs(cx - bx)&#10;            val dy = abs(cy - by)&#10;            val centerDist = hypot(dx, dy)&#10;            val radiusSum = r + b.radius + gap&#10;            if (centerDist &lt; radiusSum) return true&#10;            if (dx &lt; minH &amp;&amp; dy &lt; minV) return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    private fun findFreeX(sizePx: Int, startY: Int): Float {&#10;        val maxX = (gameField.width - sizePx).coerceAtLeast(0)&#10;        repeat(16) {&#10;            val candidate = Random.nextInt(0, maxX + 1)&#10;            if (!willOverlapStrict(candidate.toFloat(), startY.toFloat(), sizePx)) return candidate.toFloat()&#10;        }&#10;        var x = 0&#10;        while (x &lt;= maxX) {&#10;            if (!willOverlapStrict(x.toFloat(), startY.toFloat(), sizePx)) return x.toFloat()&#10;            x += (sizePx / 2).coerceAtLeast(1)&#10;        }&#10;        return Random.nextInt(0, maxX + 1).toFloat()&#10;    }&#10;&#10;    private fun animateCorrectBubbleAndRemove(bubble: View) {&#10;        bubble.isClickable = false&#10;        val rotate = ObjectAnimator.ofFloat(bubble, View.ROTATION, 0f, 360f)&#10;        val scaleX = ObjectAnimator.ofFloat(bubble, View.SCALE_X, 1f, 0f)&#10;        val scaleY = ObjectAnimator.ofFloat(bubble, View.SCALE_Y, 1f, 0f)&#10;        AnimatorSet().apply {&#10;            duration = 400&#10;            interpolator = AccelerateInterpolator()&#10;            playTogether(rotate, scaleX, scaleY)&#10;            addListener(object : AnimatorListenerAdapter() {&#10;                override fun onAnimationEnd(animation: Animator) { (bubble.parent as? ViewGroup)?.removeView(bubble) }&#10;            })&#10;            start()&#10;        }&#10;    }&#10;&#10;    private fun animateWrongBubble(bubble: View) {&#10;        val sx = ObjectAnimator.ofFloat(bubble, View.SCALE_X, 1f, 0.9f, 1.06f, 1f)&#10;        val sy = ObjectAnimator.ofFloat(bubble, View.SCALE_Y, 1f, 0.9f, 1.06f, 1f)&#10;        AnimatorSet().apply {&#10;            duration = 220&#10;            interpolator = AccelerateDecelerateInterpolator()&#10;            playTogether(sx, sy)&#10;            start()&#10;        }&#10;    }&#10;&#10;    private fun clearAllBubbles() {&#10;        bubbles.clear()&#10;        gameField.removeAllViews()&#10;    }&#10;&#10;    private fun speakTarget() {&#10;        tts?.speak(&quot;Лови цифру ${numberWords[targetDigit]}&quot;, TextToSpeech.QUEUE_FLUSH, null, &quot;catch_target&quot;)&#10;    }&#10;&#10;    private fun randomBubbleColor(): Int {&#10;        val palette = listOf(&#10;            Color.parseColor(&quot;#EF5350&quot;),&#10;            Color.parseColor(&quot;#AB47BC&quot;),&#10;            Color.parseColor(&quot;#5C6BC0&quot;),&#10;            Color.parseColor(&quot;#29B6F6&quot;),&#10;            Color.parseColor(&quot;#26A69A&quot;),&#10;            Color.parseColor(&quot;#66BB6A&quot;),&#10;            Color.parseColor(&quot;#FFCA28&quot;),&#10;            Color.parseColor(&quot;#FFA726&quot;),&#10;            Color.parseColor(&quot;#EC407A&quot;)&#10;        )&#10;        return palette[Random.nextInt(palette.size)]&#10;    }&#10;&#10;    private fun dp(value: Int): Int = TypedValue.applyDimension(&#10;        TypedValue.COMPLEX_UNIT_DIP, value.toFloat(), resources.displayMetrics&#10;    ).roundToInt()&#10;    private fun dpf(value: Float): Float = TypedValue.applyDimension(&#10;        TypedValue.COMPLEX_UNIT_DIP, value, resources.displayMetrics&#10;    )&#10;&#10;    private fun finishGame() {&#10;        val intent = android.content.Intent(this, BubbleCatchResultsActivity::class.java)&#10;        intent.putExtra(&quot;SCORE&quot;, score)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    private fun triggerGameOver() {&#10;        stopSpawning()&#10;        stopUpdateLoop()&#10;        clearAllBubbles()&#10;        val intent = android.content.Intent(this, BubbleCatchResultsActivity::class.java)&#10;        intent.putExtra(&quot;SCORE&quot;, score)&#10;        intent.putExtra(&quot;GAME_OVER&quot;, true)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        stopSpawning()&#10;        stopUpdateLoop()&#10;        levelTimer?.cancel()&#10;        stopGradientAnimation()&#10;        tts?.stop(); tts?.shutdown()&#10;    }&#10;&#10;    private fun createGlossyBubbleDrawable(baseColor: Int, sizePx: Int): Drawable {&#10;        return GlossyBalloonDrawable(this, baseColor)&#10;    }&#10;&#10;    // Кастомный Drawable: сохраняет форму шара с хвостиком (ic_balloon) и накладывает объёмный градиент и блик&#10;    private class GlossyBalloonDrawable(&#10;        private val context: android.content.Context,&#10;        private val baseColor: Int&#10;    ) : Drawable() {&#10;        private val rectF = RectF()&#10;        private val bodyPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { isDither = true }&#10;        private val highlightPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { isDither = true }&#10;        private val xferAtop = PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP)&#10;&#10;        override fun draw(canvas: android.graphics.Canvas) {&#10;            val b = bounds&#10;            if (b.isEmpty) return&#10;            rectF.set(b)&#10;&#10;            // Подложка: исходный balloon с хвостиком, затонированный базовым цветом&#10;            val balloon = ContextCompat.getDrawable(context, R.drawable.ic_balloon)?.mutate() ?: return&#10;            balloon.setTint(baseColor)&#10;            balloon.bounds = b&#10;&#10;            // Градиент тела (радиальный, свет сверху-слева)&#10;            val cx = b.left + b.width() * 0.35f&#10;            val cy = b.top + b.height() * 0.35f&#10;            val radius = max(b.width(), b.height()) * 0.75f&#10;            bodyPaint.shader = RadialGradient(&#10;                cx, cy, radius,&#10;                intArrayOf(lighten(baseColor, 0.28f), baseColor, darken(baseColor, 0.22f)),&#10;                floatArrayOf(0f, 0.65f, 1f),&#10;                Shader.TileMode.CLAMP&#10;            )&#10;&#10;            // Блик сверху (линейный градиент)&#10;            highlightPaint.shader = LinearGradient(&#10;                b.left.toFloat(), b.top.toFloat(), b.left.toFloat(), b.top + b.height() * 0.7f,&#10;                intArrayOf(Color.argb(160, 255, 255, 255), Color.argb(40, 255, 255, 255), Color.TRANSPARENT),&#10;                floatArrayOf(0f, 0.6f, 1f),&#10;                Shader.TileMode.CLAMP&#10;            )&#10;&#10;            // Слой: рисуем форму, затем накладываем градиенты по SRC_ATOP, чтобы сохранить силуэт (включая хвостик)&#10;            val save = canvas.saveLayer(rectF, null)&#10;            balloon.draw(canvas)&#10;&#10;            bodyPaint.xfermode = xferAtop&#10;            canvas.drawRect(rectF, bodyPaint)&#10;            bodyPaint.xfermode = null&#10;&#10;            highlightPaint.xfermode = xferAtop&#10;            canvas.drawRect(rectF, highlightPaint)&#10;            highlightPaint.xfermode = null&#10;&#10;            canvas.restoreToCount(save)&#10;        }&#10;&#10;        override fun setAlpha(alpha: Int) {}&#10;        override fun setColorFilter(colorFilter: android.graphics.ColorFilter?) {}&#10;        override fun getOpacity(): Int = android.graphics.PixelFormat.TRANSLUCENT&#10;&#10;        private fun lighten(color: Int, amount: Float): Int {&#10;            val a = Color.alpha(color)&#10;            val r = (Color.red(color) + (255 - Color.red(color)) * amount).toInt().coerceIn(0, 255)&#10;            val g = (Color.green(color) + (255 - Color.green(color)) * amount).toInt().coerceIn(0, 255)&#10;            val b = (Color.blue(color) + (255 - Color.blue(color)) * amount).toInt().coerceIn(0, 255)&#10;            return Color.argb(a, r, g, b)&#10;        }&#10;        private fun darken(color: Int, amount: Float): Int {&#10;            val a = Color.alpha(color)&#10;            val r = (Color.red(color) * (1f - amount)).toInt().coerceIn(0, 255)&#10;            val g = (Color.green(color) * (1f - amount)).toInt().coerceIn(0, 255)&#10;            val b = (Color.blue(color) * (1f - amount)).toInt().coerceIn(0, 255)&#10;            return Color.argb(a, r, g, b)&#10;        }&#10;    }&#10;&#10;    companion object { private const val LEVEL_DURATION_MS = 60_000L }&#10;}&#10;" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.animation.Animator&#10;import android.animation.AnimatorListenerAdapter&#10;import android.animation.AnimatorSet&#10;import android.animation.ObjectAnimator&#10;import android.content.pm.ActivityInfo&#10;import android.graphics.Color&#10;import android.graphics.Paint&#10;import android.graphics.LinearGradient&#10;import android.graphics.RadialGradient&#10;import android.graphics.Shader&#10;import android.graphics.PorterDuff&#10;import android.graphics.PorterDuffXfermode&#10;import android.graphics.RectF&#10;import android.graphics.drawable.Drawable&#10;import android.graphics.drawable.TransitionDrawable&#10;import android.os.Bundle&#10;import android.os.CountDownTimer&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.os.SystemClock&#10;import android.speech.tts.TextToSpeech&#10;import android.util.TypedValue&#10;import android.view.Gravity&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.view.animation.AccelerateDecelerateInterpolator&#10;import android.view.animation.AccelerateInterpolator&#10;import android.widget.FrameLayout&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import java.util.Locale&#10;import kotlin.math.abs&#10;import kotlin.math.floor&#10;import kotlin.math.hypot&#10;import kotlin.math.max&#10;import kotlin.math.min&#10;import kotlin.math.roundToInt&#10;import kotlin.random.Random&#10;&#10;class BubbleCatchActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private lateinit var gameField: FrameLayout&#10;    private lateinit var timerText: TextView&#10;    private lateinit var scoreText: TextView&#10;    private lateinit var targetText: TextView&#10;    private lateinit var progressBar: ProgressBar&#10;&#10;    private var score = 0&#10;    private val totalLevels = 10&#10;    private var currentLevel = 0&#10;    private val digitsOrder = (0..9).shuffled().toMutableList()&#10;    private var targetDigit = 0&#10;&#10;    private var tts: TextToSpeech? = null&#10;    private var levelTimer: CountDownTimer? = null&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var spawnRunnable: Runnable? = null&#10;    private val scheduledIncrements = mutableListOf&lt;Runnable&gt;()&#10;&#10;    // Градиентный фон&#10;    private lateinit var rootView: View&#10;    private val gradientHandler = Handler(Looper.getMainLooper())&#10;    private var gradientRunnable: Runnable? = null&#10;    private var gradientIndex = 0&#10;    private val gradientIds = intArrayOf(&#10;        R.drawable.child_gradient_yellow,&#10;        R.drawable.child_gradient_blue,&#10;        R.drawable.child_gradient_purple&#10;    )&#10;&#10;    // Параметры игры&#10;    private var currentConcurrentLimit: Int = 10&#10;    private val maxConcurrentCapBase: Int = 15&#10;&#10;    // Вероятность появления целевой цифры&#10;    private val targetDigitProbability = 0.35f&#10;&#10;    // Словесные названия чисел для TTS&#10;    private val numberWords = arrayOf(&#10;        &quot;ноль&quot;, &quot;один&quot;, &quot;два&quot;, &quot;три&quot;, &quot;четыре&quot;, &quot;пять&quot;,&#10;        &quot;шесть&quot;, &quot;семь&quot;, &quot;восемь&quot;, &quot;девять&quot;&#10;    )&#10;&#10;    // Короткие фразы для озвучивания событий&#10;    private val correctHitPhrases = listOf(&#10;        &quot;Отлично!&quot;, &quot;Верно!&quot;, &quot;Правильно!&quot;, &quot;Так держать!&quot;, &quot;Молодец!&quot;&#10;    )&#10;    private val wrongHitPhrases = listOf(&#10;        &quot;Не та цифра.&quot;, &quot;Промах.&quot;, &quot;Неверно.&quot;, &quot;Попробуй ещё.&quot;, &quot;Это не она.&quot;&#10;    )&#10;    private val missedPhrases = listOf(&#10;        &quot;Ты упустил нужный шарик.&quot;, &quot;Нужный шарик улетел.&quot;, &quot;Цель улетела.&quot;, &quot;Будь внимательнее.&quot;&#10;    )&#10;&#10;    // Список активных шариков и апдейт-цикл&#10;    private data class Bubble(&#10;        val view: View,&#10;        var x: Float,&#10;        var y: Float,&#10;        var vx: Float,&#10;        var vy: Float,&#10;        val radius: Float,&#10;        val value: Int,&#10;        var clickable: Boolean = true&#10;    )&#10;    private val bubbles = mutableListOf&lt;Bubble&gt;()&#10;    private var updateRunnable: Runnable? = null&#10;    private var lastUpdateMs: Long = 0L&#10;&#10;    // Интервал спавна (уменьшается каждые 10 секунд уровня)&#10;    private val baseSpawnIntervalMs = 900L&#10;    private var currentSpawnIntervalMs = baseSpawnIntervalMs&#10;    private val minSpawnIntervalMs = 300L&#10;    private val scheduledSpawnReductions = mutableListOf&lt;Runnable&gt;()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_bubble_catch)&#10;        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT&#10;&#10;        rootView = findViewById(R.id.main)&#10;        ViewCompat.setOnApplyWindowInsetsListener(rootView) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;        startGradientAnimation()&#10;&#10;        tts = TextToSpeech(this, this)&#10;        setupViews()&#10;        setupBackButton()&#10;    }&#10;&#10;    // Градиент фона&#10;    private fun startGradientAnimation() {&#10;        stopGradientAnimation()&#10;        fun nextIndex(i: Int) = (i + 1) % gradientIds.size&#10;        gradientRunnable = object : Runnable {&#10;            override fun run() {&#10;                val curr = ContextCompat.getDrawable(this@BubbleCatchActivity, gradientIds[gradientIndex])&#10;                val next = ContextCompat.getDrawable(this@BubbleCatchActivity, gradientIds[nextIndex(gradientIndex)])&#10;                if (curr != null &amp;&amp; next != null) {&#10;                    val td = TransitionDrawable(arrayOf(curr, next))&#10;                    rootView.background = td&#10;                    td.isCrossFadeEnabled = true&#10;                    td.startTransition(6000)&#10;                }&#10;                gradientIndex = nextIndex(gradientIndex)&#10;                gradientHandler.postDelayed(this, 6000L)&#10;            }&#10;        }&#10;        gradientHandler.post(gradientRunnable!!)&#10;    }&#10;    private fun stopGradientAnimation() {&#10;        gradientRunnable?.let { gradientHandler.removeCallbacks(it) }&#10;        gradientRunnable = null&#10;    }&#10;&#10;    private fun setupViews() {&#10;        gameField = findViewById(R.id.gameField)&#10;        timerText = findViewById(R.id.timerText)&#10;        scoreText = findViewById(R.id.scoreText)&#10;        targetText = findViewById(R.id.targetText)&#10;        progressBar = findViewById(R.id.levelProgressBar)&#10;&#10;        scoreText.text = score.toString()&#10;        progressBar.max = LEVEL_DURATION_MS.toInt()&#10;        progressBar.progress = LEVEL_DURATION_MS.toInt()&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.speakerButton).setOnClickListener { speakTarget() }&#10;    }&#10;&#10;    private fun setupBackButton() {&#10;        findViewById&lt;ImageView&gt;(R.id.backButton).setOnClickListener { finish() }&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            tts?.language = Locale.forLanguageTag(&quot;ru-RU&quot;)&#10;            startNextLevel()&#10;        }&#10;    }&#10;&#10;    private fun startNextLevel() {&#10;        if (currentLevel &gt;= totalLevels) { finishGame(); return }&#10;&#10;        // Настройка цели уровня&#10;        targetDigit = digitsOrder[currentLevel]&#10;        targetText.text = targetDigit.toString()&#10;        speakTarget()&#10;&#10;        // Таймер уровня&#10;        levelTimer?.cancel()&#10;        levelTimer = object : CountDownTimer(LEVEL_DURATION_MS, 100L) {&#10;            override fun onTick(millisUntilFinished: Long) { updateTimerUi(millisUntilFinished) }&#10;            override fun onFinish() {&#10;                updateTimerUi(0)&#10;                stopSpawning()&#10;                clearAllBubbles()&#10;                currentLevel++&#10;                gameField.postDelayed({ startNextLevel() }, 600)&#10;            }&#10;        }.start()&#10;&#10;        // Динамика одновременных шариков на уровне: стартуем с 10&#10;        currentConcurrentLimit = 10&#10;        scheduleConcurrencyIncrements()&#10;&#10;        // Сброс и планирование уменьшения интервала спавна каждые 3 секунды&#10;        currentSpawnIntervalMs = baseSpawnIntervalMs&#10;        scheduleSpawnIntervalReductions()&#10;&#10;        // Старт апдейт-цикла и спавна&#10;        startUpdateLoop()&#10;        startSpawning()&#10;    }&#10;&#10;    private fun updateTimerUi(millisUntilFinished: Long) {&#10;        val seconds = (millisUntilFinished / 1000).toInt()&#10;        timerText.text = String.format(Locale.getDefault(), &quot;%02d:%02d&quot;, seconds / 60, seconds % 60)&#10;        progressBar.progress = millisUntilFinished.toInt()&#10;    }&#10;&#10;    private fun scheduleConcurrencyIncrements() {&#10;        cancelScheduledIncrements()&#10;        val stepMs = 10_000L&#10;        var delay = stepMs&#10;        repeat(10) {&#10;            val r = Runnable { currentConcurrentLimit = min(currentConcurrentLimit + 1, maxConcurrentCapBase) }&#10;            scheduledIncrements += r&#10;            handler.postDelayed(r, delay)&#10;            delay += stepMs&#10;        }&#10;    }&#10;    private fun cancelScheduledIncrements() {&#10;        scheduledIncrements.forEach { handler.removeCallbacks(it) }&#10;        scheduledIncrements.clear()&#10;    }&#10;&#10;    private fun scheduleSpawnIntervalReductions() {&#10;        cancelScheduledSpawnReductions()&#10;        var delay = 3_000L&#10;        while (delay &lt; LEVEL_DURATION_MS) {&#10;            val r = Runnable {&#10;                currentSpawnIntervalMs = (currentSpawnIntervalMs - 100L).coerceAtLeast(minSpawnIntervalMs)&#10;            }&#10;            scheduledSpawnReductions += r&#10;            handler.postDelayed(r, delay)&#10;            delay += 3_000L&#10;        }&#10;    }&#10;    private fun cancelScheduledSpawnReductions() {&#10;        if (scheduledSpawnReductions.isNotEmpty()) {&#10;            scheduledSpawnReductions.forEach { handler.removeCallbacks(it) }&#10;            scheduledSpawnReductions.clear()&#10;        }&#10;    }&#10;&#10;    private fun startSpawning() {&#10;        stopSpawning()&#10;        spawnRunnable = object : Runnable {&#10;            override fun run() {&#10;                val active = bubbles.size&#10;                if (active &lt; currentConcurrentLimit) {&#10;                    val deficit = (currentConcurrentLimit - active).coerceAtLeast(0)&#10;                    if (deficit &gt; 0) spawnBubbles(deficit)&#10;                }&#10;                handler.postDelayed(this, currentSpawnIntervalMs)&#10;            }&#10;        }&#10;        handler.post(spawnRunnable!!)&#10;    }&#10;    private fun stopSpawning() {&#10;        spawnRunnable?.let { handler.removeCallbacks(it) }&#10;        spawnRunnable = null&#10;        cancelScheduledIncrements()&#10;        cancelScheduledSpawnReductions()&#10;    }&#10;&#10;    private fun startUpdateLoop() {&#10;        if (updateRunnable != null) return&#10;        lastUpdateMs = SystemClock.uptimeMillis()&#10;        updateRunnable = object : Runnable {&#10;            override fun run() {&#10;                val now = SystemClock.uptimeMillis()&#10;                val dt = ((now - lastUpdateMs).coerceAtMost(50)).toFloat() / 1000f&#10;                lastUpdateMs = now&#10;                stepPhysics(dt)&#10;                handler.postDelayed(this, 16L)&#10;            }&#10;        }&#10;        handler.post(updateRunnable!!)&#10;    }&#10;    private fun stopUpdateLoop() { updateRunnable?.let { handler.removeCallbacks(it) }; updateRunnable = null }&#10;&#10;    private fun stepPhysics(dt: Float) {&#10;        if (gameField.width == 0 || gameField.height == 0) return&#10;        val width = gameField.width&#10;&#10;        // Обновление позиций&#10;        for (b in bubbles) {&#10;            b.x += b.vx * dt&#10;            b.y += b.vy * dt&#10;            // столкновения со стенами (по X), небольшое затухание&#10;            if (b.x &lt; 0f) { b.x = 0f; b.vx = -b.vx * 0.9f }&#10;            val maxX = (width - b.radius * 2)&#10;            if (b.x &gt; maxX) { b.x = maxX; b.vx = -b.vx * 0.9f }&#10;        }&#10;&#10;        // Столкновения между шарами (упругие, почти)&#10;        for (i in 0 until bubbles.size) {&#10;            val a = bubbles[i]&#10;            for (j in i + 1 until bubbles.size) {&#10;                val c = bubbles[j]&#10;                val ax = a.x + a.radius&#10;                val ay = a.y + a.radius&#10;                val cx = c.x + c.radius&#10;                val cy = c.y + c.radius&#10;                val dx = cx - ax&#10;                val dy = cy - ay&#10;                val dist = hypot(dx, dy)&#10;                val minDist = a.radius + c.radius + dpf(6f) // небольшой зазор&#10;                if (dist &lt; minDist &amp;&amp; dist &gt; 0f) {&#10;                    // Раздвигаем на половины перекрытия&#10;                    val overlap = (minDist - dist)&#10;                    val nx = dx / dist&#10;                    val ny = dy / dist&#10;                    a.x -= nx * (overlap / 2f)&#10;                    a.y -= ny * (overlap / 2f)&#10;                    c.x += nx * (overlap / 2f)&#10;                    c.y += ny * (overlap / 2f)&#10;                    // Импульс по ��ормали (равные массы)&#10;                    val rvx = c.vx - a.vx&#10;                    val rvy = c.vy - a.vy&#10;                    val vn = rvx * nx + rvy * ny&#10;                    if (vn &lt; 0f) {&#10;                        val e = 0.8f // коэффициент реституции&#10;                        val jImp = -(1 + e) * vn / 2f&#10;                        val jx = jImp * nx&#10;                        val jy = jImp * ny&#10;                        a.vx -= jx; a.vy -= jy&#10;                        c.vx += jx; c.vy += jy&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Удаление улетевших и обновление view&#10;        val iterator = bubbles.iterator()&#10;        while (iterator.hasNext()) {&#10;            val b = iterator.next()&#10;            if (b.y + b.radius * 2 &lt; 0) {&#10;                if (b.clickable &amp;&amp; b.value == targetDigit) {&#10;                    score -= 1&#10;                    if (score &lt; 0) {&#10;                        score = 0&#10;                        scoreText.text = &quot;0&quot;&#10;                        tts?.speak(missedPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;missed&quot;)&#10;                        triggerGameOver()&#10;                        return&#10;                    } else {&#10;                        scoreText.text = score.toString()&#10;                        tts?.speak(missedPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;missed&quot;)&#10;                    }&#10;                }&#10;                (b.view.parent as? ViewGroup)?.removeView(b.view)&#10;                iterator.remove()&#10;                continue&#10;            }&#10;            b.view.x = b.x&#10;            b.view.y = b.y&#10;        }&#10;    }&#10;&#10;    private fun spawnBubbles(count: Int) {&#10;        val sizes = IntArray(count) { dp(Random.nextInt(84, 126)) }&#10;        gameField.post {&#10;            val startYBase = gameField.height&#10;&#10;            // Колонки по ширине&#10;            val maxSizePx = dp(126)&#10;            val laneGap = dp(12) // увеличенный зазор&#10;            val laneWidth = max(maxSizePx + laneGap, 1)&#10;            val lanes = floor(gameField.width.toFloat() / laneWidth).toInt().coerceAtLeast(1)&#10;            val centers = FloatArray(lanes) { i -&gt; (laneWidth / 2f) + i * laneWidth }&#10;&#10;            repeat(count) { idx -&gt;&#10;                val size = sizes[idx]&#10;                val startY = startYBase + size&#10;                val endY = -size&#10;&#10;                // Подбор X: по свободным колонкам, затем fallback&#10;                val order = (0 until lanes).shuffled()&#10;                var chosenX: Float? = null&#10;                for (li in order) {&#10;                    val cx = centers[li]&#10;                    val xCand = (cx - size / 2f).coerceIn(0f, (gameField.width - size).toFloat())&#10;                    if (!willOverlapStrict(xCand, startY.toFloat(), size)) { chosenX = xCand; break }&#10;                }&#10;                val x = chosenX ?: findFreeX(size, startY)&#10;&#10;                // Создание view и модели&#10;                val bubbleView = FrameLayout(this).apply {&#10;                    layoutParams = FrameLayout.LayoutParams(size, size)&#10;                    this.x = x&#10;                    this.y = startY.toFloat()&#10;                    background = createGlossyBubbleDrawable(randomBubbleColor(), size)&#10;                }&#10;                val value = if (Random.nextFloat() &lt; targetDigitProbability) targetDigit else {&#10;                    var v: Int; do { v = Random.nextInt(0, 10) } while (v == targetDigit); v&#10;                }&#10;                val text = TextView(this).apply {&#10;                    layoutParams = FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT)&#10;                    setTextSize(TypedValue.COMPLEX_UNIT_SP, 22f)&#10;                    setTextColor(Color.WHITE)&#10;                    gravity = Gravity.CENTER&#10;                    setShadowLayer(4f, 0f, 2f, Color.parseColor(&quot;#66000000&quot;))&#10;                    text = value.toString()&#10;                }&#10;                bubbleView.addView(text)&#10;&#10;                val radius = size / 2f&#10;                // Базовая скорость по вертикали (px/с) ~ путь / 6с, с разбросом&#10;                val travelDist = (startY - endY).toFloat()&#10;                val baseVy = -travelDist / 6f&#10;                val vy = baseVy * Random.nextDouble(0.85, 1.25).toFloat()&#10;                val vx = dp(8) * Random.nextDouble(-0.6, 0.6).toFloat() // небольшой боковой дрейф&#10;&#10;                val model = Bubble(bubbleView, x, startY.toFloat(), vx, vy, radius, value, true)&#10;                bubbleView.isClickable = true&#10;                bubbleView.setOnClickListener {&#10;                    if (!model.clickable) return@setOnClickListener&#10;                    if (model.value == targetDigit) {&#10;                        score += 2&#10;                        scoreText.text = score.toString()&#10;                        tts?.speak(correctHitPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;hit_ok&quot;)&#10;                        model.clickable = false&#10;                        bubbles.remove(model)&#10;                        animateCorrectBubbleAndRemove(bubbleView)&#10;                    } else {&#10;                        score -= 1&#10;                        if (score &lt; 0) {&#10;                            score = 0&#10;                            scoreText.text = &quot;0&quot;&#10;                            bubbleView.performHapticFeedback(android.view.HapticFeedbackConstants.KEYBOARD_TAP)&#10;                            animateWrongBubble(bubbleView)&#10;                            tts?.speak(wrongHitPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;hit_bad&quot;)&#10;                            triggerGameOver()&#10;                        } else {&#10;                            scoreText.text = score.toString()&#10;                            bubbleView.performHapticFeedback(android.view.HapticFeedbackConstants.KEYBOARD_TAP)&#10;                            animateWrongBubble(bubbleView)&#10;                            tts?.speak(wrongHitPhrases.random(), TextToSpeech.QUEUE_ADD, null, &quot;hit_bad&quot;)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                gameField.addView(bubbleView)&#10;                bubbles.add(model)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Строгая проверка перекрытий: радиусы + гориз./верт. з��зоры&#10;    private fun willOverlapStrict(xTopLeft: Float, yTopLeft: Float, size: Int): Boolean {&#10;        val cx = xTopLeft + size / 2f&#10;        val cy = yTopLeft + size / 2f&#10;        val r = size / 2f&#10;        val gap = dpf(12f)&#10;        val minH = dpf(10f)&#10;        val minV = dpf(10f)&#10;        for (b in bubbles) {&#10;            val bx = b.x + b.radius&#10;            val by = b.y + b.radius&#10;            val dx = abs(cx - bx)&#10;            val dy = abs(cy - by)&#10;            val centerDist = hypot(dx, dy)&#10;            val radiusSum = r + b.radius + gap&#10;            if (centerDist &lt; radiusSum) return true&#10;            if (dx &lt; minH &amp;&amp; dy &lt; minV) return true&#10;        }&#10;        return false&#10;    }&#10;&#10;    private fun findFreeX(sizePx: Int, startY: Int): Float {&#10;        val maxX = (gameField.width - sizePx).coerceAtLeast(0)&#10;        repeat(16) {&#10;            val candidate = Random.nextInt(0, maxX + 1)&#10;            if (!willOverlapStrict(candidate.toFloat(), startY.toFloat(), sizePx)) return candidate.toFloat()&#10;        }&#10;        var x = 0&#10;        while (x &lt;= maxX) {&#10;            if (!willOverlapStrict(x.toFloat(), startY.toFloat(), sizePx)) return x.toFloat()&#10;            x += (sizePx / 2).coerceAtLeast(1)&#10;        }&#10;        return Random.nextInt(0, maxX + 1).toFloat()&#10;    }&#10;&#10;    private fun animateCorrectBubbleAndRemove(bubble: View) {&#10;        bubble.isClickable = false&#10;        val rotate = ObjectAnimator.ofFloat(bubble, View.ROTATION, 0f, 360f)&#10;        val scaleX = ObjectAnimator.ofFloat(bubble, View.SCALE_X, 1f, 0f)&#10;        val scaleY = ObjectAnimator.ofFloat(bubble, View.SCALE_Y, 1f, 0f)&#10;        AnimatorSet().apply {&#10;            duration = 400&#10;            interpolator = AccelerateInterpolator()&#10;            playTogether(rotate, scaleX, scaleY)&#10;            addListener(object : AnimatorListenerAdapter() {&#10;                override fun onAnimationEnd(animation: Animator) { (bubble.parent as? ViewGroup)?.removeView(bubble) }&#10;            })&#10;            start()&#10;        }&#10;    }&#10;&#10;    private fun animateWrongBubble(bubble: View) {&#10;        val sx = ObjectAnimator.ofFloat(bubble, View.SCALE_X, 1f, 0.9f, 1.06f, 1f)&#10;        val sy = ObjectAnimator.ofFloat(bubble, View.SCALE_Y, 1f, 0.9f, 1.06f, 1f)&#10;        AnimatorSet().apply {&#10;            duration = 220&#10;            interpolator = AccelerateDecelerateInterpolator()&#10;            playTogether(sx, sy)&#10;            start()&#10;        }&#10;    }&#10;&#10;    private fun clearAllBubbles() {&#10;        bubbles.clear()&#10;        gameField.removeAllViews()&#10;    }&#10;&#10;    private fun speakTarget() {&#10;        tts?.speak(&quot;Лови цифру ${numberWords[targetDigit]}&quot;, TextToSpeech.QUEUE_FLUSH, null, &quot;catch_target&quot;)&#10;    }&#10;&#10;    private fun randomBubbleColor(): Int {&#10;        val palette = listOf(&#10;            Color.parseColor(&quot;#EF5350&quot;),&#10;            Color.parseColor(&quot;#AB47BC&quot;),&#10;            Color.parseColor(&quot;#5C6BC0&quot;),&#10;            Color.parseColor(&quot;#29B6F6&quot;),&#10;            Color.parseColor(&quot;#26A69A&quot;),&#10;            Color.parseColor(&quot;#66BB6A&quot;),&#10;            Color.parseColor(&quot;#FFCA28&quot;),&#10;            Color.parseColor(&quot;#FFA726&quot;),&#10;            Color.parseColor(&quot;#EC407A&quot;)&#10;        )&#10;        return palette[Random.nextInt(palette.size)]&#10;    }&#10;&#10;    private fun dp(value: Int): Int = TypedValue.applyDimension(&#10;        TypedValue.COMPLEX_UNIT_DIP, value.toFloat(), resources.displayMetrics&#10;    ).roundToInt()&#10;    private fun dpf(value: Float): Float = TypedValue.applyDimension(&#10;        TypedValue.COMPLEX_UNIT_DIP, value, resources.displayMetrics&#10;    )&#10;&#10;    private fun finishGame() {&#10;        val intent = android.content.Intent(this, BubbleCatchResultsActivity::class.java)&#10;        intent.putExtra(&quot;SCORE&quot;, score)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    private fun triggerGameOver() {&#10;        stopSpawning()&#10;        stopUpdateLoop()&#10;        clearAllBubbles()&#10;        val intent = android.content.Intent(this, BubbleCatchResultsActivity::class.java)&#10;        intent.putExtra(&quot;SCORE&quot;, score)&#10;        intent.putExtra(&quot;GAME_OVER&quot;, true)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        stopSpawning()&#10;        stopUpdateLoop()&#10;        levelTimer?.cancel()&#10;        stopGradientAnimation()&#10;        tts?.stop(); tts?.shutdown()&#10;    }&#10;&#10;    private fun createGlossyBubbleDrawable(baseColor: Int, sizePx: Int): Drawable {&#10;        return GlossyBalloonDrawable(this, baseColor)&#10;    }&#10;&#10;    // Кастомный Drawable: сохраняет форму шара с хвостиком (ic_balloon) и накладывает объёмный градиент и блик&#10;    private class GlossyBalloonDrawable(&#10;        private val context: android.content.Context,&#10;        private val baseColor: Int&#10;    ) : Drawable() {&#10;        private val rectF = RectF()&#10;        private val bodyPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { isDither = true }&#10;        private val highlightPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply { isDither = true }&#10;        private val xferAtop = PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP)&#10;&#10;        override fun draw(canvas: android.graphics.Canvas) {&#10;            val b = bounds&#10;            if (b.isEmpty) return&#10;            rectF.set(b)&#10;&#10;            // Подложка: исходный balloon с хвостиком, затонированный базовым цветом&#10;            val balloon = ContextCompat.getDrawable(context, R.drawable.ic_balloon)?.mutate() ?: return&#10;            balloon.setTint(baseColor)&#10;            balloon.bounds = b&#10;&#10;            // Градиент тела (радиальный, свет сверху-слева)&#10;            val cx = b.left + b.width() * 0.35f&#10;            val cy = b.top + b.height() * 0.35f&#10;            val radius = max(b.width(), b.height()) * 0.75f&#10;            bodyPaint.shader = RadialGradient(&#10;                cx, cy, radius,&#10;                intArrayOf(lighten(baseColor, 0.28f), baseColor, darken(baseColor, 0.22f)),&#10;                floatArrayOf(0f, 0.65f, 1f),&#10;                Shader.TileMode.CLAMP&#10;            )&#10;&#10;            // Блик сверху (линейный градиент)&#10;            highlightPaint.shader = LinearGradient(&#10;                b.left.toFloat(), b.top.toFloat(), b.left.toFloat(), b.top + b.height() * 0.7f,&#10;                intArrayOf(Color.argb(160, 255, 255, 255), Color.argb(40, 255, 255, 255), Color.TRANSPARENT),&#10;                floatArrayOf(0f, 0.6f, 1f),&#10;                Shader.TileMode.CLAMP&#10;            )&#10;&#10;            // Слой: рисуем форму, затем накладываем градиенты по SRC_ATOP, чтобы сохранить силуэт (включая хвостик)&#10;            val save = canvas.saveLayer(rectF, null)&#10;            balloon.draw(canvas)&#10;&#10;            bodyPaint.xfermode = xferAtop&#10;            canvas.drawRect(rectF, bodyPaint)&#10;            bodyPaint.xfermode = null&#10;&#10;            highlightPaint.xfermode = xferAtop&#10;            canvas.drawRect(rectF, highlightPaint)&#10;            highlightPaint.xfermode = null&#10;&#10;            canvas.restoreToCount(save)&#10;        }&#10;&#10;        override fun setAlpha(alpha: Int) {}&#10;        override fun setColorFilter(colorFilter: android.graphics.ColorFilter?) {}&#10;        override fun getOpacity(): Int = android.graphics.PixelFormat.TRANSLUCENT&#10;&#10;        private fun lighten(color: Int, amount: Float): Int {&#10;            val a = Color.alpha(color)&#10;            val r = (Color.red(color) + (255 - Color.red(color)) * amount).toInt().coerceIn(0, 255)&#10;            val g = (Color.green(color) + (255 - Color.green(color)) * amount).toInt().coerceIn(0, 255)&#10;            val b = (Color.blue(color) + (255 - Color.blue(color)) * amount).toInt().coerceIn(0, 255)&#10;            return Color.argb(a, r, g, b)&#10;        }&#10;        private fun darken(color: Int, amount: Float): Int {&#10;            val a = Color.alpha(color)&#10;            val r = (Color.red(color) * (1f - amount)).toInt().coerceIn(0, 255)&#10;            val g = (Color.green(color) * (1f - amount)).toInt().coerceIn(0, 255)&#10;            val b = (Color.blue(color) * (1f - amount)).toInt().coerceIn(0, 255)&#10;            return Color.argb(a, r, g, b)&#10;        }&#10;    }&#10;&#10;    companion object { private const val LEVEL_DURATION_MS = 60_000L }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/KidsComparisonActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/KidsComparisonActivity.kt" />
              <option name="originalContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.animation.AnimatorSet&#10;import android.animation.ObjectAnimator&#10;import android.content.Intent&#10;import android.content.pm.ActivityInfo&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.view.View&#10;import android.view.accessibility.AccessibilityEvent&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import com.timursarsembayev.danabalanumbers.R&#10;import java.util.Locale&#10;import kotlin.random.Random&#10;&#10;class KidsComparisonActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var tts: TextToSpeech? = null&#10;    private var currentQuestion = 0&#10;    private var score = 0&#10;    private var totalCorrectAnswers = 0&#10;    private val totalQuestions = 20&#10;&#10;    // UI&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var questionText: TextView&#10;    private lateinit var hintText: TextView&#10;&#10;    private lateinit var leftCard: CardView&#10;    private lateinit var rightCard: CardView&#10;&#10;    private lateinit var leftPersonDisplay: TextView&#10;    private lateinit var rightPersonDisplay: TextView&#10;    private lateinit var leftObjectsDisplay: TextView&#10;    private lateinit var rightObjectsDisplay: TextView&#10;    private lateinit var centerSymbol: TextView&#10;    private lateinit var leftNumberDisplay: TextView&#10;    private lateinit var rightNumberDisplay: TextView&#10;&#10;    private lateinit var nextButton: Button&#10;    private lateinit var equalButton: Button&#10;&#10;    // Logic&#10;    private var leftCount = 0&#10;    private var rightCount = 0&#10;    private var currentObjectEmoji = &quot;&quot;&#10;    private var leftIsBoy = true // the other will be girl&#10;&#10;    // Словарь названий предметов (род. падеж множественного числа)&#10;    private val emojiNames: Map&lt;String, String&gt; = mapOf(&#10;        &quot;&quot; to &quot;яблок&quot;,&#10;        &quot;&quot; to &quot;бананов&quot;,&#10;        &quot;&quot; to &quot;виноградин&quot;,&#10;        &quot;&quot; to &quot;клубничек&quot;,&#10;        &quot;&quot; to &quot;вишенок&quot;,&#10;        &quot;&quot; to &quot;морковок&quot;,&#10;        &quot;&quot; to &quot;огурцов&quot;,&#10;        &quot;&quot; to &quot;помидоров&quot;,&#10;        &quot;⚽&quot; to &quot;мячей&quot;,&#10;        &quot;&quot; to &quot;мячей&quot;,&#10;        &quot;&quot; to &quot;мячиков&quot;,&#10;        &quot;&quot; to &quot;мячей&quot;,&#10;        &quot;&quot; to &quot;шариков&quot;,&#10;        &quot;&quot; to &quot;подарков&quot;,&#10;        &quot;&quot; to &quot;тортиков&quot;,&#10;        &quot;&quot; to &quot;красок&quot;,&#10;        &quot;&quot; to &quot;звёзд&quot;,&#10;        &quot;⭐&quot; to &quot;звёздочек&quot;,&#10;        &quot;✨&quot; to &quot;искорок&quot;,&#10;        &quot;&quot; to &quot;цветков&quot;,&#10;        &quot;&quot; to &quot;цветков&quot;,&#10;        &quot;&quot; to &quot;ромашек&quot;,&#10;        &quot;&quot; to &quot;подсолнухов&quot;,&#10;        &quot;&quot; to &quot;роз&quot;&#10;    )&#10;&#10;    private val confirmationEndings = listOf(&#10;        &quot;Ты уверен?&quot;,&#10;        &quot;Верно?&quot;,&#10;        &quot;Как думаешь, это правильно?&quot;,&#10;        &quot;Проверь внимательно!&quot;,&#10;        &quot;Давай проверим!&quot;&#10;    )&#10;&#10;    // Эмодзи предметов для выбора&#10;    private val objectEmojis = arrayOf(&#10;        &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,&#10;        &quot;⚽&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,&#10;        &quot;&quot;, &quot;⭐&quot;, &quot;✨&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;&#10;    )&#10;&#10;    // Текущее выделение пользователя&#10;    private enum class Selected { NONE, LEFT, RIGHT }&#10;    private var selected: Selected = Selected.NONE&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        // Keep landscape like original comparison&#10;        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE&#10;        setContentView(R.layout.activity_kids_comparison)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        tts = TextToSpeech(this, this)&#10;        initViews()&#10;        setupClicks()&#10;        generateNewQuestion()&#10;    }&#10;&#10;    private fun initViews() {&#10;        progressBar = findViewById(R.id.progressBar)&#10;        questionText = findViewById(R.id.questionText)&#10;        hintText = findViewById(R.id.hintText)&#10;&#10;        leftCard = findViewById(R.id.leftCard)&#10;        rightCard = findViewById(R.id.rightCard)&#10;&#10;        leftPersonDisplay = findViewById(R.id.leftPersonDisplay)&#10;        rightPersonDisplay = findViewById(R.id.rightPersonDisplay)&#10;        leftObjectsDisplay = findViewById(R.id.leftObjectsDisplay)&#10;        rightObjectsDisplay = findViewById(R.id.rightObjectsDisplay)&#10;        leftNumberDisplay = findViewById(R.id.leftNumberDisplay)&#10;        rightNumberDisplay = findViewById(R.id.rightNumberDisplay)&#10;&#10;        centerSymbol = findViewById(R.id.centerSymbol)&#10;        nextButton = findViewById(R.id.nextButton)&#10;        equalButton = findViewById(R.id.equalButton)&#10;&#10;        // back button&#10;        findViewById&lt;ImageButton&gt;(R.id.backButton).setOnClickListener { finish() }&#10;&#10;        nextButton.visibility = View.GONE&#10;    }&#10;&#10;    private fun setupClicks() {&#10;        leftCard.setOnClickListener { onSideSelected(isLeft = true) }&#10;        rightCard.setOnClickListener { onSideSelected(isLeft = false) }&#10;        equalButton.setOnClickListener { onEqualSelected() }&#10;&#10;        nextButton.setOnClickListener { nextQuestion() }&#10;    }&#10;&#10;    private fun onSideSelected(isLeft: Boolean) {&#10;        if (nextButton.visibility == View.VISIBLE) return&#10;&#10;        // Устанавливаем выбранную сторону и обновляем UI выделения&#10;        selected = if (isLeft) Selected.LEFT else Selected.RIGHT&#10;        updateSelectionUI()&#10;&#10;        // Озвучиваем выбранный вариант с корректным определением пола&#10;        speakSelectionQuestion(isLeft)&#10;&#10;        // Показать в центре символ выбора пользователя: слева выбирают «больше», значит '&gt;'&#10;        showCenterSymbol(if (isLeft) &quot;&gt;&quot; else &quot;&lt;&quot;)&#10;&#10;        val correctLeft = leftCount &gt; rightCount&#10;        val correctRight = rightCount &gt; leftCount&#10;        val isCorrect = (isLeft &amp;&amp; correctLeft) || (!isLeft &amp;&amp; correctRight)&#10;&#10;        if (isCorrect) {&#10;            score += 100&#10;            totalCorrectAnswers++&#10;            hintText.text = &quot;Отлично!&quot;&#10;            hintText.setTextColor(ContextCompat.getColor(this, android.R.color.holo_green_dark))&#10;            centerSymbol.setBackgroundResource(R.drawable.number_input_correct)&#10;            animatePulse(centerSymbol)&#10;            nextButton.visibility = View.VISIBLE&#10;        } else {&#10;            hintText.text = &quot;Попробуй ещё раз&quot;&#10;            hintText.setTextColor(ContextCompat.getColor(this, android.R.color.holo_red_dark))&#10;            // временная красная подсветка на нажатой карточке&#10;            val card = if (isLeft) leftCard else rightCard&#10;            val originalColor = (if (selected == (if (isLeft) Selected.LEFT else Selected.RIGHT))&#10;                ContextCompat.getColor(this, android.R.color.holo_blue_light)&#10;            else ContextCompat.getColor(this, android.R.color.white))&#10;            card.setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.holo_red_light))&#10;            card.postDelayed({ updateSelectionUI() }, 500)&#10;            centerSymbol.setBackgroundResource(R.drawable.number_drop_zone)&#10;            animateShake(card)&#10;        }&#10;    }&#10;&#10;    private fun onEqualSelected() {&#10;        if (nextButton.visibility == View.VISIBLE) return&#10;        // Сброс выделения при выборе равенства&#10;        selected = Selected.NONE&#10;        updateSelectionUI()&#10;&#10;        // Озвучка равенства&#10;        val item = getItemNamePlural()&#10;        val ending = confirmationEndings.random()&#10;        val phrase = &quot;Поровну ${item}? $ending&quot;&#10;        tts?.speak(phrase, TextToSpeech.QUEUE_FLUSH, null, null)&#10;&#10;        // Показать символ '=' в центре&#10;        showCenterSymbol(&quot;=&quot;)&#10;&#10;        val isCorrect = leftCount == rightCount&#10;        if (isCorrect) {&#10;            score += 100&#10;            totalCorrectAnswers++&#10;            hintText.text = &quot;Верно!&quot;&#10;            hintText.setTextColor(ContextCompat.getColor(this, android.R.color.holo_green_dark))&#10;            centerSymbol.setBackgroundResource(R.drawable.number_input_correct)&#10;            animatePulse(centerSymbol)&#10;            nextButton.visibility = View.VISIBLE&#10;        } else {&#10;            hintText.text = &quot;Попробуй ещё раз&quot;&#10;            hintText.setTextColor(ContextCompat.getColor(this, android.R.color.holo_red_dark))&#10;            centerSymbol.setBackgroundResource(R.drawable.number_input_incorrect)&#10;            centerSymbol.postDelayed({ centerSymbol.setBackgroundResource(R.drawable.number_drop_zone) }, 500)&#10;            animateShake(centerSymbol)&#10;        }&#10;    }&#10;&#10;    private fun showCenterSymbol(symbol: String) { centerSymbol.text = symbol }&#10;&#10;    // Пульсация (успех)&#10;    private fun animatePulse(view: View) {&#10;        val sx = ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1f, 1.15f, 1f)&#10;        val sy = ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 1f, 1.15f, 1f)&#10;        AnimatorSet().apply {&#10;            playTogether(sx, sy)&#10;            duration = 300&#10;            start()&#10;        }&#10;    }&#10;&#10;    // Тряска (ошибка)&#10;    private fun animateShake(view: View) {&#10;        val anim = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 0f, -10f, 10f, -5f, 5f, 0f)&#10;        anim.duration = 500&#10;        anim.start()&#10;    }&#10;&#10;    // Обновляет визуальное выделение выбранной карточки&#10;    private fun updateSelectionUI() {&#10;        val blue = ContextCompat.getColor(this, android.R.color.holo_blue_light)&#10;        val white = ContextCompat.getColor(this, android.R.color.white)&#10;        when (selected) {&#10;            Selected.LEFT -&gt; {&#10;                leftCard.setCardBackgroundColor(blue)&#10;                rightCard.setCardBackgroundColor(white)&#10;            }&#10;            Selected.RIGHT -&gt; {&#10;                leftCard.setCardBackgroundColor(white)&#10;                rightCard.setCardBackgroundColor(blue)&#10;            }&#10;            Selected.NONE -&gt; {&#10;                leftCard.setCardBackgroundColor(white)&#10;                rightCard.setCardBackgroundColor(white)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun generateNewQuestion() {&#10;        nextButton.visibility = View.GONE&#10;        selected = Selected.NONE&#10;        updateSelectionUI()&#10;        centerSymbol.text = &quot;&quot;&#10;        centerSymbol.setBackgroundResource(R.drawable.number_drop_zone)&#10;&#10;        // Randomly assign who is boy/girl ensuring left/right are different&#10;        leftIsBoy = Random.nextBoolean()&#10;        leftPersonDisplay.text = if (leftIsBoy) &quot;&quot; else &quot;&quot;&#10;        rightPersonDisplay.text = if (leftIsBoy) &quot;&quot; else &quot;&quot;&#10;&#10;        // Генерация чисел с шансом равенства ~30%&#10;        leftCount = Random.nextInt(0, 10)&#10;        rightCount = Random.nextInt(0, 10)&#10;        if (Random.nextFloat() &lt; 0.3f) {&#10;            rightCount = leftCount&#10;        } else {&#10;            // гарантируем неравенство&#10;            if (rightCount == leftCount) {&#10;                rightCount = (leftCount + 1) % 10&#10;            }&#10;        }&#10;        // Исключаем случай одновременного нуля с обеих сторон&#10;        if (leftCount == 0 &amp;&amp; rightCount == 0) {&#10;            if (Random.nextBoolean()) rightCount = 1 else leftCount = 1&#10;        }&#10;&#10;        // Choose object&#10;        currentObjectEmoji = objectEmojis.random()&#10;&#10;        leftObjectsDisplay.text = currentObjectEmoji.repeat(leftCount)&#10;        rightObjectsDisplay.text = currentObjectEmoji.repeat(rightCount)&#10;        leftNumberDisplay.text = leftCount.toString()&#10;        rightNumberDisplay.text = rightCount.toString()&#10;&#10;        // Текст вопроса на экране и TTS&#10;        val itemName = emojiNames[currentObjectEmoji] ?: &quot;предметов&quot;&#10;        questionText.text = &quot;У кого $itemName больше, у мальчика или девочки?&quot;&#10;        hintText.text = &quot;Нажми на карточку&quot;&#10;        hintText.setTextColor(ContextCompat.getColor(this, android.R.color.darker_gray))&#10;&#10;        updateProgress()&#10;        speakQuestion()&#10;    }&#10;&#10;    private fun getItemNamePlural(): String = emojiNames[currentObjectEmoji] ?: &quot;предметов&quot;&#10;&#10;    private fun updateProgress() {&#10;        progressBar.progress = ((currentQuestion.toFloat() / totalQuestions) * 100).toInt()&#10;    }&#10;&#10;    private fun nextQuestion() {&#10;        currentQuestion++&#10;        if (currentQuestion &gt;= totalQuestions) {&#10;            finishGame()&#10;        } else {&#10;            generateNewQuestion()&#10;        }&#10;    }&#10;&#10;    private fun finishGame() {&#10;        val intent = Intent(this, NumberComparisonResultsActivity::class.java)&#10;        intent.putExtra(&quot;score&quot;, score)&#10;        intent.putExtra(&quot;totalCorrectAnswers&quot;, totalCorrectAnswers)&#10;        intent.putExtra(&quot;totalQuestions&quot;, totalQuestions)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    private fun speakQuestion() {&#10;        val text = &quot;У кого ${getItemNamePlural()} больше, у мальчика или девочки?&quot;&#10;        tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)&#10;    }&#10;&#10;    private fun speakSelectionQuestion(isLeft: Boolean) {&#10;        val item = getItemNamePlural()&#10;        val ending = confirmationEndings.random()&#10;        val selectedIsBoy = if (isLeft) leftIsBoy else !leftIsBoy&#10;        val subject = if (selectedIsBoy) &quot;мальчика&quot; else &quot;девочки&quot;&#10;        val other = if (selectedIsBoy) &quot;девочки&quot; else &quot;мальчика&quot;&#10;        val phrase = &quot;У $subject $item больше, чем у $other? $ending&quot;&#10;        tts?.speak(phrase, TextToSpeech.QUEUE_FLUSH, null, null)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val res = tts!!.setLanguage(Locale(&quot;ru&quot;, &quot;RU&quot;))&#10;            if (res == TextToSpeech.LANG_MISSING_DATA || res == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                tts!!.setLanguage(Locale.getDefault())&#10;            }&#10;            speakQuestion()&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        super.onDestroy()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.animation.AnimatorSet&#10;import android.animation.ObjectAnimator&#10;import android.content.Intent&#10;import android.content.pm.ActivityInfo&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.view.View&#10;import android.view.accessibility.AccessibilityEvent&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import com.timursarsembayev.danabalanumbers.R&#10;import java.util.Locale&#10;import kotlin.random.Random&#10;&#10;class KidsComparisonActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var tts: TextToSpeech? = null&#10;    private var currentQuestion = 0&#10;    private var score = 0&#10;    private var totalCorrectAnswers = 0&#10;    private val totalQuestions = 20&#10;&#10;    // UI&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var questionText: TextView&#10;    private lateinit var hintText: TextView&#10;&#10;    private lateinit var leftCard: CardView&#10;    private lateinit var rightCard: CardView&#10;&#10;    private lateinit var leftPersonDisplay: TextView&#10;    private lateinit var rightPersonDisplay: TextView&#10;    private lateinit var leftObjectsDisplay: TextView&#10;    private lateinit var rightObjectsDisplay: TextView&#10;    private lateinit var centerSymbol: TextView&#10;    private lateinit var leftNumberDisplay: TextView&#10;    private lateinit var rightNumberDisplay: TextView&#10;&#10;    private lateinit var nextButton: Button&#10;    private lateinit var equalButton: Button&#10;&#10;    // Logic&#10;    private var leftCount = 0&#10;    private var rightCount = 0&#10;    private var currentObjectEmoji = &quot;&quot;&#10;    private var leftIsBoy = true // the other will be girl&#10;&#10;    // Словарь названий предметов (род. падеж множественного числа)&#10;    private val emojiNames: Map&lt;String, String&gt; = mapOf(&#10;        &quot;&quot; to &quot;яблок&quot;,&#10;        &quot;&quot; to &quot;бананов&quot;,&#10;        &quot;&quot; to &quot;виноградин&quot;,&#10;        &quot;&quot; to &quot;клубничек&quot;,&#10;        &quot;&quot; to &quot;вишенок&quot;,&#10;        &quot;&quot; to &quot;морковок&quot;,&#10;        &quot;&quot; to &quot;огурцов&quot;,&#10;        &quot;&quot; to &quot;помидоров&quot;,&#10;        &quot;⚽&quot; to &quot;мячей&quot;,&#10;        &quot;&quot; to &quot;мячей&quot;,&#10;        &quot;&quot; to &quot;мячиков&quot;,&#10;        &quot;&quot; to &quot;мячей&quot;,&#10;        &quot;&quot; to &quot;шариков&quot;,&#10;        &quot;&quot; to &quot;подарков&quot;,&#10;        &quot;&quot; to &quot;тортиков&quot;,&#10;        &quot;&quot; to &quot;красок&quot;,&#10;        &quot;&quot; to &quot;звёзд&quot;,&#10;        &quot;⭐&quot; to &quot;звёздочек&quot;,&#10;        &quot;✨&quot; to &quot;искорок&quot;,&#10;        &quot;&quot; to &quot;цветков&quot;,&#10;        &quot;&quot; to &quot;цветков&quot;,&#10;        &quot;&quot; to &quot;ромашек&quot;,&#10;        &quot;&quot; to &quot;подсолнухов&quot;,&#10;        &quot;&quot; to &quot;роз&quot;&#10;    )&#10;&#10;    private val confirmationEndings = listOf(&#10;        &quot;Ты уверен?&quot;,&#10;        &quot;Верно?&quot;,&#10;        &quot;Как думаешь, это правильно?&quot;,&#10;        &quot;Проверь внимательно!&quot;,&#10;        &quot;Давай проверим!&quot;&#10;    )&#10;&#10;    // Эмодзи предметов для выбора&#10;    private val objectEmojis = arrayOf(&#10;        &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,&#10;        &quot;⚽&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,&#10;        &quot;&quot;, &quot;⭐&quot;, &quot;✨&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;&#10;    )&#10;&#10;    // Текущее выделение пользователя&#10;    private enum class Selected { NONE, LEFT, RIGHT }&#10;    private var selected: Selected = Selected.NONE&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        // Keep landscape like original comparison&#10;        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE&#10;        setContentView(R.layout.activity_kids_comparison)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        tts = TextToSpeech(this, this)&#10;        initViews()&#10;        setupClicks()&#10;        generateNewQuestion()&#10;    }&#10;&#10;    private fun initViews() {&#10;        progressBar = findViewById(R.id.progressBar)&#10;        questionText = findViewById(R.id.questionText)&#10;        hintText = findViewById(R.id.hintText)&#10;&#10;        leftCard = findViewById(R.id.leftCard)&#10;        rightCard = findViewById(R.id.rightCard)&#10;&#10;        leftPersonDisplay = findViewById(R.id.leftPersonDisplay)&#10;        rightPersonDisplay = findViewById(R.id.rightPersonDisplay)&#10;        leftObjectsDisplay = findViewById(R.id.leftObjectsDisplay)&#10;        rightObjectsDisplay = findViewById(R.id.rightObjectsDisplay)&#10;        leftNumberDisplay = findViewById(R.id.leftNumberDisplay)&#10;        rightNumberDisplay = findViewById(R.id.rightNumberDisplay)&#10;&#10;        centerSymbol = findViewById(R.id.centerSymbol)&#10;        nextButton = findViewById(R.id.nextButton)&#10;        equalButton = findViewById(R.id.equalButton)&#10;&#10;        // back button&#10;        findViewById&lt;ImageButton&gt;(R.id.backButton).setOnClickListener { finish() }&#10;&#10;        nextButton.visibility = View.GONE&#10;    }&#10;&#10;    private fun setupClicks() {&#10;        leftCard.setOnClickListener { onSideSelected(isLeft = true) }&#10;        rightCard.setOnClickListener { onSideSelected(isLeft = false) }&#10;        equalButton.setOnClickListener { onEqualSelected() }&#10;&#10;        nextButton.setOnClickListener { nextQuestion() }&#10;    }&#10;&#10;    private fun onSideSelected(isLeft: Boolean) {&#10;        if (nextButton.visibility == View.VISIBLE) return&#10;&#10;        // Устанавливаем выбранную сторону и обновляем UI выделения&#10;        selected = if (isLeft) Selected.LEFT else Selected.RIGHT&#10;        updateSelectionUI()&#10;&#10;        // Озвучиваем выбранный вариант с корректным определением пола&#10;        speakSelectionQuestion(isLeft)&#10;&#10;        // Показать в центре символ выбора пользователя: слева выбирают «больше», значит '&gt;'&#10;        showCenterSymbol(if (isLeft) &quot;&gt;&quot; else &quot;&lt;&quot;)&#10;&#10;        val correctLeft = leftCount &gt; rightCount&#10;        val correctRight = rightCount &gt; leftCount&#10;        val isCorrect = (isLeft &amp;&amp; correctLeft) || (!isLeft &amp;&amp; correctRight)&#10;&#10;        if (isCorrect) {&#10;            score += 100&#10;            totalCorrectAnswers++&#10;            hintText.text = &quot;Отлично!&quot;&#10;            hintText.setTextColor(ContextCompat.getColor(this, android.R.color.holo_green_dark))&#10;            centerSymbol.setBackgroundResource(R.drawable.number_input_correct)&#10;            animatePulse(centerSymbol)&#10;            nextButton.visibility = View.VISIBLE&#10;        } else {&#10;            hintText.text = &quot;Попробуй ещё раз&quot;&#10;            hintText.setTextColor(ContextCompat.getColor(this, android.R.color.holo_red_dark))&#10;            // временная красная подсветка на нажатой карточке&#10;            val card = if (isLeft) leftCard else rightCard&#10;            val originalColor = (if (selected == (if (isLeft) Selected.LEFT else Selected.RIGHT))&#10;                ContextCompat.getColor(this, android.R.color.holo_blue_light)&#10;            else ContextCompat.getColor(this, android.R.color.white))&#10;            card.setCardBackgroundColor(ContextCompat.getColor(this, android.R.color.holo_red_light))&#10;            card.postDelayed({ updateSelectionUI() }, 500)&#10;            centerSymbol.setBackgroundResource(R.drawable.number_drop_zone)&#10;            animateShake(card)&#10;        }&#10;    }&#10;&#10;    private fun onEqualSelected() {&#10;        if (nextButton.visibility == View.VISIBLE) return&#10;        // Сброс выделения при выборе равенства&#10;        selected = Selected.NONE&#10;        updateSelectionUI()&#10;&#10;        // Озвучка равенства&#10;        val item = getItemNamePlural()&#10;        val ending = confirmationEndings.random()&#10;        val phrase = &quot;Поровну ${item}? $ending&quot;&#10;        tts?.speak(phrase, TextToSpeech.QUEUE_FLUSH, null, null)&#10;&#10;        // Показать символ '=' в центре&#10;        showCenterSymbol(&quot;=&quot;)&#10;&#10;        val isCorrect = leftCount == rightCount&#10;        if (isCorrect) {&#10;            score += 100&#10;            totalCorrectAnswers++&#10;            hintText.text = &quot;Верно!&quot;&#10;            hintText.setTextColor(ContextCompat.getColor(this, android.R.color.holo_green_dark))&#10;            centerSymbol.setBackgroundResource(R.drawable.number_input_correct)&#10;            animatePulse(centerSymbol)&#10;            nextButton.visibility = View.VISIBLE&#10;        } else {&#10;            hintText.text = &quot;Попробуй ещё раз&quot;&#10;            hintText.setTextColor(ContextCompat.getColor(this, android.R.color.holo_red_dark))&#10;            centerSymbol.setBackgroundResource(R.drawable.number_input_incorrect)&#10;            centerSymbol.postDelayed({ centerSymbol.setBackgroundResource(R.drawable.number_drop_zone) }, 500)&#10;            animateShake(centerSymbol)&#10;        }&#10;    }&#10;&#10;    private fun showCenterSymbol(symbol: String) { centerSymbol.text = symbol }&#10;&#10;    // Пульсация (успех)&#10;    private fun animatePulse(view: View) {&#10;        val sx = ObjectAnimator.ofFloat(view, &quot;scaleX&quot;, 1f, 1.15f, 1f)&#10;        val sy = ObjectAnimator.ofFloat(view, &quot;scaleY&quot;, 1f, 1.15f, 1f)&#10;        AnimatorSet().apply {&#10;            playTogether(sx, sy)&#10;            duration = 300&#10;            start()&#10;        }&#10;    }&#10;&#10;    // Тряска (ошибка)&#10;    private fun animateShake(view: View) {&#10;        val anim = ObjectAnimator.ofFloat(view, &quot;translationX&quot;, 0f, -10f, 10f, -5f, 5f, 0f)&#10;        anim.duration = 500&#10;        anim.start()&#10;    }&#10;&#10;    // Обновляет визуальное выделение выбранной карточки&#10;    private fun updateSelectionUI() {&#10;        val blue = ContextCompat.getColor(this, android.R.color.holo_blue_light)&#10;        val white = ContextCompat.getColor(this, android.R.color.white)&#10;        when (selected) {&#10;            Selected.LEFT -&gt; {&#10;                leftCard.setCardBackgroundColor(blue)&#10;                rightCard.setCardBackgroundColor(white)&#10;            }&#10;            Selected.RIGHT -&gt; {&#10;                leftCard.setCardBackgroundColor(white)&#10;                rightCard.setCardBackgroundColor(blue)&#10;            }&#10;            Selected.NONE -&gt; {&#10;                leftCard.setCardBackgroundColor(white)&#10;                rightCard.setCardBackgroundColor(white)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun generateNewQuestion() {&#10;        nextButton.visibility = View.GONE&#10;        selected = Selected.NONE&#10;        updateSelectionUI()&#10;        centerSymbol.text = &quot;&quot;&#10;        centerSymbol.setBackgroundResource(R.drawable.number_drop_zone)&#10;&#10;        // Randomly assign who is boy/girl ensuring left/right are different&#10;        leftIsBoy = Random.nextBoolean()&#10;        leftPersonDisplay.text = if (leftIsBoy) &quot;&quot; else &quot;&quot;&#10;        rightPersonDisplay.text = if (leftIsBoy) &quot;&quot; else &quot;&quot;&#10;&#10;        // Генерация чисел с шансом равенства ~30%&#10;        leftCount = Random.nextInt(0, 10)&#10;        rightCount = Random.nextInt(0, 10)&#10;        if (Random.nextFloat() &lt; 0.3f) {&#10;            rightCount = leftCount&#10;        } else {&#10;            // гарантируем неравенство&#10;            if (rightCount == leftCount) {&#10;                rightCount = (leftCount + 1) % 10&#10;            }&#10;        }&#10;        // Исключаем случай одновременного нуля с обеих сторон&#10;        if (leftCount == 0 &amp;&amp; rightCount == 0) {&#10;            if (Random.nextBoolean()) rightCount = 1 else leftCount = 1&#10;        }&#10;&#10;        // Choose object&#10;        currentObjectEmoji = objectEmojis.random()&#10;&#10;        leftObjectsDisplay.text = currentObjectEmoji.repeat(leftCount)&#10;        rightObjectsDisplay.text = currentObjectEmoji.repeat(rightCount)&#10;        leftNumberDisplay.text = leftCount.toString()&#10;        rightNumberDisplay.text = rightCount.toString()&#10;&#10;        // Текст вопроса на экране и TTS&#10;        val itemName = emojiNames[currentObjectEmoji] ?: &quot;предметов&quot;&#10;        questionText.text = &quot;У кого $itemName больше, у мальчика или девочки?&quot;&#10;        hintText.text = &quot;Нажми на карточку&quot;&#10;        hintText.setTextColor(ContextCompat.getColor(this, android.R.color.darker_gray))&#10;&#10;        updateProgress()&#10;        speakQuestion()&#10;    }&#10;&#10;    private fun getItemNamePlural(): String = emojiNames[currentObjectEmoji] ?: &quot;предметов&quot;&#10;&#10;    private fun updateProgress() {&#10;        progressBar.progress = ((currentQuestion.toFloat() / totalQuestions) * 100).toInt()&#10;    }&#10;&#10;    private fun nextQuestion() {&#10;        currentQuestion++&#10;        if (currentQuestion &gt;= totalQuestions) {&#10;            finishGame()&#10;        } else {&#10;            generateNewQuestion()&#10;        }&#10;    }&#10;&#10;    private fun finishGame() {&#10;        val intent = Intent(this, NumberComparisonResultsActivity::class.java)&#10;        intent.putExtra(&quot;score&quot;, score)&#10;        intent.putExtra(&quot;totalCorrectAnswers&quot;, totalCorrectAnswers)&#10;        intent.putExtra(&quot;totalQuestions&quot;, totalQuestions)&#10;        intent.putExtra(&quot;fromKidsComparison&quot;, true)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    private fun speakQuestion() {&#10;        val text = &quot;У кого ${getItemNamePlural()} больше, у мальчика или девочки?&quot;&#10;        tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)&#10;    }&#10;&#10;    private fun speakSelectionQuestion(isLeft: Boolean) {&#10;        val item = getItemNamePlural()&#10;        val ending = confirmationEndings.random()&#10;        val selectedIsBoy = if (isLeft) leftIsBoy else !leftIsBoy&#10;        val subject = if (selectedIsBoy) &quot;мальчика&quot; else &quot;девочки&quot;&#10;        val other = if (selectedIsBoy) &quot;девочки&quot; else &quot;мальчика&quot;&#10;        val phrase = &quot;У $subject $item больше, чем у $other? $ending&quot;&#10;        tts?.speak(phrase, TextToSpeech.QUEUE_FLUSH, null, null)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val res = tts!!.setLanguage(Locale(&quot;ru&quot;, &quot;RU&quot;))&#10;            if (res == TextToSpeech.LANG_MISSING_DATA || res == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                tts!!.setLanguage(Locale.getDefault())&#10;            }&#10;            speakQuestion()&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/NumberComparisonResultsActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/NumberComparisonResultsActivity.kt" />
              <option name="originalContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Intent&#10;import android.content.pm.ActivityInfo&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import java.util.*&#10;&#10;class NumberComparisonResultsActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var tts: TextToSpeech? = null&#10;&#10;    // Варианты поздравлений для разных уровней успеха&#10;    private val excellentPhrases = listOf(&#10;        &quot;Поздравляю! Ты настоящий чемпион по сравнению чисел!&quot;,&#10;        &quot;Невероятно! Ты отлично знаешь, какие числа больше, а какие меньше!&quot;,&#10;        &quot;Браво! Ты справился просто великолепно!&quot;,&#10;        &quot;Супер! Ты становишься настоящим математиком!&quot;&#10;    )&#10;&#10;    private val goodPhrases = listOf(&#10;        &quot;Молодец! Ты хорошо понимаешь сравнение чисел!&quot;,&#10;        &quot;Отлично! Продолжай в том же духе!&quot;,&#10;        &quot;Здорово! Ты делаешь большие успехи!&quot;,&#10;        &quot;Умница! Ты очень хорошо справился!&quot;&#10;    )&#10;&#10;    private val okayPhrases = listOf(&#10;        &quot;Неплохо! Продолжай тренироваться, и у тебя все получится!&quot;,&#10;        &quot;Хорошая попытка! Ты на правильном пути!&quot;,&#10;        &quot;Так держать! С каждым разом у тебя получается лучше!&quot;,&#10;        &quot;Молодец, что стараешься! Продолжай изучать числа!&quot;&#10;    )&#10;&#10;    private val encouragementPhrases = listOf(&#10;        &quot;Не расстраивайся! Все учатся постепенно. Попробуй еще раз!&quot;,&#10;        &quot;Ничего страшного! Каждый математик начинал с простых заданий!&quot;,&#10;        &quot;Не сдавайся! Ты обязательно научишься сравнивать числа!&quot;,&#10;        &quot;Попробуй снова! У тебя все получится!&quot;&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Принудительно устанавливаем альбомную ориентацию&#10;        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE&#10;&#10;        setContentView(R.layout.activity_number_comparison_results)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        tts = TextToSpeech(this, this)&#10;        setupViews()&#10;    }&#10;&#10;    private fun setupViews() {&#10;        val score = intent.getIntExtra(&quot;score&quot;, 0)&#10;        val totalCorrectAnswers = intent.getIntExtra(&quot;totalCorrectAnswers&quot;, 0)&#10;        val totalQuestions = intent.getIntExtra(&quot;totalQuestions&quot;, 20)&#10;&#10;        val scoreDisplay = findViewById&lt;TextView&gt;(R.id.scoreDisplay)&#10;        val correctAnswersDisplay = findViewById&lt;TextView&gt;(R.id.correctAnswersDisplay)&#10;        val accuracyDisplay = findViewById&lt;TextView&gt;(R.id.accuracyDisplay)&#10;        val messageDisplay = findViewById&lt;TextView&gt;(R.id.messageDisplay)&#10;        val motivationalMessage = findViewById&lt;TextView&gt;(R.id.motivationalMessage)&#10;        val performanceBadge = findViewById&lt;TextView&gt;(R.id.performanceBadge)&#10;        val congratulationsIcon = findViewById&lt;TextView&gt;(R.id.congratulationsIcon)&#10;        val achievementStars = findViewById&lt;LinearLayout&gt;(R.id.achievementStars)&#10;&#10;        scoreDisplay.text = &quot;Очки: $score&quot;&#10;        correctAnswersDisplay.text = &quot;Правильных ответов: $totalCorrectAnswers из $totalQuestions&quot;&#10;&#10;        val accuracy = if (totalQuestions &gt; 0) {&#10;            (totalCorrectAnswers.toFloat() / totalQuestions * 100).toInt()&#10;        } else 0&#10;&#10;        accuracyDisplay.text = &quot;Точность: $accuracy%&quot;&#10;&#10;        // Настройка сообщений и внешнего вида в зависимости от результата&#10;        when {&#10;            accuracy &gt;= 90 -&gt; {&#10;                messageDisplay.text = &quot; Поздравляем! Ты чемпион!&quot;&#10;                motivationalMessage.text = &quot;Ты отлично знаешь, как сравнивать числа! Продолжай изучать математику!&quot;&#10;                performanceBadge.text = &quot; ПРЕВОСХОДНО!&quot;&#10;                congratulationsIcon.text = &quot;&quot;&#10;                createStars(achievementStars, 5)&#10;            }&#10;            accuracy &gt;= 75 -&gt; {&#10;                messageDisplay.text = &quot; Отлично! Очень хорошо!&quot;&#10;                motivationalMessage.text = &quot;Ты хорошо понимаешь сравнение чисел! Так держать!&quot;&#10;                performanceBadge.text = &quot; ОТЛИЧНО!&quot;&#10;                congratulationsIcon.text = &quot;&quot;&#10;                createStars(achievementStars, 4)&#10;            }&#10;            accuracy &gt;= 50 -&gt; {&#10;                messageDisplay.text = &quot; Хорошая попытка!&quot;&#10;                motivationalMessage.text = &quot;Ты на правильном пути! Продолжай тренироваться!&quot;&#10;                performanceBadge.text = &quot; ХОРОШО!&quot;&#10;                congratulationsIcon.text = &quot;&quot;&#10;                createStars(achievementStars, 3)&#10;            }&#10;            else -&gt; {&#10;                messageDisplay.text = &quot; Попробуй еще раз!&quot;&#10;                motivationalMessage.text = &quot;Не расстраивайся! Все учатся постепенно. Ты обязательно справишься!&quot;&#10;                performanceBadge.text = &quot; СТАРАЙСЯ!&quot;&#10;                congratulationsIcon.text = &quot;&quot;&#10;                createStars(achievementStars, 2)&#10;            }&#10;        }&#10;&#10;        // Кнопки&#10;        findViewById&lt;Button&gt;(R.id.restartButton).setOnClickListener {&#10;            val intent = Intent(this, NumberComparisonActivity::class.java)&#10;            startActivity(intent)&#10;            finish()&#10;        }&#10;&#10;        findViewById&lt;Button&gt;(R.id.homeButton).setOnClickListener {&#10;            val intent = Intent(this, MathExercisesActivity::class.java)&#10;            intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            startActivity(intent)&#10;            finish()&#10;        }&#10;&#10;        findViewById&lt;ImageButton&gt;(R.id.backButton).setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun createStars(container: LinearLayout, count: Int) {&#10;        container.removeAllViews()&#10;&#10;        for (i in 1..5) {&#10;            val star = TextView(this).apply {&#10;                text = if (i &lt;= count) &quot;⭐&quot; else &quot;☆&quot;&#10;                textSize = 24f&#10;                setPadding(4, 0, 4, 0)&#10;            }&#10;            container.addView(star)&#10;        }&#10;    }&#10;&#10;    private fun speakCongratulations(accuracy: Int) {&#10;        val congratulationPhrase = when {&#10;            accuracy &gt;= 90 -&gt; excellentPhrases.random()&#10;            accuracy &gt;= 75 -&gt; goodPhrases.random()&#10;            accuracy &gt;= 50 -&gt; okayPhrases.random()&#10;            else -&gt; encouragementPhrases.random()&#10;        }&#10;&#10;        speakText(congratulationPhrase)&#10;    }&#10;&#10;    private fun speakText(text: String) {&#10;        tts?.speak(text, TextToSpeech.QUEUE_ADD, null, null)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val result = tts!!.setLanguage(Locale(&quot;ru&quot;, &quot;RU&quot;))&#10;            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                tts!!.setLanguage(Locale.getDefault())&#10;            }&#10;&#10;            // Озвучиваем поздравления через секунду после инициализации TTS&#10;            val accuracy = if (intent.getIntExtra(&quot;totalQuestions&quot;, 20) &gt; 0) {&#10;                (intent.getIntExtra(&quot;totalCorrectAnswers&quot;, 0).toFloat() / intent.getIntExtra(&quot;totalQuestions&quot;, 20) * 100).toInt()&#10;            } else 0&#10;&#10;            // Небольшая задержка для лучшего восприятия&#10;            android.os.Handler(mainLooper).postDelayed({&#10;                speakCongratulations(accuracy)&#10;            }, 1000)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        super.onDestroy()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Intent&#10;import android.content.pm.ActivityInfo&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.LinearLayout&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.core.content.ContextCompat&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import java.util.*&#10;&#10;class NumberComparisonResultsActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var tts: TextToSpeech? = null&#10;&#10;    // Варианты поздравлений для разных уровней успеха&#10;    private val excellentPhrases = listOf(&#10;        &quot;Поздравляю! Ты настоящий чемпион по сравнению чисел!&quot;,&#10;        &quot;Невероятно! Ты отлично знаешь, какие числа больше, а какие меньше!&quot;,&#10;        &quot;Браво! Ты справился просто великолепно!&quot;,&#10;        &quot;Супер! Ты становишься настоящим математиком!&quot;&#10;    )&#10;&#10;    private val goodPhrases = listOf(&#10;        &quot;Молодец! Ты хорошо понимаешь сравнение чисел!&quot;,&#10;        &quot;Отлично! Продолжай в том же духе!&quot;,&#10;        &quot;Здорово! Ты делаешь большие успехи!&quot;,&#10;        &quot;Умница! Ты очень хорошо справился!&quot;&#10;    )&#10;&#10;    private val okayPhrases = listOf(&#10;        &quot;Неплохо! Продолжай тренироваться, и у тебя все получится!&quot;,&#10;        &quot;Хорошая попытка! Ты на правильном пути!&quot;,&#10;        &quot;Так держать! С каждым разом у тебя получается лучше!&quot;,&#10;        &quot;Молодец, что стараешься! Продолжай изучать числа!&quot;&#10;    )&#10;&#10;    private val encouragementPhrases = listOf(&#10;        &quot;Не расстраивайся! Вс�� учатся постепенно. Попробуй еще раз!&quot;,&#10;        &quot;Ничего страшного! Каждый математик начинал с простых заданий!&quot;,&#10;        &quot;Не сдавайся! Ты обязательно научишься сравнивать числа!&quot;,&#10;        &quot;Попробуй снова! У ��ебя все получится!&quot;&#10;    )&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Принудительно устанавливае�� альбомную ориентацию&#10;        requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE&#10;&#10;        setContentView(R.layout.activity_number_comparison_results)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        tts = TextToSpeech(this, this)&#10;        setupViews()&#10;    }&#10;&#10;    private fun setupViews() {&#10;        val score = intent.getIntExtra(&quot;score&quot;, 0)&#10;        val totalCorrectAnswers = intent.getIntExtra(&quot;totalCorrectAnswers&quot;, 0)&#10;        val totalQuestions = intent.getIntExtra(&quot;totalQuestions&quot;, 20)&#10;        val fromKidsComparison = intent.getBooleanExtra(&quot;fromKidsComparison&quot;, false)&#10;&#10;        val scoreDisplay = findViewById&lt;TextView&gt;(R.id.scoreDisplay)&#10;        val correctAnswersDisplay = findViewById&lt;TextView&gt;(R.id.correctAnswersDisplay)&#10;        val accuracyDisplay = findViewById&lt;TextView&gt;(R.id.accuracyDisplay)&#10;        val messageDisplay = findViewById&lt;TextView&gt;(R.id.messageDisplay)&#10;        val motivationalMessage = findViewById&lt;TextView&gt;(R.id.motivationalMessage)&#10;        val performanceBadge = findViewById&lt;TextView&gt;(R.id.performanceBadge)&#10;        val congratulationsIcon = findViewById&lt;TextView&gt;(R.id.congratulationsIcon)&#10;        val achievementStars = findViewById&lt;LinearLayout&gt;(R.id.achievementStars)&#10;&#10;        scoreDisplay.text = &quot;Очки: $score&quot;&#10;        correctAnswersDisplay.text = &quot;Правильных ответов: $totalCorrectAnswers из $totalQuestions&quot;&#10;&#10;        val accuracy = if (totalQuestions &gt; 0) {&#10;            (totalCorrectAnswers.toFloat() / totalQuestions * 100).toInt()&#10;        } else 0&#10;&#10;        accuracyDisplay.text = &quot;Точность: $accuracy%&quot;&#10;&#10;        // Настройка сообщений и внешнего вида в зависимости от результата&#10;        when {&#10;            accuracy &gt;= 90 -&gt; {&#10;                messageDisplay.text = &quot; Поздравляем! Ты чемпион!&quot;&#10;                motivationalMessage.text = &quot;Ты отлично знаешь, как сравнивать числа! Продолжай изучать математику!&quot;&#10;                performanceBadge.text = &quot; ПРЕВОСХОДНО!&quot;&#10;                congratulationsIcon.text = &quot;&quot;&#10;                createStars(achievementStars, 5)&#10;            }&#10;            accuracy &gt;= 75 -&gt; {&#10;                messageDisplay.text = &quot; Отлично! Очень хорошо!&quot;&#10;                motivationalMessage.text = &quot;Ты хорошо понимаешь сравнение чисел! Так держать!&quot;&#10;                performanceBadge.text = &quot; ОТЛИЧНО!&quot;&#10;                congratulationsIcon.text = &quot;&quot;&#10;                createStars(achievementStars, 4)&#10;            }&#10;            accuracy &gt;= 50 -&gt; {&#10;                messageDisplay.text = &quot; Хорошая попытка!&quot;&#10;                motivationalMessage.text = &quot;Ты на правильном пути! Продолжай тренироваться!&quot;&#10;                performanceBadge.text = &quot; ХОРОШО!&quot;&#10;                congratulationsIcon.text = &quot;&quot;&#10;                createStars(achievementStars, 3)&#10;            }&#10;            else -&gt; {&#10;                messageDisplay.text = &quot; Попробуй еще раз!&quot;&#10;                motivationalMessage.text = &quot;Не расстраивайся! Все учатся постепенно. Ты обязательно справишься!&quot;&#10;                performanceBadge.text = &quot; СТАРАЙСЯ!&quot;&#10;                congratulationsIcon.text = &quot;&quot;&#10;                createStars(achievementStars, 2)&#10;            }&#10;        }&#10;&#10;        // Кнопки&#10;        findViewById&lt;Button&gt;(R.id.restartButton).setOnClickListener {&#10;            val intent = Intent(this, if (fromKidsComparison) KidsComparisonActivity::class.java else NumberComparisonActivity::class.java)&#10;            startActivity(intent)&#10;            finish()&#10;        }&#10;&#10;        findViewById&lt;Button&gt;(R.id.homeButton).setOnClickListener {&#10;            val intent = Intent(this, MathExercisesActivity::class.java)&#10;            intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            startActivity(intent)&#10;            finish()&#10;        }&#10;&#10;        findViewById&lt;ImageButton&gt;(R.id.backButton).setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun createStars(container: LinearLayout, count: Int) {&#10;        container.removeAllViews()&#10;&#10;        for (i in 1..5) {&#10;            val star = TextView(this).apply {&#10;                text = if (i &lt;= count) &quot;⭐&quot; else &quot;☆&quot;&#10;                textSize = 24f&#10;                setPadding(4, 0, 4, 0)&#10;            }&#10;            container.addView(star)&#10;        }&#10;    }&#10;&#10;    private fun speakCongratulations(accuracy: Int) {&#10;        val congratulationPhrase = when {&#10;            accuracy &gt;= 90 -&gt; excellentPhrases.random()&#10;            accuracy &gt;= 75 -&gt; goodPhrases.random()&#10;            accuracy &gt;= 50 -&gt; okayPhrases.random()&#10;            else -&gt; encouragementPhrases.random()&#10;        }&#10;&#10;        speakText(congratulationPhrase)&#10;    }&#10;&#10;    private fun speakText(text: String) {&#10;        tts?.speak(text, TextToSpeech.QUEUE_ADD, null, null)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val result = tts!!.setLanguage(Locale(&quot;ru&quot;, &quot;RU&quot;))&#10;            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                tts!!.setLanguage(Locale.getDefault())&#10;            }&#10;&#10;            // Озвучиваем поздравления через секунду после инициализации TTS&#10;            val accuracy = if (intent.getIntExtra(&quot;totalQuestions&quot;, 20) &gt; 0) {&#10;                (intent.getIntExtra(&quot;totalCorrectAnswers&quot;, 0).toFloat() / intent.getIntExtra(&quot;totalQuestions&quot;, 20) * 100).toInt()&#10;            } else 0&#10;&#10;            // Небольшая задержка для лучшего восприятия&#10;            android.os.Handler(mainLooper).postDelayed({&#10;                speakCongratulations(accuracy)&#10;            }, 1000)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/NumberSequenceModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/NumberSequenceModels.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/SchulteNumbersActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/SchulteNumbersActivity.kt" />
              <option name="originalContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.speech.tts.TextToSpeech&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.timursarsembayev.danabalanumbers.R&#10;import java.util.Locale&#10;&#10;class SchulteNumbersActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private lateinit var timerView: TextView&#10;    private lateinit var targetView: TextView&#10;    private lateinit var gameView: SchulteNumbersView&#10;&#10;    private var startTimeMs: Long = 0L&#10;    private var running = false&#10;    private val handler = Handler(Looper.getMainLooper())&#10;&#10;    private var targetDigit = 0&#10;&#10;    private var tts: TextToSpeech? = null&#10;    private var ttsReady = false&#10;&#10;    private val updateTimer = object : Runnable {&#10;        override fun run() {&#10;            if (!running) return&#10;            val elapsed = System.currentTimeMillis() - startTimeMs&#10;            timerView.text = formatTime(elapsed)&#10;            handler.postDelayed(this, 100)&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_schulte_numbers)&#10;&#10;        timerView = findViewById&lt;TextView&gt;(R.id.timerView)&#10;        targetView = findViewById&lt;TextView&gt;(R.id.targetView)&#10;        gameView = findViewById&lt;SchulteNumbersView&gt;(R.id.schulteGameView)&#10;&#10;        findViewById&lt;ImageButton&gt;(R.id.buttonBack).setOnClickListener { finish() }&#10;&#10;        tts = TextToSpeech(this, this)&#10;&#10;        gameView.onTileTap = { digit -&gt;&#10;            if (digit == targetDigit) {&#10;                speakPraise()&#10;                nextTargetOrFinish()&#10;            }&#10;        }&#10;&#10;        startGame()&#10;    }&#10;&#10;    private fun startGame() {&#10;        targetDigit = 0&#10;        updateTargetText()&#10;        gameView.resetGrid(targetDigit)&#10;        startTimeMs = System.currentTimeMillis()&#10;        running = true&#10;        handler.post(updateTimer)&#10;    }&#10;&#10;    private fun nextTargetOrFinish() {&#10;        if (targetDigit &gt;= 9) {&#10;            finishGame()&#10;        } else {&#10;            targetDigit++&#10;            updateTargetText()&#10;            gameView.flipToNext(targetDigit)&#10;        }&#10;    }&#10;&#10;    private fun updateTargetText() {&#10;        targetView.text = &quot;Найди цифру $targetDigit&quot;&#10;    }&#10;&#10;    private fun finishGame() {&#10;        running = false&#10;        handler.removeCallbacks(updateTimer)&#10;        val elapsed = System.currentTimeMillis() - startTimeMs&#10;        val intent = Intent(this, SchulteNumbersResultsActivity::class.java)&#10;        intent.putExtra(&quot;elapsed&quot;, elapsed)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    private fun speakPraise() {&#10;        if (!ttsReady) return&#10;        val phrase = listOf(&#10;            &quot;Молодец!&quot;, &quot;Отлично!&quot;, &quot;Так держать!&quot;, &quot;Здорово!&quot;, &quot;Супер!&quot;&#10;        ).random()&#10;        tts?.speak(phrase, TextToSpeech.QUEUE_FLUSH, null, &quot;schulte_praise&quot;)&#10;    }&#10;&#10;    private fun formatTime(ms: Long): String {&#10;        val totalSec = ms / 1000&#10;        val min = totalSec / 60&#10;        val sec = totalSec % 60&#10;        val hund = (ms % 1000) / 10&#10;        return String.format(Locale.getDefault(), &quot;%02d:%02d.%02d&quot;, min, sec, hund)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val res = tts?.setLanguage(Locale(&quot;ru&quot;, &quot;RU&quot;))&#10;            if (res == TextToSpeech.LANG_MISSING_DATA || res == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                tts?.language = Locale.getDefault()&#10;            }&#10;            ttsReady = true&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        running = false&#10;        handler.removeCallbacks(updateTimer)&#10;        tts?.stop()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (targetDigit &lt;= 9) {&#10;            running = true&#10;            if (startTimeMs == 0L) startTimeMs = System.currentTimeMillis()&#10;            handler.post(updateTimer)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop(); tts?.shutdown(); tts = null&#10;        super.onDestroy()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.os.Handler&#10;import android.os.Looper&#10;import android.speech.tts.TextToSpeech&#10;import android.widget.ImageView&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import com.timursarsembayev.danabalanumbers.R&#10;import java.util.Locale&#10;&#10;class SchulteNumbersActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private lateinit var timerView: TextView&#10;    private lateinit var targetView: TextView&#10;    private lateinit var gameView: SchulteNumbersView&#10;    private lateinit var progressBar: ProgressBar&#10;&#10;    private var startTimeMs: Long = 0L&#10;    private var running = false&#10;    private val handler = Handler(Looper.getMainLooper())&#10;&#10;    private var targetDigit = 0&#10;&#10;    private var tts: TextToSpeech? = null&#10;    private var ttsReady = false&#10;&#10;    private val updateTimer = object : Runnable {&#10;        override fun run() {&#10;            if (!running) return&#10;            val elapsed = System.currentTimeMillis() - startTimeMs&#10;            timerView.text = formatTime(elapsed)&#10;            handler.postDelayed(this, 100)&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_schulte_numbers)&#10;&#10;        timerView = findViewById&lt;TextView&gt;(R.id.timerView)&#10;        targetView = findViewById&lt;TextView&gt;(R.id.targetView)&#10;        gameView = findViewById&lt;SchulteNumbersView&gt;(R.id.schulteGameView)&#10;        progressBar = findViewById(R.id.progressBar)&#10;&#10;        // Стандартная кнопка Назад&#10;        findViewById&lt;ImageView&gt;(R.id.backButton).setOnClickListener { finish() }&#10;&#10;        // Прогресс всего 10 целей (0..9)&#10;        progressBar.max = 10&#10;        progressBar.progress = 0&#10;&#10;        tts = TextToSpeech(this, this)&#10;&#10;        gameView.onTileTap = { digit -&gt;&#10;            if (digit == targetDigit) {&#10;                speakPraise()&#10;                nextTargetOrFinish()&#10;            }&#10;        }&#10;&#10;        startGame()&#10;    }&#10;&#10;    private fun startGame() {&#10;        targetDigit = 0&#10;        updateTargetText()&#10;        gameView.resetGrid(targetDigit)&#10;        startTimeMs = System.currentTimeMillis()&#10;        running = true&#10;        handler.post(updateTimer)&#10;        // Озвучим первое задание&#10;        speakTarget()&#10;    }&#10;&#10;    private fun nextTargetOrFinish() {&#10;        if (targetDigit &gt;= 9) {&#10;            // Завершаем и заполняем прогресс на 100%&#10;            progressBar.progress = 10&#10;            finishGame()&#10;        } else {&#10;            targetDigit++&#10;            updateTargetText()&#10;            // Обновляем прогресс после успешного нажатия&#10;            progressBar.progress = targetDigit&#10;            gameView.flipToNext(targetDigit)&#10;            // Озвучим следующее задание&#10;            speakTarget()&#10;        }&#10;    }&#10;&#10;    private fun updateTargetText() {&#10;        targetView.text = &quot;Найди цифру $targetDigit&quot;&#10;    }&#10;&#10;    private fun finishGame() {&#10;        running = false&#10;        handler.removeCallbacks(updateTimer)&#10;        val elapsed = System.currentTimeMillis() - startTimeMs&#10;        val intent = Intent(this, SchulteNumbersResultsActivity::class.java)&#10;        intent.putExtra(&quot;elapsed&quot;, elapsed)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    private fun speakPraise() {&#10;        if (!ttsReady) return&#10;        val phrase = listOf(&#10;            &quot;Молодец!&quot;, &quot;Отлично!&quot;, &quot;Так держать!&quot;, &quot;Здорово!&quot;, &quot;Супер!&quot;&#10;        ).random()&#10;        // Не перекрываем последующее задание, добавляем в очередь&#10;        tts?.speak(phrase, TextToSpeech.QUEUE_FLUSH, null, &quot;schulte_praise&quot;)&#10;    }&#10;&#10;    private fun speakTarget() {&#10;        if (!ttsReady) return&#10;        val text = &quot;Найди цифру $targetDigit&quot;&#10;        tts?.speak(text, TextToSpeech.QUEUE_ADD, null, &quot;schulte_target_$targetDigit&quot;)&#10;    }&#10;&#10;    private fun formatTime(ms: Long): String {&#10;        val totalSec = ms / 1000&#10;        val min = totalSec / 60&#10;        val sec = totalSec % 60&#10;        val hund = (ms % 1000) / 10&#10;        return String.format(Locale.getDefault(), &quot;%02d:%02d.%02d&quot;, min, sec, hund)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val res = tts?.setLanguage(Locale(&quot;ru&quot;, &quot;RU&quot;))&#10;            if (res == TextToSpeech.LANG_MISSING_DATA || res == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                tts?.language = Locale.getDefault()&#10;            }&#10;            ttsReady = true&#10;            // Озвучим текущее задание при готовности TTS&#10;            speakTarget()&#10;        }&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        running = false&#10;        handler.removeCallbacks(updateTimer)&#10;        tts?.stop()&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        if (progressBar.progress &lt; progressBar.max) {&#10;            running = true&#10;            if (startTimeMs == 0L) startTimeMs = System.currentTimeMillis()&#10;            handler.post(updateTimer)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop(); tts?.shutdown(); tts = null&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/SchulteNumbersResultsActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabala/SchulteNumbersResultsActivity.kt" />
              <option name="originalContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import java.util.Locale&#10;&#10;class SchulteNumbersResultsActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var tts: TextToSpeech? = null&#10;    private var elapsedMs: Long = 0L&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_schulte_numbers_results)&#10;&#10;        elapsedMs = intent.getLongExtra(&quot;elapsed&quot;, 0L)&#10;        findViewById&lt;TextView&gt;(R.id.timeText).text = formatTime(elapsedMs)&#10;&#10;        tts = TextToSpeech(this, this)&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.btnBack).setOnClickListener { finish() }&#10;        findViewById&lt;CardView&gt;(R.id.btnPlayAgain).setOnClickListener {&#10;            tts?.stop()&#10;            startActivity(Intent(this, SchulteNumbersActivity::class.java))&#10;            finish()&#10;        }&#10;        findViewById&lt;CardView&gt;(R.id.btnBackToMenu).setOnClickListener {&#10;            tts?.stop()&#10;            val i = Intent(this, MathExercisesActivity::class.java)&#10;            i.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            startActivity(i)&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun formatTime(ms: Long): String {&#10;        val totalSec = ms / 1000&#10;        val min = totalSec / 60&#10;        val sec = totalSec % 60&#10;        val hund = (ms % 1000) / 10&#10;        return String.format(Locale.getDefault(), &quot;%02d:%02d.%02d&quot;, min, sec, hund)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            tts?.language = Locale.forLanguageTag(&quot;ru-RU&quot;)&#10;            val text = &quot;Отлично! Время ${formatTime(elapsedMs)}&quot;&#10;            tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, &quot;schulte_done&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop(); tts?.shutdown(); tts = null&#10;        super.onDestroy()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import java.util.Locale&#10;&#10;class SchulteNumbersResultsActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var tts: TextToSpeech? = null&#10;    private var elapsedMs: Long = 0L&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_schulte_numbers_results)&#10;&#10;        elapsedMs = intent.getLongExtra(&quot;elapsed&quot;, 0L)&#10;        findViewById&lt;TextView&gt;(R.id.timeText).text = formatTime(elapsedMs)&#10;&#10;        tts = TextToSpeech(this, this)&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.btnBack).setOnClickListener { finish() }&#10;        findViewById&lt;CardView&gt;(R.id.btnPlayAgain).setOnClickListener {&#10;            tts?.stop()&#10;            startActivity(Intent(this, SchulteNumbersActivity::class.java))&#10;            finish()&#10;        }&#10;        findViewById&lt;CardView&gt;(R.id.btnBackToMenu).setOnClickListener {&#10;            tts?.stop()&#10;            val i = Intent(this, MathExercisesActivity::class.java)&#10;            i.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            startActivity(i)&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun formatTime(ms: Long): String {&#10;        val totalSec = ms / 1000&#10;        val min = totalSec / 60&#10;        val sec = totalSec % 60&#10;        val hund = (ms % 1000) / 10&#10;        return String.format(Locale.getDefault(), &quot;%02d:%02d.%02d&quot;, min, sec, hund)&#10;    }&#10;&#10;    private fun plural(n: Long, forms: Triple&lt;String, String, String&gt;): String {&#10;        val nAbs = (n % 100).toInt()&#10;        val last = nAbs % 10&#10;        return when {&#10;            nAbs in 11..14 -&gt; forms.third&#10;            last == 1 -&gt; forms.first&#10;            last in 2..4 -&gt; forms.second&#10;            else -&gt; forms.third&#10;        }&#10;    }&#10;&#10;    private fun buildTimeSpeech(ms: Long): String {&#10;        val totalSec = ms / 1000&#10;        val minutes = totalSec / 60&#10;        val seconds = totalSec % 60&#10;        val minForm = plural(minutes, Triple(&quot;минута&quot;, &quot;минуты&quot;, &quot;минут&quot;))&#10;        val secForm = plural(seconds, Triple(&quot;секунда&quot;, &quot;секунды&quot;, &quot;секунд&quot;))&#10;        return when {&#10;            minutes &gt; 0 &amp;&amp; seconds &gt; 0 -&gt; &quot;за $minutes $minForm и $seconds $secForm&quot;&#10;            minutes &gt; 0 -&gt; &quot;за $minutes $minForm&quot;&#10;            else -&gt; &quot;за $seconds $secForm&quot;&#10;        }&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            tts?.language = Locale.forLanguageTag(&quot;ru-RU&quot;)&#10;            val kidsPhrases = listOf(&#10;                &quot;Молодец!&quot;, &quot;Отлично!&quot;, &quot;Здорово!&quot;, &quot;Ты умница!&quot;, &quot;Супер!&quot;, &quot;Браво!&quot;, &quot;Так держать!&quot;, &quot;У тебя получилось!&quot;&#10;            )&#10;            val timePart = buildTimeSpeech(elapsedMs)&#10;            val text = kidsPhrases.random() + &quot; Ты справился $timePart!&quot;&#10;            tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, &quot;schulte_done&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop(); tts?.shutdown(); tts = null&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabalanumbers/AudioButtonsAdapter.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabalanumbers/AudioButtonsAdapter.kt" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import androidx.cardview.widget.CardView&#10;import androidx.recyclerview.widget.RecyclerView&#10;&#10;class AudioButtonsAdapter(&#10;    private var items: MutableList&lt;MatchingItem&gt;,&#10;    private val onItemClick: (MatchingItem, View) -&gt; Unit&#10;) : RecyclerView.Adapter&lt;AudioButtonsAdapter.AudioButtonViewHolder&gt;() {&#10;&#10;    class AudioButtonViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {&#10;        val cardView: CardView = itemView.findViewById(R.id.cardView)&#10;    }&#10;&#10;    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AudioButtonViewHolder {&#10;        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_audio_button, parent, false)&#10;        return AudioButtonViewHolder(view)&#10;    }&#10;&#10;    override fun onBindViewHolder(holder: AudioButtonViewHolder, position: Int) {&#10;        val item = items[position]&#10;&#10;        // Устанавливаем прозрачность для сопоставленных элементов&#10;        holder.cardView.alpha = if (item.isMatched) 0.3f else 1.0f&#10;&#10;        holder.cardView.setOnClickListener {&#10;            if (!item.isMatched) {&#10;                // Простой эффект нажатия&#10;                holder.cardView.animate().scaleX(0.95f).scaleY(0.95f).setDuration(100)&#10;                    .withEndAction {&#10;                        holder.cardView.animate().scaleX(1.0f).scaleY(1.0f).setDuration(100).start()&#10;                    }.start()&#10;&#10;                onItemClick(item, holder.cardView)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun getItemCount(): Int = items.size&#10;&#10;    fun updateItems(newItems: List&lt;MatchingItem&gt;) {&#10;        items.clear()&#10;        items.addAll(newItems)&#10;        notifyDataSetChanged()&#10;    }&#10;&#10;    fun removeItem(item: MatchingItem) {&#10;        val position = items.indexOf(item)&#10;        if (position != -1) {&#10;            items.removeAt(position)&#10;            notifyItemRemoved(position)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabalanumbers/AudioMatchingActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabalanumbers/AudioMatchingActivity.kt" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.animation.Animator&#10;import android.animation.AnimatorListenerAdapter&#10;import android.animation.ValueAnimator&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.view.View&#10;import android.widget.ImageView&#10;import android.widget.LinearLayout&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import java.util.Locale&#10;import kotlin.random.Random&#10;&#10;class AudioMatchingActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private lateinit var audioButtonsRecyclerView: RecyclerView&#10;    private lateinit var numbersRecyclerView: RecyclerView&#10;    private lateinit var audioButtonsAdapter: AudioButtonsAdapter&#10;    private lateinit var numbersAdapter: NumbersAdapter&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var backButton: ImageView&#10;&#10;    private var currentLevel = 1&#10;    private var totalLevels = 10&#10;    private var levels = mutableListOf&lt;AudioMatchingLevel&gt;()&#10;    private var currentLevelData: AudioMatchingLevel? = null&#10;&#10;    private var selectedAudioItem: MatchingItem? = null&#10;    private var selectedNumberItem: MatchingItem? = null&#10;    private var selectedAudioView: View? = null&#10;    private var selectedNumberView: View? = null&#10;&#10;    private var completedMatches = 0&#10;    private var correctActions = 0&#10;    private var incorrectActions = 0&#10;&#10;    private lateinit var tts: TextToSpeech&#10;    private var isTtsReady = false&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_audio_matching)&#10;&#10;        initTTS()&#10;        initViews()&#10;        initData()&#10;        setupRecyclerViews()&#10;        loadLevel(currentLevel)&#10;    }&#10;&#10;    private fun initTTS() {&#10;        tts = TextToSpeech(this, this)&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val result = tts.setLanguage(Locale(&quot;ru&quot;))&#10;            isTtsReady = result != TextToSpeech.LANG_MISSING_DATA &amp;&amp; result != TextToSpeech.LANG_NOT_SUPPORTED&#10;        }&#10;    }&#10;&#10;    private fun speakNumber(number: Int) {&#10;        if (isTtsReady) {&#10;            val numberText = when (number) {&#10;                1 -&gt; &quot;один&quot;&#10;                2 -&gt; &quot;два&quot;&#10;                3 -&gt; &quot;три&quot;&#10;                4 -&gt; &quot;четыре&quot;&#10;                5 -&gt; &quot;пять&quot;&#10;                6 -&gt; &quot;шесть&quot;&#10;                7 -&gt; &quot;семь&quot;&#10;                8 -&gt; &quot;восемь&quot;&#10;                9 -&gt; &quot;девять&quot;&#10;                else -&gt; number.toString()&#10;            }&#10;            tts.speak(numberText, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;    }&#10;&#10;    private fun speakText(text: String) {&#10;        if (isTtsReady) {&#10;            tts.speak(text, TextToSpeech.QUEUE_FLUSH, null, null)&#10;        }&#10;    }&#10;&#10;    private fun initViews() {&#10;        audioButtonsRecyclerView = findViewById(R.id.audioButtonsRecyclerView)&#10;        numbersRecyclerView = findViewById(R.id.numbersRecyclerView)&#10;        progressBar = findViewById(R.id.progressBar)&#10;        backButton = findViewById(R.id.backButton)&#10;&#10;        backButton.setOnClickListener {&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun initData() {&#10;        levels = AudioMatchingGameData.generateAllLevels().toMutableList()&#10;    }&#10;&#10;    private fun setupRecyclerViews() {&#10;        audioButtonsAdapter = AudioButtonsAdapter(mutableListOf()) { item, view -&gt;&#10;            onAudioButtonClick(item, view)&#10;        }&#10;&#10;        numbersAdapter = NumbersAdapter(mutableListOf()) { item, view -&gt;&#10;            onNumberItemClick(item, view)&#10;        }&#10;&#10;        audioButtonsRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@AudioMatchingActivity)&#10;            adapter = audioButtonsAdapter&#10;        }&#10;&#10;        numbersRecyclerView.apply {&#10;            layoutManager = LinearLayoutManager(this@AudioMatchingActivity)&#10;            adapter = numbersAdapter&#10;        }&#10;    }&#10;&#10;    private fun loadLevel(level: Int) {&#10;        currentLevelData = levels[level - 1]&#10;        updateProgressBar()&#10;        completedMatches = 0&#10;&#10;        // Перемешиваем элементы для случайного порядка&#10;        val audioButtons = currentLevelData!!.pairs.map { it.number }.shuffled()&#10;        val numbers = currentLevelData!!.pairs.map { it.number }.shuffled()&#10;&#10;        audioButtonsAdapter.updateItems(audioButtons)&#10;        numbersAdapter.updateItems(numbers)&#10;&#10;        clearSelections()&#10;        resetViewsAlpha()&#10;    }&#10;&#10;    private fun updateProgressBar() {&#10;        val progress = (currentLevel * 100) / totalLevels&#10;        progressBar.progress = progress&#10;    }&#10;&#10;    private fun resetViewsAlpha() {&#10;        audioButtonsRecyclerView.post {&#10;            for (i in 0 until audioButtonsRecyclerView.childCount) {&#10;                val child = audioButtonsRecyclerView.getChildAt(i)&#10;                child.alpha = 1.0f&#10;                child.scaleX = 1.0f&#10;                child.scaleY = 1.0f&#10;            }&#10;        }&#10;&#10;        numbersRecyclerView.post {&#10;            for (i in 0 until numbersRecyclerView.childCount) {&#10;                val child = numbersRecyclerView.getChildAt(i)&#10;                child.alpha = 1.0f&#10;                child.scaleX = 1.0f&#10;                child.scaleY = 1.0f&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun onAudioButtonClick(item: MatchingItem, view: View) {&#10;        if (item.isMatched) return&#10;&#10;        // Озвучиваем число&#10;        speakNumber(item.value)&#10;&#10;        // Убираем предыдущее выделение&#10;        selectedAudioView?.let { prevView -&gt;&#10;            val linearLayout = prevView.findViewById&lt;LinearLayout&gt;(R.id.audioButtonLayout)&#10;            linearLayout?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, android.R.color.white))&#10;        }&#10;&#10;        if (selectedAudioItem == item) {&#10;            clearSelections()&#10;            return&#10;        }&#10;&#10;        selectedAudioItem = item&#10;        selectedAudioView = view&#10;&#10;        // Выделяем элемент зеленым цветом&#10;        val linearLayout = view.findViewById&lt;LinearLayout&gt;(R.id.audioButtonLayout)&#10;        linearLayout?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, android.R.color.holo_green_light))&#10;&#10;        checkMatch()&#10;    }&#10;&#10;    private fun onNumberItemClick(item: MatchingItem, view: View) {&#10;        if (item.isMatched) return&#10;&#10;        // Убираем предыдущее выделение&#10;        selectedNumberView?.let { prevView -&gt;&#10;            val numberText = prevView.findViewById&lt;TextView&gt;(R.id.numberText)&#10;            numberText?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, R.color.button_color))&#10;        }&#10;&#10;        if (selectedNumberItem == item) {&#10;            clearSelections()&#10;            return&#10;        }&#10;&#10;        selectedNumberItem = item&#10;        selectedNumberView = view&#10;&#10;        // Выделяем элемент зеленым цветом&#10;        val numberText = view.findViewById&lt;TextView&gt;(R.id.numberText)&#10;        numberText?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, android.R.color.holo_green_light))&#10;&#10;        checkMatch()&#10;    }&#10;&#10;    private fun checkMatch() {&#10;        val audioItem = selectedAudioItem&#10;        val numberItem = selectedNumberItem&#10;&#10;        if (audioItem != null &amp;&amp; numberItem != null) {&#10;            if (audioItem.value == numberItem.value) {&#10;                onCorrectMatch(audioItem, numberItem)&#10;            } else {&#10;                onIncorrectMatch()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun onCorrectMatch(audioItem: MatchingItem, numberItem: MatchingItem) {&#10;        correctActions++&#10;&#10;        val randomPhrase = MatchingFeedbackPhrases.correctPhrases[Random.nextInt(MatchingFeedbackPhrases.correctPhrases.size)]&#10;        speakText(randomPhrase)&#10;&#10;        audioItem.isMatched = true&#10;        numberItem.isMatched = true&#10;&#10;        animateMatch(selectedAudioView!!, selectedNumberView!!) {&#10;            audioButtonsAdapter.removeItem(audioItem)&#10;            numbersAdapter.removeItem(numberItem)&#10;&#10;            completedMatches++&#10;&#10;            if (completedMatches &gt;= 5) {&#10;                onLevelCompleted()&#10;            }&#10;        }&#10;&#10;        clearSelections()&#10;    }&#10;&#10;    private fun onIncorrectMatch() {&#10;        incorrectActions++&#10;&#10;        val randomPhrase = MatchingFeedbackPhrases.incorrectPhrases[Random.nextInt(MatchingFeedbackPhrases.incorrectPhrases.size)]&#10;        speakText(randomPhrase)&#10;&#10;        // Выделяем обе карточки красным цветом на полсекунды&#10;        selectedAudioView?.let { view -&gt;&#10;            val linearLayout = view.findViewById&lt;LinearLayout&gt;(R.id.audioButtonLayout)&#10;            linearLayout?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, android.R.color.holo_red_light))&#10;        }&#10;&#10;        selectedNumberView?.let { view -&gt;&#10;            val numberText = view.findViewById&lt;TextView&gt;(R.id.numberText)&#10;            numberText?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, android.R.color.holo_red_light))&#10;        }&#10;&#10;        // Через 500ms возвращаем зеленое выделение&#10;        android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;            selectedAudioView?.let { view -&gt;&#10;                val linearLayout = view.findViewById&lt;LinearLayout&gt;(R.id.audioButtonLayout)&#10;                linearLayout?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, android.R.color.holo_green_light))&#10;            }&#10;&#10;            selectedNumberView?.let { view -&gt;&#10;                val numberText = view.findViewById&lt;TextView&gt;(R.id.numberText)&#10;                numberText?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, android.R.color.holo_green_light))&#10;            }&#10;        }, 500)&#10;&#10;        animateIncorrectMatch(selectedAudioView!!, selectedNumberView!!)&#10;    }&#10;&#10;    private fun animateMatch(view1: View, view2: View, onComplete: () -&gt; Unit) {&#10;        val animator1 = ValueAnimator.ofFloat(1f, 0f)&#10;        val animator2 = ValueAnimator.ofFloat(1f, 0f)&#10;&#10;        animator1.duration = 300&#10;        animator2.duration = 300&#10;&#10;        animator1.addUpdateListener { animation -&gt;&#10;            val alpha = animation.animatedValue as Float&#10;            view1.alpha = alpha&#10;            view1.scaleX = alpha&#10;            view1.scaleY = alpha&#10;        }&#10;&#10;        animator2.addUpdateListener { animation -&gt;&#10;            val alpha = animation.animatedValue as Float&#10;            view2.alpha = alpha&#10;            view2.scaleX = alpha&#10;            view2.scaleY = alpha&#10;        }&#10;&#10;        animator1.addListener(object : AnimatorListenerAdapter() {&#10;            override fun onAnimationEnd(animation: Animator) {&#10;                onComplete()&#10;            }&#10;        })&#10;&#10;        animator1.start()&#10;        animator2.start()&#10;    }&#10;&#10;    private fun animateIncorrectMatch(view1: View, view2: View) {&#10;        val shake = ValueAnimator.ofFloat(0f, 25f, -25f, 25f, -25f, 15f, -15f, 6f, -6f, 0f)&#10;        shake.duration = 600&#10;&#10;        shake.addUpdateListener { animation -&gt;&#10;            val translateX = animation.animatedValue as Float&#10;            view1.translationX = translateX&#10;            view2.translationX = translateX&#10;        }&#10;&#10;        shake.addListener(object : AnimatorListenerAdapter() {&#10;            override fun onAnimationEnd(animation: Animator) {&#10;                view1.translationX = 0f&#10;                view2.translationX = 0f&#10;            }&#10;        })&#10;&#10;        shake.start()&#10;    }&#10;&#10;    private fun clearSelections() {&#10;        selectedAudioItem = null&#10;        selectedNumberItem = null&#10;&#10;        selectedAudioView?.let { view -&gt;&#10;            val linearLayout = view.findViewById&lt;LinearLayout&gt;(R.id.audioButtonLayout)&#10;            linearLayout?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, android.R.color.white))&#10;        }&#10;&#10;        selectedNumberView?.let { view -&gt;&#10;            val numberText = view.findViewById&lt;TextView&gt;(R.id.numberText)&#10;            numberText?.setBackgroundColor(androidx.core.content.ContextCompat.getColor(this, R.color.button_color))&#10;        }&#10;&#10;        selectedAudioView = null&#10;        selectedNumberView = null&#10;    }&#10;&#10;    private fun onLevelCompleted() {&#10;        if (currentLevel &lt; totalLevels) {&#10;            currentLevel++&#10;            loadLevel(currentLevel)&#10;        } else {&#10;            showResults()&#10;        }&#10;    }&#10;&#10;    private fun showResults() {&#10;        val finalScore = (correctActions * 10) - (incorrectActions * 5)&#10;&#10;        val intent = Intent(this, AudioMatchingResultsActivity::class.java)&#10;        intent.putExtra(&quot;completed_levels&quot;, currentLevel)&#10;        intent.putExtra(&quot;correct_actions&quot;, correctActions)&#10;        intent.putExtra(&quot;incorrect_actions&quot;, incorrectActions)&#10;        intent.putExtra(&quot;final_score&quot;, finalScore)&#10;        startActivity(intent)&#10;        finish()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        if (::tts.isInitialized) {&#10;            tts.stop()&#10;            tts.shutdown()&#10;        }&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabalanumbers/AudioMatchingModels.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabalanumbers/AudioMatchingModels.kt" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;data class AudioMatchingLevel(&#10;    val pairs: List&lt;AudioMatchingPair&gt;&#10;)&#10;&#10;data class AudioMatchingPair(&#10;    val number: MatchingItem // Используем ту же модель, что и в обычном сопоставлении&#10;)&#10;&#10;object AudioMatchingGameData {&#10;    fun generateAllLevels(): List&lt;AudioMatchingLevel&gt; {&#10;        val levels = mutableListOf&lt;AudioMatchingLevel&gt;()&#10;        &#10;        // Создаем 10 уровней&#10;        repeat(10) { levelIndex -&gt;&#10;            val pairs = mutableListOf&lt;AudioMatchingPair&gt;()&#10;            &#10;            // Генерируем 5 пар чисел для каждого уровня&#10;            val usedNumbers = mutableSetOf&lt;Int&gt;()&#10;            repeat(5) {&#10;                var number: Int&#10;                do {&#10;                    number = (1..9).random()&#10;                } while (usedNumbers.contains(number))&#10;                &#10;                usedNumbers.add(number)&#10;                &#10;                val matchingItem = MatchingItem(&#10;                    value = number,&#10;                    emoji = &quot;&quot;, // Для аудио кнопок не нужен emoji&#10;                    isMatched = false&#10;                )&#10;                &#10;                pairs.add(AudioMatchingPair(matchingItem))&#10;            }&#10;            &#10;            levels.add(AudioMatchingLevel(pairs))&#10;        }&#10;        &#10;        return levels&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabalanumbers/AudioMatchingResultsActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/timursarsembayev/danabalanumbers/AudioMatchingResultsActivity.kt" />
              <option name="updatedContent" value="package com.timursarsembayev.danabalanumbers&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.speech.tts.TextToSpeech&#10;import android.widget.ImageView&#10;import android.widget.TextView&#10;import androidx.appcompat.app.AppCompatActivity&#10;import androidx.cardview.widget.CardView&#10;import androidx.core.view.ViewCompat&#10;import androidx.core.view.WindowInsetsCompat&#10;import java.util.*&#10;import kotlin.random.Random&#10;&#10;class AudioMatchingResultsActivity : AppCompatActivity(), TextToSpeech.OnInitListener {&#10;&#10;    private var tts: TextToSpeech? = null&#10;    private var isTtsReady = false&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_audio_matching_results)&#10;&#10;        ViewCompat.setOnApplyWindowInsetsListener(findViewById(R.id.main)) { v, insets -&gt;&#10;            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())&#10;            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)&#10;            insets&#10;        }&#10;&#10;        // Инициализация TTS&#10;        tts = TextToSpeech(this, this)&#10;&#10;        setupViews()&#10;        setupButtons()&#10;    }&#10;&#10;    override fun onInit(status: Int) {&#10;        if (status == TextToSpeech.SUCCESS) {&#10;            val result = tts?.setLanguage(Locale(&quot;ru&quot;))&#10;            isTtsReady = result != TextToSpeech.LANG_MISSING_DATA &amp;&amp; result != TextToSpeech.LANG_NOT_SUPPORTED&#10;&#10;            if (isTtsReady) {&#10;                speakCongratulation()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupViews() {&#10;        val completedLevels = intent.getIntExtra(&quot;completed_levels&quot;, 10)&#10;        val correctActions = intent.getIntExtra(&quot;correct_actions&quot;, 0)&#10;        val incorrectActions = intent.getIntExtra(&quot;incorrect_actions&quot;, 0)&#10;        val finalScore = intent.getIntExtra(&quot;final_score&quot;, 0)&#10;&#10;        // Обновляем UI с результатами&#10;        findViewById&lt;TextView&gt;(R.id.completedLevelsText).text = &quot;Пройдено уровней: $completedLevels&quot;&#10;        findViewById&lt;TextView&gt;(R.id.correctActionsText).text = &quot;Правильных действий: $correctActions&quot;&#10;        findViewById&lt;TextView&gt;(R.id.incorrectActionsText).text = &quot;Ошибок: $incorrectActions&quot;&#10;        findViewById&lt;TextView&gt;(R.id.finalScoreText).text = &quot;Итоговые очки: $finalScore&quot;&#10;&#10;        // Определяем сообщение в зависимости от результата&#10;        val accuracy = if (correctActions + incorrectActions &gt; 0) {&#10;            (correctActions * 100) / (correctActions + incorrectActions)&#10;        } else {&#10;            100&#10;        }&#10;&#10;        val (message, encouragement) = when {&#10;            accuracy &gt;= 90 -&gt; Pair(&quot;Превосходно! &quot;, &quot;Ты отлично слышишь и различаешь числа!&quot;)&#10;            accuracy &gt;= 70 -&gt; Pair(&quot;Отлично! &quot;, &quot;Ты хорошо сопоставляешь звуки с цифрами!&quot;)&#10;            accuracy &gt;= 50 -&gt; Pair(&quot;Хорошо! &quot;, &quot;Продолжай тренироваться!&quot;)&#10;            else -&gt; Pair(&quot;Не сдавайся! &quot;, &quot;С каждым разом будет лучше!&quot;)&#10;        }&#10;&#10;        findViewById&lt;TextView&gt;(R.id.resultMessage).text = message&#10;        findViewById&lt;TextView&gt;(R.id.encouragementText).text = encouragement&#10;    }&#10;&#10;    private fun speakCongratulation() {&#10;        if (isTtsReady) {&#10;            val correctActions = intent.getIntExtra(&quot;correct_actions&quot;, 0)&#10;            val incorrectActions = intent.getIntExtra(&quot;incorrect_actions&quot;, 0)&#10;&#10;            val accuracy = if (correctActions + incorrectActions &gt; 0) {&#10;                (correctActions * 100) / (correctActions + incorrectActions)&#10;            } else {&#10;                100&#10;            }&#10;&#10;            val phrases = when {&#10;                accuracy == 100 -&gt; DifferentiatedCongratulationPhrases.perfect100Phrases&#10;                accuracy &gt;= 90 -&gt; DifferentiatedCongratulationPhrases.excellent90Phrases&#10;                accuracy &gt;= 80 -&gt; DifferentiatedCongratulationPhrases.good80Phrases&#10;                else -&gt; DifferentiatedCongratulationPhrases.encouragement80Phrases&#10;            }&#10;&#10;            val randomPhrase = phrases[Random.nextInt(phrases.size)]&#10;            tts?.speak(randomPhrase, TextToSpeech.QUEUE_FLUSH, null, &quot;congratulation&quot;)&#10;        }&#10;    }&#10;&#10;    private fun setupButtons() {&#10;        findViewById&lt;CardView&gt;(R.id.btnPlayAgain).setOnClickListener {&#10;            stopTTS()&#10;            val intent = Intent(this, AudioMatchingActivity::class.java)&#10;            startActivity(intent)&#10;            finish()&#10;        }&#10;&#10;        findViewById&lt;CardView&gt;(R.id.btnBackToMenu).setOnClickListener {&#10;            stopTTS()&#10;            val intent = Intent(this, MathExercisesActivity::class.java)&#10;            startActivity(intent)&#10;            finish()&#10;        }&#10;&#10;        findViewById&lt;ImageView&gt;(R.id.btnBack).setOnClickListener {&#10;            stopTTS()&#10;            finish()&#10;        }&#10;    }&#10;&#10;    private fun stopTTS() {&#10;        tts?.stop()&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        super.onDestroy()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/gradient_reading_background.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/gradient_reading_background.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;    &lt;gradient&#10;        android:startColor=&quot;#F3E5F5&quot;&#10;        android:centerColor=&quot;#E1BEE7&quot;&#10;        android:endColor=&quot;#CE93D8&quot;&#10;        android:angle=&quot;315&quot;&#10;        android:type=&quot;linear&quot; /&gt;&#10;&lt;/shape&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_0_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_0_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M100,50 C140,50 170,80 170,120 L170,230 C170,270 140,300 100,300 C60,300 30,270 30,230 L30,120 C30,80 60,50 100,50 Z&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_1_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_1_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M100,50 L100,250 M70,80 L100,50 M50,250 L150,250&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:strokeLineCap=&quot;round&quot;&#10;        android:strokeLineJoin=&quot;round&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_2_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_2_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M40,90 C40,65 60,50 100,50 C140,50 160,65 160,90 C160,115 140,130 100,130 L40,170 L160,170 M40,250 L160,250&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:strokeLineCap=&quot;round&quot;&#10;        android:strokeLineJoin=&quot;round&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_3_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_3_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M40,90 C40,65 60,50 100,50 C140,50 160,65 160,90 C160,115 140,130 100,130 C140,130 160,145 160,170 C160,195 140,210 100,210 C60,210 40,195 40,170 M100,130 L140,130&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:strokeLineCap=&quot;round&quot;&#10;        android:strokeLineJoin=&quot;round&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_4_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_4_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M40,50 L40,150 L120,150 M120,50 L120,250 M40,150 L160,150&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:strokeLineCap=&quot;round&quot;&#10;        android:strokeLineJoin=&quot;round&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_5_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_5_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M160,50 L40,50 L40,130 L100,130 C140,130 160,145 160,170 C160,195 140,210 100,210 C60,210 40,195 40,170&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:strokeLineCap=&quot;round&quot;&#10;        android:strokeLineJoin=&quot;round&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_6_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_6_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M160,80 C160,65 140,50 100,50 C60,50 40,65 40,80 L40,130 C40,145 60,160 100,160 C140,160 160,175 160,200 C160,225 140,240 100,240 C60,240 40,225 40,200&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:strokeLineCap=&quot;round&quot;&#10;        android:strokeLineJoin=&quot;round&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_7_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_7_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M40,50 L160,50 L60,250&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:strokeLineCap=&quot;round&quot;&#10;        android:strokeLineJoin=&quot;round&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_8_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_8_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M100,50 C140,50 160,65 160,90 C160,115 140,130 100,130 C60,130 40,115 40,90 C40,65 60,50 100,50 Z M100,130 C140,130 160,145 160,170 C160,195 140,210 100,210 C60,210 40,195 40,170 C40,145 60,130 100,130 Z&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:strokeLineCap=&quot;round&quot;&#10;        android:strokeLineJoin=&quot;round&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/number_9_outline.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/number_9_outline.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;300dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;300&quot;&gt;&#10;    &#10;    &lt;path&#10;        android:pathData=&quot;M100,50 C140,50 160,65 160,90 C160,115 140,130 100,130 C60,130 40,115 40,90 C40,65 60,50 100,50 M160,90 L160,170 C160,195 140,210 100,210 C60,210 40,195 40,170&quot;&#10;        android:strokeColor=&quot;#000000&quot;&#10;        android:strokeWidth=&quot;8&quot;&#10;        android:strokeLineCap=&quot;round&quot;&#10;        android:strokeLineJoin=&quot;round&quot;&#10;        android:fillColor=&quot;@android:color/transparent&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_ascending_numbers.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_ascending_numbers.xml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_descending_numbers.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_descending_numbers.xml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_letter_recognition_fixed.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_letter_recognition_fixed.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/main&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:background=&quot;@drawable/gradient_exercise_background&quot;&#10;    android:padding=&quot;16dp&quot;&#10;    tools:context=&quot;.LetterRecognitionActivity&quot;&gt;&#10;&#10;    &lt;!-- Верхняя панель с кнопкой назад, заголовком и прогресс-баром --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:gravity=&quot;center_vertical&quot;&#10;        android:layout_marginBottom=&quot;20dp&quot;&gt;&#10;&#10;        &lt;!-- Кнопка назад --&gt;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/backButton&quot;&#10;            android:layout_width=&quot;32dp&quot;&#10;            android:layout_height=&quot;32dp&quot;&#10;            android:src=&quot;@drawable/ic_arrow_back&quot;&#10;            android:background=&quot;?attr/selectableItemBackgroundBorderless&quot;&#10;            android:padding=&quot;4dp&quot;&#10;            android:clickable=&quot;true&quot;&#10;            android:focusable=&quot;true&quot;&#10;            android:contentDescription=&quot;Назад&quot; /&gt;&#10;&#10;        &lt;!-- Заголовок --&gt;&#10;        &lt;TextView&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot; Найди букву&quot;&#10;            android:textSize=&quot;20sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#8E24AA&quot;&#10;            android:layout_marginStart=&quot;12dp&quot;&#10;            android:gravity=&quot;start&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Прогресс-бар --&gt;&#10;    &lt;ProgressBar&#10;        android:id=&quot;@+id/progressBar&quot;&#10;        style=&quot;?android:attr/progressBarStyleHorizontal&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;8dp&quot;&#10;        android:layout_marginBottom=&quot;30dp&quot;&#10;        android:max=&quot;100&quot;&#10;        android:progress=&quot;3&quot;&#10;        android:progressTint=&quot;#9C27B0&quot;&#10;        android:progressBackgroundTint=&quot;#E0E0E0&quot; /&gt;&#10;&#10;    &lt;!-- Красивая кнопка озвучивания --&gt;&#10;    &lt;androidx.cardview.widget.CardView&#10;        android:layout_width=&quot;80dp&quot;&#10;        android:layout_height=&quot;80dp&quot;&#10;        android:layout_gravity=&quot;center&quot;&#10;        android:layout_marginBottom=&quot;40dp&quot;&#10;        app:cardCornerRadius=&quot;40dp&quot;&#10;        app:cardElevation=&quot;12dp&quot;&#10;        app:cardBackgroundColor=&quot;#8E24AA&quot;&gt;&#10;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/speakerButton&quot;&#10;            android:layout_width=&quot;48dp&quot;&#10;            android:layout_height=&quot;48dp&quot;&#10;            android:layout_gravity=&quot;center&quot;&#10;            android:src=&quot;@drawable/ic_volume_up&quot;&#10;            android:background=&quot;?attr/selectableItemBackgroundBorderless&quot;&#10;            android:clickable=&quot;true&quot;&#10;            android:focusable=&quot;true&quot;&#10;            android:contentDescription=&quot;Озвучить вопрос&quot;&#10;            android:tint=&quot;#FFFFFF&quot;&#10;            android:scaleType=&quot;centerInside&quot; /&gt;&#10;&#10;    &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;    &lt;!-- Сетка карточек с буквами (2x2) --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:gravity=&quot;center&quot;&gt;&#10;&#10;        &lt;!-- Первый ряд --&gt;&#10;        &lt;LinearLayout&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:orientation=&quot;horizontal&quot;&#10;            android:gravity=&quot;center&quot;&#10;            android:layout_marginBottom=&quot;20dp&quot;&gt;&#10;&#10;            &lt;!-- Карточка 1 --&gt;&#10;            &lt;androidx.cardview.widget.CardView&#10;                android:id=&quot;@+id/card1&quot;&#10;                android:layout_width=&quot;120dp&quot;&#10;                android:layout_height=&quot;120dp&quot;&#10;                android:layout_margin=&quot;12dp&quot;&#10;                android:clickable=&quot;true&quot;&#10;                android:focusable=&quot;true&quot;&#10;                android:foreground=&quot;?android:attr/selectableItemBackground&quot;&#10;                app:cardCornerRadius=&quot;20dp&quot;&#10;                app:cardElevation=&quot;8dp&quot;&#10;                app:cardBackgroundColor=&quot;#FFFFFF&quot;&gt;&#10;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/letter1&quot;&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;match_parent&quot;&#10;                    android:text=&quot;А&quot;&#10;                    android:textSize=&quot;48sp&quot;&#10;                    android:textStyle=&quot;bold&quot;&#10;                    android:textColor=&quot;#8E24AA&quot;&#10;                    android:gravity=&quot;center&quot; /&gt;&#10;&#10;            &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;            &lt;!-- Карточка 2 --&gt;&#10;            &lt;androidx.cardview.widget.CardView&#10;                android:id=&quot;@+id/card2&quot;&#10;                android:layout_width=&quot;120dp&quot;&#10;                android:layout_height=&quot;120dp&quot;&#10;                android:layout_margin=&quot;12dp&quot;&#10;                android:clickable=&quot;true&quot;&#10;                android:focusable=&quot;true&quot;&#10;                android:foreground=&quot;?android:attr/selectableItemBackground&quot;&#10;                app:cardCornerRadius=&quot;20dp&quot;&#10;                app:cardElevation=&quot;8dp&quot;&#10;                app:cardBackgroundColor=&quot;#FFFFFF&quot;&gt;&#10;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/letter2&quot;&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;match_parent&quot;&#10;                    android:text=&quot;Б&quot;&#10;                    android:textSize=&quot;48sp&quot;&#10;                    android:textStyle=&quot;bold&quot;&#10;                    android:textColor=&quot;#8E24AA&quot;&#10;                    android:gravity=&quot;center&quot; /&gt;&#10;&#10;            &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;        &lt;/LinearLayout&gt;&#10;&#10;        &lt;!-- Второй ряд --&gt;&#10;        &lt;LinearLayout&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:orientation=&quot;horizontal&quot;&#10;            android:gravity=&quot;center&quot;&gt;&#10;&#10;            &lt;!-- Карточка 3 --&gt;&#10;            &lt;androidx.cardview.widget.CardView&#10;                android:id=&quot;@+id/card3&quot;&#10;                android:layout_width=&quot;120dp&quot;&#10;                android:layout_height=&quot;120dp&quot;&#10;                android:layout_margin=&quot;12dp&quot;&#10;                android:clickable=&quot;true&quot;&#10;                android:focusable=&quot;true&quot;&#10;                android:foreground=&quot;?android:attr/selectableItemBackground&quot;&#10;                app:cardCornerRadius=&quot;20dp&quot;&#10;                app:cardElevation=&quot;8dp&quot;&#10;                app:cardBackgroundColor=&quot;#FFFFFF&quot;&gt;&#10;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/letter3&quot;&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;match_parent&quot;&#10;                    android:text=&quot;В&quot;&#10;                    android:textSize=&quot;48sp&quot;&#10;                    android:textStyle=&quot;bold&quot;&#10;                    android:textColor=&quot;#8E24AA&quot;&#10;                    android:gravity=&quot;center&quot; /&gt;&#10;&#10;            &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;            &lt;!-- Карточка 4 --&gt;&#10;            &lt;androidx.cardview.widget.CardView&#10;                android:id=&quot;@+id/card4&quot;&#10;                android:layout_width=&quot;120dp&quot;&#10;                android:layout_height=&quot;120dp&quot;&#10;                android:layout_margin=&quot;12dp&quot;&#10;                android:clickable=&quot;true&quot;&#10;                android:focusable=&quot;true&quot;&#10;                android:foreground=&quot;?android:attr/selectableItemBackground&quot;&#10;                app:cardCornerRadius=&quot;20dp&quot;&#10;                app:cardElevation=&quot;8dp&quot;&#10;                app:cardBackgroundColor=&quot;#FFFFFF&quot;&gt;&#10;&#10;                &lt;TextView&#10;                    android:id=&quot;@+id/letter4&quot;&#10;                    android:layout_width=&quot;match_parent&quot;&#10;                    android:layout_height=&quot;match_parent&quot;&#10;                    android:text=&quot;Г&quot;&#10;                    android:textSize=&quot;48sp&quot;&#10;                    android:textStyle=&quot;bold&quot;&#10;                    android:textColor=&quot;#8E24AA&quot;&#10;                    android:gravity=&quot;center&quot; /&gt;&#10;&#10;            &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;        &lt;/LinearLayout&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_number_sequence_results.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_number_sequence_results.xml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_schulte_numbers.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_schulte_numbers.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/main&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:background=&quot;@drawable/child_gradient_blue&quot;&#10;    android:padding=&quot;12dp&quot;&#10;    tools:context=&quot;.SchulteNumbersActivity&quot;&gt;&#10;&#10;    &lt;!-- Header: Back + Timer + Target --&gt;&#10;    &lt;TextView&#10;        android:id=&quot;@+id/textView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:text=&quot;Цифровой&quot; /&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:gravity=&quot;center_vertical&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;&gt;&#10;&#10;        &lt;ImageButton&#10;            android:id=&quot;@+id/buttonBack&quot;&#10;            android:layout_width=&quot;40dp&quot;&#10;            android:layout_height=&quot;40dp&quot;&#10;            android:background=&quot;?attr/selectableItemBackgroundBorderless&quot;&#10;            android:src=&quot;@drawable/ic_arrow_back&quot;&#10;            android:contentDescription=&quot;Назад&quot;&#10;            android:layout_marginEnd=&quot;12dp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/timerView&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;00:00.00&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#1565C0&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/targetView&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Найди цифру 0&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#1565C0&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Game View --&gt;&#10;    &lt;com.timursarsembayev.danabalanumbers.SchulteNumbersView&#10;        android:id=&quot;@+id/schulteGameView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:padding=&quot;8dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/main&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:background=&quot;@drawable/child_gradient_blue&quot;&#10;    android:padding=&quot;16dp&quot;&#10;    tools:context=&quot;.SchulteNumbersActivity&quot;&gt;&#10;&#10;    &lt;!-- Верхняя панель: назад + заголовок (стандарт) --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:gravity=&quot;center_vertical&quot;&#10;        android:layout_marginBottom=&quot;12dp&quot;&gt;&#10;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/backButton&quot;&#10;            android:layout_width=&quot;32dp&quot;&#10;            android:layout_height=&quot;32dp&quot;&#10;            android:src=&quot;@drawable/ic_arrow_back&quot;&#10;            android:background=&quot;?attr/selectableItemBackgroundBorderless&quot;&#10;            android:padding=&quot;4dp&quot;&#10;            android:clickable=&quot;true&quot;&#10;            android:focusable=&quot;true&quot;&#10;            android:contentDescription=&quot;Назад&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/headerTitle&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot; Шульт��: найди цифры&quot;&#10;            android:textSize=&quot;20sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#1565C0&quot;&#10;            android:layout_marginStart=&quot;12dp&quot;&#10;            android:gravity=&quot;start&quot; /&gt;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Прогресс-бар --&gt;&#10;    &lt;ProgressBar&#10;        android:id=&quot;@+id/progressBar&quot;&#10;        style=&quot;?android:attr/progressBarStyleHorizontal&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;8dp&quot;&#10;        android:max=&quot;10&quot;&#10;        android:progress=&quot;0&quot;&#10;        android:progressTint=&quot;#4CAF50&quot;&#10;        android:progressBackgroundTint=&quot;#E0E0E0&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot; /&gt;&#10;&#10;    &lt;!-- Строка статуса: таймер + задание --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:gravity=&quot;center_vertical&quot;&#10;        android:layout_marginBottom=&quot;8dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/timerView&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;00:00.00&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#1565C0&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/targetView&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Найди цифру 0&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#1565C0&quot; /&gt;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Игровое поле --&gt;&#10;    &lt;com.timursarsembayev.danabalanumbers.SchulteNumbersView&#10;        android:id=&quot;@+id/schulteGameView&quot;&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:padding=&quot;8dp&quot; /&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/layout/activity_schulte_numbers_results.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/layout/activity_schulte_numbers_results.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    android:id=&quot;@+id/main&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:background=&quot;@drawable/child_gradient_blue&quot;&#10;    android:padding=&quot;16dp&quot;&#10;    tools:context=&quot;.SchulteNumbersResultsActivity&quot;&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:gravity=&quot;center_vertical&quot;&#10;        android:layout_marginBottom=&quot;12dp&quot;&gt;&#10;&#10;        &lt;ImageButton&#10;            android:id=&quot;@+id/backButton&quot;&#10;            android:layout_width=&quot;40dp&quot;&#10;            android:layout_height=&quot;40dp&quot;&#10;            android:background=&quot;?attr/selectableItemBackgroundBorderless&quot;&#10;            android:src=&quot;@drawable/ic_arrow_back&quot;&#10;            android:contentDescription=&quot;Назад&quot;&#10;            android:layout_marginEnd=&quot;12dp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;&quot;&#10;            android:textSize=&quot;22sp&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Результат&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#1565C0&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:gravity=&quot;center&quot;&#10;        android:layout_marginBottom=&quot;16dp&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Время:&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#1565C0&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/timeValue&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;00:00.00&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#1565C0&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:gravity=&quot;center&quot;&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/buttonRestart&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;48dp&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;Ещё раз&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#FFFFFF&quot;&#10;            android:background=&quot;@drawable/button_primary&quot;&#10;            android:layout_marginEnd=&quot;8dp&quot; /&gt;&#10;&#10;        &lt;Button&#10;            android:id=&quot;@+id/buttonHome&quot;&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;48dp&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;На главную&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#FFFFFF&quot;&#10;            android:background=&quot;@drawable/button_next&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&#10;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&#10;    android:id=&quot;@+id/main&quot;&#10;    android:layout_width=&quot;match_parent&quot;&#10;    android:layout_height=&quot;match_parent&quot;&#10;    android:orientation=&quot;vertical&quot;&#10;    android:padding=&quot;16dp&quot;&#10;    android:background=&quot;@drawable/gradient_celebration_background&quot;&#10;    tools:context=&quot;.SchulteNumbersResultsActivity&quot;&gt;&#10;&#10;    &lt;!-- Верхняя панель (стандарт) --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;horizontal&quot;&#10;        android:gravity=&quot;center_vertical&quot;&#10;        android:layout_marginBottom=&quot;20dp&quot;&gt;&#10;&#10;        &lt;ImageView&#10;            android:id=&quot;@+id/btnBack&quot;&#10;            android:layout_width=&quot;32dp&quot;&#10;            android:layout_height=&quot;32dp&quot;&#10;            android:src=&quot;@drawable/ic_arrow_back&quot;&#10;            android:background=&quot;?attr/selectableItemBackgroundBorderless&quot;&#10;            android:padding=&quot;4dp&quot;&#10;            android:clickable=&quot;true&quot;&#10;            android:focusable=&quot;true&quot;&#10;            android:contentDescription=&quot;Назад&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:layout_width=&quot;0dp&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:layout_weight=&quot;1&quot;&#10;            android:text=&quot;Результат&quot;&#10;            android:textSize=&quot;18sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#1565C0&quot;&#10;            android:layout_marginStart=&quot;12dp&quot;&#10;            android:gravity=&quot;start&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Основной контент --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;0dp&quot;&#10;        android:layout_weight=&quot;1&quot;&#10;        android:orientation=&quot;vertical&quot;&#10;        android:gravity=&quot;center&quot;&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/emojiText&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;&quot;&#10;            android:textSize=&quot;80sp&quot;&#10;            android:layout_marginBottom=&quot;24dp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/messageTitleText&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;Твой результат&quot;&#10;            android:textSize=&quot;16sp&quot;&#10;            android:textColor=&quot;#666666&quot;&#10;            android:layout_marginBottom=&quot;8dp&quot; /&gt;&#10;&#10;        &lt;TextView&#10;            android:id=&quot;@+id/timeText&quot;&#10;            android:layout_width=&quot;wrap_content&quot;&#10;            android:layout_height=&quot;wrap_content&quot;&#10;            android:text=&quot;00:00.00&quot;&#10;            android:textSize=&quot;32sp&quot;&#10;            android:textStyle=&quot;bold&quot;&#10;            android:textColor=&quot;#2E7D32&quot;&#10;            android:layout_marginBottom=&quot;8dp&quot; /&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;    &lt;!-- Кнопки --&gt;&#10;    &lt;LinearLayout&#10;        android:layout_width=&quot;match_parent&quot;&#10;        android:layout_height=&quot;wrap_content&quot;&#10;        android:orientation=&quot;vertical&quot;&gt;&#10;&#10;        &lt;androidx.cardview.widget.CardView&#10;            android:id=&quot;@+id/btnPlayAgain&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;56dp&quot;&#10;            android:layout_marginBottom=&quot;12dp&quot;&#10;            android:clickable=&quot;true&quot;&#10;            android:focusable=&quot;true&quot;&#10;            android:foreground=&quot;?android:attr/selectableItemBackground&quot;&#10;            app:cardCornerRadius=&quot;16dp&quot;&#10;            app:cardElevation=&quot;6dp&quot;&#10;            app:cardBackgroundColor=&quot;#4CAF50&quot;&gt;&#10;&#10;            &lt;TextView&#10;                android:layout_width=&quot;match_parent&quot;&#10;                android:layout_height=&quot;match_parent&quot;&#10;                android:text=&quot;Ещё раз&quot;&#10;                android:textSize=&quot;18sp&quot;&#10;                android:textStyle=&quot;bold&quot;&#10;                android:textColor=&quot;#FFFFFF&quot;&#10;                android:gravity=&quot;center&quot; /&gt;&#10;&#10;        &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;        &lt;androidx.cardview.widget.CardView&#10;            android:id=&quot;@+id/btnBackToMenu&quot;&#10;            android:layout_width=&quot;match_parent&quot;&#10;            android:layout_height=&quot;56dp&quot;&#10;            android:clickable=&quot;true&quot;&#10;            android:focusable=&quot;true&quot;&#10;            android:foreground=&quot;?android:attr/selectableItemBackground&quot;&#10;            app:cardCornerRadius=&quot;16dp&quot;&#10;            app:cardElevation=&quot;6dp&quot;&#10;            app:cardBackgroundColor=&quot;#2196F3&quot;&gt;&#10;&#10;            &lt;TextView&#10;                android:layout_width=&quot;match_parent&quot;&#10;                android:layout_height=&quot;match_parent&quot;&#10;                android:text=&quot;В меню&quot;&#10;                android:textSize=&quot;18sp&quot;&#10;                android:textStyle=&quot;bold&quot;&#10;                android:textColor=&quot;#FFFFFF&quot;&#10;                android:gravity=&quot;center&quot; /&gt;&#10;&#10;        &lt;/androidx.cardview.widget.CardView&gt;&#10;&#10;    &lt;/LinearLayout&gt;&#10;&#10;&lt;/LinearLayout&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>